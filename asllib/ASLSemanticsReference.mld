{0
          ASL Semantics Reference
}

{1
Monadic operators                               
}

The basic bricks of the semantics are monadic operators, viz:
  + returns [return_<continuation>];
  + binds [bind_<composition>];
  + product [prod_par];
  + application [appl_data].  

{2
Return
}
 
Each return_<continuation> function performs a specific continuation, as
follows.
  {3 Normal}
  [return_normal] <description, minimal example>

  {3 Continue}
  [return_continue] <description, minimal example>

  {3 Return}
  [return_return] <description, minimal example>

{2
Bind 
}

Each bind_<composition> function performs a specific
composition, as follows. 

  {3 Sequential}
  [bind_seq], also written [let*|], denotes the program order,
  as given by [;] in the ASL code.  <minimal example>

  {3 Data}
  [bind_data], also written [let*] and [>>=] hands over the
data of its first argument to its second argument. Graphically,
it creates an Intrinsic Data Dependency between the Effects
generated by it first argument and the Effects generated by its
result.  <minimal example>

  {3 Control}
  [bind_ctrl] creates an Intrinsic Control Dependency between
the Effects generates by its first argument and the Effects
generated by its results.  <minimal example>

  {3 Choice}
  [bind_choice_m] and [bind_choice] make a choice between
different values

  {3 Exception}
  [bind_exception] (and its specific instances
[bind_exception_seq] also written [let**|],
[bind_exception_data] also written [let**],
[bind_exception_ctrl]), creates an Intrinsic Dependency as
mandated by its [_composition] binder, and throws an exception
when necessary.  <minimal example>

  {3 Continue}
  [bind_continue m f], also written [let*>], executes [f] on
[m] only if [m] is [Normal (Continuing _)] <minimal example> 

  {3 Unroll}
  [bind_unroll "while" m f] executes [f] on [m] after having
ticked the unrolling stack of [m] only if [m] is [Normal
(Continuing _)] <minimal example>

  {3 Thrown}
  [bind_thrown] and [bind_explicit_thrown] handle [throw]
statements <minimal example>

{2 
Product
}
  
[prod_par], also written [and*], ensures that evaluation is
done in parallel <minimal example>


{2
Application 
}

Application, viz,  [appl_data], also written [>=>], ensures that evaluation
follows function application <minimal example>


{1
Environments                               
}

An environment is what the semantics operates over: a structure
which amongst other things associates values to variables.
Intuitively, the evaluation of a program makes an initial
environment evolve, with new values as given by the operations
of the program.

The initial environment is built with the help of the
[build_<object>] functions.  Each [build_<object>] function
builds a specific object, as follows.

  {2 Base Value}
  [base_value] <description, minimal example>

  {2 Function Calls}
  [build_func_call_ref] <description, minimal example>

  {2 Global Storage}
  [build_global_storage] <description, minimal example>

  {2 Global Environment}
  [build_global_env] <description, minimal example>

  {2 Bind Environment}
  [bind_env], also written [let*^], <description, minimal example>

Evaluating a program is evaluating its main function.
Constructively, evaluating a program requires following its
Abstract Syntax Tree and evaluating each of its components.

{1
Evaluation 
}                          
Formally, the semantics of a program are given by applying a
set of eval_<object> functions. Each eval_<object> function
describes how to evaluate a specific object, as follows.

      + [eval_expr] evaluates expressions: it takes an
environment and an expression and returns a wrapped value and a
new environment <minimal example>
      + [eval_expr_sef] evaluates expressions without side
effects <description, minimal example>
      + [eval_expr_list] and [eval_expr_list_m] evaluate lists
of expressions <description, minimal example>
      + [eval_slices] evaluates slices <description, minimal
example>
      + [eval_patterns] evaluates patterns <description,
minimal example>
      + [eval_local_decl] evaluates local declarations
<description, minimal example>
      + [eval_lexpr] evaluates left-hand sides of assignments:
it takes an environment, the left-hand side of an assignment
and a wrapped value to be written, and returns a wrapped
environment updated with the new value.  <description, minimal
example>
      + [eval_stmt] evaluates statements: it takes an
environment and a statement and returns a wrapped new
environment, viz, the environment updated with the side-effects
of the statement. <minimal example>
      + [eval_block] evaluates blocks <description, minimal
example>
      + [eval_loop] evaluates both while and repeat loops
<description, minimal example>
      + [eval_for] evaluates for loops <description, minimal
example>
      + [eval_catchers] evaluates catchers <description,
minimal example>
      + [eval_call] evaluates functions calls <description,
minimal example>
      + [eval_func] evaluates functions: it takes an
environment, a function name and its arguments, and returns a
wrapped list of the return values of the function. The
evaluation of a program is the evaluation of its main function.
<minimal example>

{2
Evaluation of Expressions 
}

[eval_expr] specifies how to evaluate an expression [e] in an
environment [env]. More precisely, [eval_expr env e] is the
monadic evaluation  of [e] in [env]. 

The evaluation of the expression [e] under an environment [env]
is [v] and one of the following applies:

{3 Rule.Lit}  
[e] denotes a Literal [l] and [v] is the value of [l] in [env]. 

<minimal example>

{3 Rule.IgnoreTypedExpr}
[(e,_t)] denotes a typed expression and <description> 

<minimal example>

{3 Rule.ELocalVar}
[e] denotes a variable [x] which is bound locally in
[env] and [v] is the value of [x] in [env].

<minimal example>

{3 Rule.EGlobalVar}
[e] denotes a variable [x] which is bound globally in [env] and
[v] is the value of [x] in [env].

<minimal example>

{3 Rule.EUndefIdent}
[e] denotes a variable [x] which is not bound in [env] and an
Error "UndefinedIdentifier" is raised.

<minimal example>

{3 Rule.Binop}
[e] denotes a Binary Operator [op] over two expressions [e1] and
[e2] and all of the following applies:
  - The evaluation of the expression [e1] under [env] is [v1];
  - The evaluation of the expression [e2] under [env] is [v2];
  - [v] is the result of applying the Binary Operator [op] to [v1] and [v2].

<minimal example>

{3 Rule.Unop} 
[e] denotes a Unary Operator [op] over an expression [e] and all of
the following applies:
  - The evaluation of the expression [e] under [env] is [t];
  - [v] is the result of applying the Unary Operator [op] to [t].

<minimal example>

{3 Rule.ECondSimple} 
[e] denotes a condition [econd] with two options [e1] and [e2] and
all of the following applies:
  - The evaluation of the condition [econd] under [env] is mcond;
  - Both [e1] and [e2] are simple expressions; EUndefIdent
  - The evaluation of [e1] or [e2], depending on [mcond], is [v].

<minimal example>

{3 Rule.ECond} 
[e] denotes a condition [e_cond] with two options [e1] and [e2] and all of
the following applies:
   - The evaluation of the condition [e_cond] under [env] is [m_cond];
   - One of [e1] or [e2] is not a simple expression;
   - The evaluation of [e1] or [e2], depending on [m_cond], is [v].

<minimal example>

{3 Rule.ESlice}
[e] denotes an expression [e_bv] sliced as per [slices] and all of the following applies:
  - The evaluation of [e_bv] under [env] is [v_bv];
  - The evaluation of [slices] under [env] is [positions];
  - [v] is the value read in [v_bv] from [positions].

<minimal example>

{3 Rule.ECall}
[e] denotes a function call [(name, actual_args, params)] and all of the following applies:
  - The evaluation of that function call under [env] is [ms];
  - [v] is the value read from [ms]. 

<minimal example>

{3 Rule.EGetArray}
[e] denotes an array [e_array] and an index [e_index] and all of the following applies
- The evaluation of [e_array] under [env] is [v_array];
- The evaluation of [e_index] under [env] is [v_index];
- [v] is the value found at the index [v_index] of [v_array].

<minimal example>

{3 Rule.ERecord} 
[e] denotes a series of field names [names] and associated expressions [fields]
and all of the following applies:
- [fields] evaluates in [env] to [v_fields];
- [v] is the record built by associating the names [names] to [v_fields].

<minimal example>

{3 Rule.EGetField}
[e] denotes a field name [field_name] in a vector [e_vec] and all of the following applies:
- the evaluation of [e_vec] in [env] is [v_vec];
- [v] is the value mapped by [field_name] in [v_vec].

<minimal example>

{3 Rule.EGetFields}
<description> 

<minimal example>

{3 Rule.EConcat} 
[e] denotes a list of expressions [e_list] and all of the following applies:
- the evaluation of [e_list] in [env] is [v_list]; 
- [v] is the concatenation of [v_list].

<minimal example>

{3 Rule.ETuple} 
[e] denotes a list of expression [e_list] and all of the following applies:
- the evaluation of [e_list] in [env] is [v_list];
- [v] is the vector built from [v_list].

<minimal example>

{3 Rule.EUnknown} 
[e] denotes a type [t] and [v] is a value in the domain of [t].

<minimal example>

{3 Rule.EPattern} 
[e] denotes a pattern [e,p] and [v] is the boolean determining whether the
evaluation of [e] in [env] matches [p].

<minimal example>

{2 
Evaluation of Side-Effect-Free Expressions
}
[eval_expr_sef] specifies how to evaluate a side-effect-free expression [e] in
an environment [env]. More precisely, [eval_expr_sef env e] is the [eval_expr
env e], if e is side-effect-free. 
<minimal example>

{2
Evaluation of Left-Hand-Side Expressions 
}
[eval_lexpr version env le m] is [env[le --> m]]. 

The evaluation of the left-hand-side expression [le] associated with a value
[v] under an environment [env] is [new_env] and one of the following applies:

  {3 Rule.LEIgnore}
  [le] can be ignored and [new_env] is [env]. 

  <minimal example>

  {3 Rule.LELocalVar}
  [le] denotes a variable [x] and all of the following applies:
  - [new_env] is a local environment; 
  - [new_env] is [env] where [x] has been assigned the value [v].

  <minimal example>

  {3 Rule.LEGlobalVar}
  [le] denotes a variable [x] and all of the following applies:
  - [new_env] is a global environment; 
  - [new_env] is [env] where [x] has been assigned the value [v].

  <minimal example>

  {3 Rule.LEUndefIdentV1}
  [le] denotes a variable [x] which is not bound in [env] and all of the following applies:
  - the ASL language version is V1;
  - an Error "UndefinedIdentifier" is raised.

  <minimal example>

  {3 Rule.LEUndefIdentV0}
  [le] denotes a variable [x] which is not bound in [env] and all of the following applies:
  - the ASL language version is V0;
  - [new_env] is [env] where [x] has been declared a local identifier bound to the value [v].

  <minimal example>

  {3 Rule.LESlice}
  [le] denotes an expression [e_bv] sliced as per [slices] and all of the following applies:
  - The evaluation of [e_bv] under [env] is [v_bv];
  - The evaluation of [slices] under [env] is [positions];
  - [v] is the value read in [v_bv] from [positions];
  - [new_env] is [env] where [le] has been assigned the value [v].

  <minimal example>

  {3 Rule.LESetArray}
  [le] denotes an array [e_array] and an index [e_index] and all of the following applies:
  - The evaluation of [e_array] under [env] is [v_array];
  - The evaluation of [e_index] under [env] is [v_index];
  - [v] is the value found at the index [v_index] of [v_array];
  - [new_env] is [env] where [le] has been assigned the value [v].

  <minimal example>

  {3 Rule.LESetField}
  [le] denotes a field name [field_name] in a vector [e_vec] and all of the following applies:
  - The evaluation of [e_vec] under [env] is [v_vec];
  - [v] is the value mapped by [field_name] in [v_vec];
  - [new_env] is [env] where [le] has been assigned the value [v].
 
  <minimal example>

  {3 Rule.LESetFields}
  <description> 
  <minimal example>

  {3 Rule.LETuple}
  [le] denotes a list of expression [e_list] and all of the following applies:
  - the evaluation of [e_list] in [env] is [v_list];
  - [v] is the vector built from [v_list];
  - [new_env] is [env] where [le] has been assigned the value [v].

  <minimal example>

{2 
Evaluation of Expression Lists
}
<description> 
<minimal example>

{2
Evaluation of Slices 
}
[eval_slices env slices] is the list of pair [(i_n, l_n)] that corresponds to
the start (included) and the length of each slice in [slices]. 
<minimal example>

{2 
Evaluation of Patterns 
}
[eval_pattern env pos v p] determines if [v] matches the pattern [p]. 
The evaluation of the pattern [p] under an environment [env]
is [v] and one of the following applies:

  {3 Rule.PAll}
  <description> 
  <minimal example>

  {3 Rule.PAny}
  <description> 
  <minimal example>

  {3 Rule.PGeq}
  <description> 
  <minimal example>

  {3 Rule.PLeq}
  <description> 
  <minimal example>

  {3 Rule.PNot}
  <description> 
  <minimal example>

  {3 Rule.PRange}
  <description> 
  <minimal example>

  {3 Rule.PSingle}
  <description> 
  <minimal example>

  {3 Rule.PMask}
  <description> 
  <minimal example>

  {3 Rule.PTuple}
  <description> 
  <minimal example>

{2
Evaluation of Local Declarations
}
[eval_local_decl s ldi env m] declares local identifiers [ldi] in [env].
The evaluation of the local identifiers [ldi] under an environment [env]
is [v] and one of the following applies:

  {3 Rule.LDIgnore}
  <description> 
  <minimal example>

  {3 Rule.LDVar}
  <description> 
  <minimal example>

  {3 Rule.LDTypedVar}
  <description> 
  <minimal example>

  {3 Rule.LDUninitialisedVar}
  <description> 
  <minimal example>

  {3 Rule.LDTuple}
  <description> 
  <minimal example>

  {3 Rule.LDTypedTuple}
  <description> 
  <minimal example>

  {3 Rule.LDUninitialisedTuple}
  <description> 
  <minimal example>

{2
Evaluation of Statements 
}
[eval_stmt env s] evaluates [s] in [env]. This is either an interruption
[Returning vs] or a continuation [env], see [eval_res].

  {3 Rule.SPass}
  <description>
  <minimal example>

  {3 Rule.SAssignCall}
  <description>
  <minimal example>

  {3 Rule.SAssignTuple}
  <description>
  <minimal example>

  {3 Rule.SAssign}
  <description>
  <minimal example>

  {3 Rule.SReturnOne}
  <description>
  <minimal example>

  {3 Rule.SReturnSome}
  <description>
  <minimal example>

  {3 Rule.SReturnNone}
  <description>
  <minimal example>

  {3 Rule.SThen}
  <description>
  <minimal example>

  {3 Rule.SCall}
  <description>
  <minimal example>

  {3 Rule.SCond}
  <description>
  <minimal example>

  {3 Rule.SCase}
  <description>
  <minimal example>

  {3 Rule.SAssert}
  <description>
  <minimal example>

  {3 Rule.SWhile}
  <description>
  <minimal example>

  {3 Rule.SRepeat}
  <description>
  <minimal example>

  {3 Rule.SFor}
  <description>
  <minimal example>

  {3 Rule.SThrowNone}
  <description>
  <minimal example>

  {3 Rule.SThrowSomeTyped}
  <description>
  <minimal example>

  {3 Rule.SThrowSome}
  <description>
  <minimal example>

  {3 Rule.STry}
  <description>
  <minimal example>

  {3 Rule.SDeclSome}
  <description>
  <minimal example>

  {3 Rule.SDeclNone}
  <description>
  <minimal example>

  {3 Rule.SDebug}
  <description>
  <minimal example>

{2
Evaluation of Blocks
}
<description> 
<minimal example>

{2
Evaluation of [while] and [repeat] loops 
}
<description> 
<minimal example>

{2
Evaluation of [for] loops 
}
<description> 
<minimal example>

{2
Evaluation of Catchers 
}
<description> 
<minimal example>

{2
Evaluation of Function Calls 
}
[eval_call pos name env args named_args] evaluate the call to function [name]
with arguments [args] and parameters [named_args].
<minimal example>

{2
Evaluation of Functions 
}
[eval_func genv name pos args nargs] evaluate the function named [name] in the
global environment [genv], with [args] the formal arguments, and [nargs] the
arguments deduced by type equality. 
<minimal example>

{1 
Typing
}
