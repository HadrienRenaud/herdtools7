\documentclass{book}
\input{ASLmacros}
\input{ASLTypingLines}
\input{ASLTypeSatisfactionLines}
\input{ASLASTLines}
\newcommand{\tests}{../tests/ASLTypingReference.t/}

\newcommand\todocomment[1]{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The following macros will be moved to ASLmacros.tex when we unify all reference documents.
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\ThrowingConfig[0]{\texttt{\#T}}
\newcommand\ErrorConfig[0]{\texttt{\#E}}
\newcommand\OrAbnormal[0]{\terminateas \ThrowingConfig, \ErrorConfig}
\newcommand\vg[0]{\texttt{g}}
\newcommand\env[0]{\texttt{env}}
\newcommand\parallelcomp[0]{\parallel}
\newcommand\binoprel[0]{\texttt{binop}}

\newcommand\dynamicdomain[0]{\textsf{dyn-dom}}
\newcommand\literals[0]{\mathcal{L}}

\newcommand\isbuiltinsingular[0]{\texttt{is\_builtin\_singular}}
\newcommand\isbuiltinaggregate[0]{\texttt{is\_builtin\_aggregate}}
\newcommand\isbuiltin[0]{\texttt{is\_builtin}}
\newcommand\isnamed[0]{\texttt{is\_named}}
\newcommand\isanonymous[0]{\texttt{is\_anonymous}}
\newcommand\issingular[0]{\texttt{is\_singular}}
\newcommand\isaggregate[0]{\texttt{is\_aggregate}}
\newcommand\isnonprimitive[0]{\texttt{is\_non\_primitive}}
\newcommand\isprimitive[0]{\texttt{is\_primitive}}

\newcommand\underconstrainedinteger[0]{\textsf{underconstrained\_integer}}
\newcommand\isunconstrainedinteger[0]{\textsf{unconstrained\_integer}}
\newcommand\isunderconstrainedinteger[0]{\textsf{under\_constrained\_integer}}
\newcommand\iswellconstrainedinteger[0]{\textsf{well\_constrained\_integer}}
\newcommand\unconstrainedinteger[0]{\textsf{unconstrained\_integer}}

\newcommand\staticeval[0]{\texttt{static\_eval}}
\newcommand\isstaticallyevaluable[0]{\texttt{check\_statically\_evaluable}}

\newcommand\sortbyid[0]{\texttt{sort-by-id}}

\newcommand\makeanonymous[0]{\texttt{make\_anonymous}}
\newcommand\structsubtypesat[0]{\texttt{structural\_subtype\_satisfies}}
\newcommand\domsubtypesat[0]{\texttt{domain\_subtype\_satisfies}}
\newcommand\subtypesat[0]{\texttt{subtype\_satisfies}}
\newcommand\typeclashes[0]{\;\texttt{type\_clashes}\;}
\newcommand\lca[0]{\texttt{lowest\_common\_ancestor}}
\newcommand\lcasat[0]{\models}
\newcommand\Supers{\textsf{Supers}}
\newcommand\bitfieldsincluded[0]{\texttt{bitfields\_included}}
\newcommand\instantiate[0]{\textsf{instantiate}}
\newcommand\canbeinitializedwith[0]{\texttt{can\_be\_initialized\_with}}
\newcommand\getbitvectorwidth[0]{\texttt{get\_bitvector\_width}}

\newcommand\typeequal[0]{\texttt{type\_equal}}
\newcommand\exprequal[0]{\texttt{expr\_equal}}
\newcommand\bitwidthequal[0]{\texttt{bitwidth\_equal}}
\newcommand\bitfieldequal[0]{\texttt{bitfield\_equal}}
\newcommand\bitfieldsequal[0]{\texttt{bitfields\_equal}}

\newcommand\toir[0]{\texttt{to\_ir}}
\newcommand\toircase[0]{\texttt{to\_ir\_case}}
\newcommand\exprir[0]{\textsf{expr\_ir}}
\newcommand\Prod[0]{\textsf{Prod}}
\newcommand\Sum[0]{\textsf{Sum}}
\newcommand\monomials[0]{\textsf{Monomials}}
\newcommand\polynomials[0]{\textsf{Polynomials}}
\newcommand\addpolynomials[0]{\texttt{add\_polynomials}}
\newcommand\mulpolynomials[0]{\texttt{mul\_polynomials}}
\newcommand\mulmonomials[0]{\texttt{mul\_mononimials}}

\newcommand\eliteral[1]{\textsf{E\_Literal}(#1)}
\newcommand\name[0]{\texttt{name}}
\newcommand\newname[0]{\texttt{new\_name}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Type functions
\newcommand\CheckUnop[0]{\texttt{check\_unop}}
\newcommand\CheckBinop[0]{\texttt{check\_binop}}
\newcommand\constraintbinop[0]{\texttt{constraint\_binop}}
\newcommand\sliceswidth[0]{\texttt{slices\_width}}
\newcommand\annotateexpr[1]{\textsf{annotate\_expr}(#1)}
\newcommand\annotatelexpr[1]{\textsf{annotate\_lexpr}(#1)}
\newcommand\annotatearrayindex[0]{\textsf{annotate\_array\_index}}
\newcommand\annotateslices[0]{\textsf{annotate\_slices}}
\newcommand\annotatelocaldeclitem[1]{\texttt{annotate\_local\_decl\_item}(#1)}
\newcommand\annotatestmt[1]{\texttt{annotate\_stmt}(#1)}
\newcommand\annotateblock[1]{\texttt{annotate\_block}(#1)}
\newcommand\inlinesetter[1]{\texttt{setter\_should\_reduce\_to\_call\_s}(#1)}
\newcommand\annotatecall[1]{\texttt{annotate\_call}(#1)}
\newcommand\annotatecatcher[1]{\texttt{annotate\_catcher}(#1)}
\newcommand\reduceconstants[1]{\texttt{reduce\_constants}(#1)}
\newcommand\declarelocalconstant[1]{\texttt{declare\_local\_constant}(#1)}
\newcommand\annotatelocaldeclitemuninit[1]{\texttt{annotate\_local\_decl\_item\_uninit}(#1)}
\newcommand\checkvarnotinenv[1]{\texttt{check\_var\_not\_in\_env}(#1)}
\newcommand\annotatesubprogram[1]{\texttt{annotate\_subprogram}(#1)}
\newcommand\declaredecl[1]{\texttt{annotate\_decl}(#1)}
\newcommand\annotatespec[1]{\texttt{annotate\_spec}(#1)}
\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalconstraint[1]{\texttt{eval\_constraint}(#1)}
\newcommand\annotateliteral[1]{\texttt{annotate\_literal}(#1)}
\newcommand\exprequalcase[0]{\texttt{expr\_equal\_case}}
\newcommand\exprequalnorm[0]{\texttt{expr\_equal\_norm}}
\newcommand\slicesequal[0]{\texttt{slices\_equal}}
\newcommand\sliceequal[0]{\texttt{slice\_equal}}
\newcommand\constraintsequal[0]{\texttt{constraints\_equal}}
\newcommand\constraintequal[0]{\texttt{constraint\_equal}}
\newcommand\literalequal[0]{\texttt{literal\_equal}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Typeset variable names
\newcommand\newtenv[0]{\texttt{new\_tenv}}
\newcommand\tenvone[0]{\texttt{tenv1}}
\newcommand\tenvtwo[0]{\texttt{tenv2}}
\newcommand\va[0]{\texttt{a}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\vcone[0]{\texttt{c1}}
\newcommand\vctwo[0]{\texttt{c2}}
\newcommand\vi[0]{\texttt{i}}
\newcommand\vione[0]{\texttt{i1}}
\newcommand\vitwo[0]{\texttt{i2}}
\newcommand\vf[0]{\texttt{f}}
\newcommand\vfone[0]{\texttt{f1}}
\newcommand\vftwo[0]{\texttt{f2}}
\newcommand\vl[0]{\texttt{l}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\vy[0]{\texttt{y}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vo[0]{\texttt{o}}
\newcommand\vv[0]{\texttt{v}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vte[0]{\texttt{t\_e}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vleone[0]{\texttt{le1}}
\newcommand\vletwo[0]{\texttt{le2}}
\newcommand\vtleone[0]{\texttt{t\_le1}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vtsone[0]{\texttt{ts1}}
\newcommand\vtstwo[0]{\texttt{ts2}}
\newcommand\vlt[0]{\texttt{l\_t}}
\newcommand\vls[0]{\texttt{l\_s}}
\newcommand\vtt[0]{\texttt{t\_t}}
\newcommand\vts[0]{\texttt{t\_s}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vz[0]{\texttt{z}}
\newcommand\vw[0]{\texttt{w}}
\newcommand\vwone[0]{\texttt{w1}}
\newcommand\vwtwo[0]{\texttt{w2}}
\newcommand\vwidth[0]{\texttt{width}}
\newcommand\size[0]{\texttt{size}}
\newcommand\vfield[0]{\texttt{field}}
\newcommand\vfieldone[0]{\texttt{field1}}
\newcommand\vfieldtwo[0]{\texttt{field2}}
\newcommand\vfieldsone[0]{\texttt{fields1}}
\newcommand\vfieldstwo[0]{\texttt{fields2}}
\newcommand\bitfields[0]{\texttt{bitfields}}
\newcommand\bfone[0]{\texttt{bf1}}
\newcommand\bftwo[0]{\texttt{bf2}}
\newcommand\bfoneone[0]{\texttt{bf1\_1}}
\newcommand\bftwoone[0]{\texttt{bf2\_1}}
\newcommand\vslices[0]{\texttt{slices}}
\newcommand\newle[0]{\texttt{new\_le}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldk[0]{\texttt{ldk}}
\newcommand\tty[0]{\texttt{ty}}
\newcommand\tsy[0]{\texttt{sy}}
\newcommand\tyopt[0]{\texttt{ty\_opt}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\newldi[0]{\texttt{new\_ldi}}
\newcommand\news[0]{\texttt{new\_s}}
\newcommand\newsone[0]{\texttt{new\_s1}}
\newcommand\newstwo[0]{\texttt{new\_s2}}
\newcommand\newargs[0]{\texttt{new\_args}}
\newcommand\eqs[0]{\texttt{eqs}}
\newcommand\neweqs[0]{\texttt{new\_eqs}}
\newcommand\reduced[0]{\texttt{reduced}}
\newcommand\tcond[0]{\texttt{t\_cond}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\vcond[0]{\texttt{v\_cond}}
\newcommand\etrue[0]{\texttt{e\_true}}
\newcommand\efalse[0]{\texttt{e\_false}}
\newcommand\ttrue[0]{\texttt{t\_true}}
\newcommand\tfalse[0]{\texttt{t\_false}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\wantedtindex[0]{\texttt{wanted\_t\_index}}
\newcommand\tindex[0]{\texttt{t\_index}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\fieldsone[0]{\texttt{fields1}}
\newcommand\fieldstwo[0]{\texttt{fields2}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\newe[0]{\texttt{new\_e}}
\newcommand\ta[0]{\texttt{ta}}
\newcommand\les[0]{\texttt{les}}
\newcommand\subtys[0]{\texttt{sub\_tys}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwise[0]{\texttt{otherwise}}
\newcommand\csone[0]{\texttt{cs1}}
\newcommand\cstwo[0]{\texttt{cs2}}
\newcommand\irone[0]{\texttt{ir1}}
\newcommand\irtwo[0]{\texttt{ir2}}
\newcommand\vpone[0]{\texttt{p1}}
\newcommand\vptwo[0]{\texttt{p2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\opone[0]{\texttt{op1}}
\newcommand\optwo[0]{\texttt{op2}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\veoneone[0]{\texttt{e1\_1}}
\newcommand\veonetwo[0]{\texttt{e1\_2}}
\newcommand\veonethree[0]{\texttt{e1\_3}}
\newcommand\vetwoone[0]{\texttt{e2\_1}}
\newcommand\vetwotwo[0]{\texttt{e2\_2}}
\newcommand\vetwothree[0]{\texttt{e2\_3}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vbthree[0]{\texttt{b3}}
\newcommand\nameone[0]{\texttt{name1}}
\newcommand\nametwo[0]{\texttt{name2}}
\newcommand\vargsone[0]{\texttt{args1}}
\newcommand\vargstwo[0]{\texttt{args2}}
\newcommand\vargone[0]{\texttt{arg1}}
\newcommand\vargtwo[0]{\texttt{arg2}}
\newcommand\vlone[0]{\texttt{l1}}
\newcommand\vltwo[0]{\texttt{l2}}
\newcommand\sliceone[0]{\texttt{slice1}}
\newcommand\slicetwo[0]{\texttt{slice2}}
\newcommand\slicesone[0]{\texttt{slices1}}
\newcommand\slicestwo[0]{\texttt{slices2}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\posmax[0]{\texttt{pos\_max}}
\newcommand\bv[0]{\texttt{bv}}
\newcommand\bvone[0]{\texttt{bv1}}

% Increase indentation of sections in the table of contents
% to allow a space between the section numbers and their titles.
\makeatletter
\renewcommand{\l@section}{\@dottedtocline{1}{1.5em}{2.6em}}
\makeatother
\setcounter{tocdepth}{1}

\author{Arm Architecture Technology Group}
\title{ASL Typing Reference \\
       DDI 0622}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The purpose of this document is to describe, in a formal and authoritative way, which ASL programs are considered \emph{valid}.
Validity is defined in terms of a \emph{type system}~\cite{TypeSystemsLucaCardelli}. That is, a set of \emph{typing rules}.

\section{Abstract Syntax}
An \emph{abstract syntax tree} (AST, for short) represents an ASL specification as a labelled structured tree.
%
The ASL type system is defined over the ASL abstract syntax, which is given in~\cite{ASLAbstractSyntaxReference}.

\section{Environments}

A \emph{static environment} (also called a \emph{type environment}) is what the typing rules operate over:
a structure, which amongst other things, associates types to variables.
Throughout this document, we will use the term environment for static environment, unless otherwise stated.
Intuitively, the typing of a
specification makes an initial environment evolve, with new types as given by the
variable declarations of the specification.
%
Technically, an environment $\tenv=(G^\tenv, L^\tenv)$ consists of two
distinct components: the global environment $G^\tenv$---pertaining to AST nodes
appearing outside of a given subprogram, and the local environment
$L^\tenv$---pertaining to AST nodes appearing inside a given subprogram.

\hypertarget{def-staticenvs}{
Environments $\tenv \in \staticenvs$ are formally defined below (referring to symbols defined in the abstract syntax):
}
\[
\begin{array}{rcl}
\staticenvs 	          &=& \mathbb{G} \times \mathbb{L}\\
\mathbb{G} 	            &=& \declaredtypes \times \constantvalues \times \storagetypes\\
  			                & & \times\ \subtypes \times \subprograms \times \subprogramrenamings\\
\mathbb{L} 	            &=& \constantvalues \times \storagetypes \times \returntype\\
\hline
\hypertarget{def-declaredtypes}{\declaredtypes}	        &=& \identifier \partialto \ty\\
\hypertarget{def-constantvalues}{\constantvalues}         &=& \identifier \partialto \literal\\
\hypertarget{def-storagetypes}{\storagetypes}           &=& \identifier \partialto \ty \times \localdeclkeyword\\
\hypertarget{def-subtypes}{\subtypes}		            &=& \identifier \partialto \identifier\\
\hypertarget{def-subprograms}{\subprograms}	          &=& \identifier \partialto \func\\
\hypertarget{def-subprogramrenamings}{\subprogramrenamings}	  &=& \identifier \rightarrow 2^\func\\
\hypertarget{def0returntype}{\returntype}             &=& \langle \ty \rangle
\end{array}
\]

\hypertarget{def-emptytenv}{}
\begin{definition}[Empty Static Environment]
  The \emph{empty static environment}, denoted as $\emptytenv$ is defined as
  \[
    \emptytenv \triangleq \left(
      \begin{array}{l}
      (\overname{\emptyfunc}{\declaredtypes},
      \overname{\emptyfunc}{\constantvalues},
      \overname{\emptyfunc}{\storagetypes},
      \overname{\emptyfunc}{\subtypes},
      \overname{\emptyfunc}{\subprograms},
      \overname{\emptyfunc}{\subprogramrenamings}),\\
      (
        \overname{\emptyfunc}{\constantvalues},
        \overname{\emptyfunc}{\storagetypes},
        \overname{\None}{\returntype}
      )
      \enspace.
    \end{array}
    \right)
  \]
\end{definition}

The global environment and local environment consist of various components.
We use the notation $G^\tenv.m$ and $L^\tenv.m$ to access the $m$ component of a given environment.

To update a function component $f$ (e.g., $\declaredtypes$) of an environment $\tenv$ (either local or global)
with a new mapping $x \mapsto v$, we use the notation $\tenv.f[x \mapsto v]$ to stand for $\tenv[f \mapsto E.f[x \mapsto v]]$.

\section{Type System}
A \emph{type rule} has the form $\inferrule{P_1 \\ .. \\ P_k}{S}$.
We refer to $P_1,\ldots,P_k$ as the \emph{premises} of the rule and to the verdict $S$ as its \emph{conclusion}.
When the set of premises is empty, we may omit them entirely.

When all the premises of a rule hold (with all free variables occurring in the rule implicitly interpreted as universally quantified),
we can conclude that the verdict $S$ holds.
%
The premises typically inspect the label of an AST node and the information associated with the children of the node in a given environment.

This is related to \identd{JRXM}, \identi{ZTMQ}, \identd{HBCP}, \identi{SMMH},
\identi{DFML}, \identr{WMFV}.

\subsection*{Rule Example}
The following rule is used to type a sequence of two statements:
\[
\inferrule{
  \annotatestmt{\tenv, \vs1} = (\newsone, \tenvone)\\
  \annotatestmt{\tenvone, \vs2} = (\newstwo, \tenvtwo)\\
}
{
  \annotatestmt{\tenv, \SSeq(\vsone, \vstwo)} = (\SSeq(\newsone, \newstwo), \tenvtwo)
}
\]
The rule uses the annotation function $\annotatestmt{\cdot}$, which
accepts an environment $\tenv$ and two statements and returns a new statement and a new environment.
The function returns a new statement in order to implement certain code transformations, such as
inlining setter functions. The rule holds for all environments $\tenv, \tenvone, \tenvtwo$ and all
statements $\vs1, \vs2, \newsone, \newstwo$ for which the premises hold.

\section{Annotation}

Typing a specification consists of annotating the root of its AST. This is typically
done by traversing the AST bottom-up.  To annotate a node, the typing algorithm
finds a rule that matches the node---that is a rule whose conditions are
satisfied. If one such rule is found, the node is annotated by the result type
specified by the rule.  If no such rule is found, it is considered a \emph{typing error}
and the algorithm exits.

Sometimes it is to necessary to define \emph{error rules}---rules that result
in an error and provide extra information to help understand the reason for the
error.

We implement the process described above via a set of
\texttt{annotate\_<label>} functions. Each \texttt{annotate\_<label>}
function describes how to annotate an AST node, given its label, as follows:\begin{itemize}
\item \texttt{annotate\_expr} annotates expressions;
\item \texttt{annotate\_slices} annotates slices;
\item \texttt{annotate\_pattern} annotates pattern;
\item \texttt{annotate\_local\_decl\_item} annotates local declarations;
\item \texttt{annotate\_lexpr} annotates left-hand sides of assignments;
\item \texttt{annotate\_stmt} annotates statements;
\item \texttt{annotate\_block} annotates blocks;
\item \texttt{annotate\_catcher} annotates catchers;
\item \texttt{annotate\_call} annotates functions calls;
\item \texttt{annotate\_func} annotates functions.
\end{itemize}

This is related to \identr{VDPC}.

\include{ASLFormal}

\newcommand\Elit[1]{\texttt{E}(#1)}
We use the shorthand $\Elit{n}$ for the expression denoting the literal integer value $n$. That is, $\texttt{E\_Literal}(\texttt{L\_Int}(n))$.

We use the shorthand notation $\underconstrainedinteger$ to denote the underconstraint integer type: $\TInt(\texttt{UnConstrained})$
and $\unconstrainedinteger$ to denote the unconstrained integer type: $\TInt(\langle\rangle)$.

Note that throughout this document we use $\tty$ do denote a type variable, which should not be confused with the abstract syntax variable $\ty$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Reading guide}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The definition of each \texttt{annotation\_<label>} function is given by a number of
rules, which follow the possible shapes the \texttt{label} can have. For
example, an expression can be a literal, or a binary operator, amongst other
things. Each of those has its own evaluation rule: TypingRule.ELit in
Section~\ref{sec:TypingRule.ELit} and
Typing.Binop in Section~\ref{sec:TypingRule.Binop}, respectively.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds as much as possible to the code of the reference implementation ASLRef given at
\href{https://github.com/herd/herdtools7//tree/master/asllib}{/herdtools7/asllib};
\item one or several Example paragraphs, which as much as possible are also given as regression tests in
\href{https://github.com/herd/herdtools7//tree/master/asllib/tests/ASLTypingReference.t}{/herdtools7/asllib/tests/ASLTypingReference.t};
\item a Code paragraph which gives a verbatim of the corresponding implementation in the type-checker of ASLRef
\href{https://github.com/herd/herdtools7//tree/master/asllib/Typing.ml}{/herdtools7/asllib/Typing.ml};
\item Formal paragraphs which give formal definitions of the rule.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Basic Type Attributes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TypingRule.BuiltinSingularType \label{sec:TypingRule.BuiltinSingularType}}

    \subsection{Prose}
    The \emph{builtin singular types} are:
    \begin{itemize}
    \item integer;
    \item real;
    \item string;
    \item boolean;
    \item bits;
    \item enumeration.
    \end{itemize}

    \subsection{Example: TypingRule.BuiltinSingularTypes.asl}

In this example:
\VerbatimInput[firstline=3,lastline=8]{\tests/TypingRule.BuiltinSingularTypes.asl}

Variables of builtin singular types \texttt{integer}, \texttt{real},
\texttt{boolean}, \texttt{bits(4)}, \\ and~\texttt{bits(2)} are defined.

    \subsection{Example: TypingRule.EnumerationType.asl}
\VerbatimInput{\tests/TypingRule.EnumerationType.asl}
The builtin singular type \texttt{color} consists in two constants
\texttt{RED}, and~\texttt{BLACK}.


      \CodeSubsection{\BuiltinSingularBegin}{\BuiltinSingularEnd}{../types.ml}

\begin{formal}
   \subsection{Formally}
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TReal, \TString, \TBool, \TBits, \TEnum, \TInt\}
}{
  \isbuiltinsingular(\tty)
}
\end{mathpar}

\end{formal}

    \subsection{Comments}
    This is related to \identd{PQCK} and \identd{NZWT}.

\section{TypingRule.BuiltinAggregateType \label{sec:TypingRule.BuiltinAggregateType}}

    \subsection{Prose}
    The builtin aggregate types are:
    \begin{itemize}
    \item tuple;
    \item array;
    \item record;
    \item exception.
    \end{itemize}

    \subsection{Example: TypingRule.BuiltinAggregateTypes.asl}
      \VerbatimInput{\tests/TypingRule.BuiltinAggregateTypes.asl}
      Type \texttt{pair} is the type of integer and booleans pairs. Notice that
      the syntax of types and expressions are similar.

Arrays are indexed either by integers from 0 to (array size minus $1$) as
specified in type declaration, as illustrated by the type \texttt{T}, or by the
elements of an enumeration type, as illustrated by type~\texttt{pointCoord}.

The (builtin aggregate) type~\texttt{pointRecord} is defined as a record type with three fields
\texttt{x}, \texttt{y} and~\texttt{z}.

    \subsection{Example: TypingRule.BuiltinExceptionType.asl}
    \VerbatimInput{\tests/TypingRule.BuiltinExceptionType.asl}
    Two (builtin aggregate) exception types are defined: exceptions \texttt{Not\_found} carry no
values, while exceptions \texttt{Error}  carry a message. Notice the
similarity with record types and that the empty field list \texttt{\{\}} can be
omitted in type declarations, as it is the case for \texttt{Not\_found}.


      \CodeSubsection{\BuiltinAggregateBegin}{\BuiltinAggregateEnd}{../types.ml}

\begin{formal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{\astlabel(\tty) \in \{\TTuple, \TArray, \TRecord, \TException\}}
{\isbuiltinaggregate(\tty)}
\end{mathpar}
\end{formal}

    \subsection{Comments}
    This is related to \identd{PQCK} and \identd{KNBD}.

\section{TypingRule.BuiltinSingularOrAggregate \label{sec:TypingRule.BuiltinSingularOrAggregate}}

    \subsection{Prose}
    $\tty$ is a builtin type and one of the following applies:
    \begin{itemize}
    \item $\tty$ is singular;
    \item $\tty$ is builtin aggregate.
    \end{itemize}

    \subsection{Example}
In ``\texttt{type ticks of integer;}'', the type \texttt{integer} is a builtin type but the named type \texttt{ticks} is not.


      \CodeSubsection{\BuiltinSingularOrAggregateBegin}{\BuiltinSingularOrAggregateEnd}{../types.ml}

\begin{formal}
      \subsection{Formally}
\begin{mathpar}
  \inferrule{\isbuiltinsingular(\tty)}{\isbuiltin(\tty)}
  \and
  \inferrule{\isbuiltinaggregate(\tty)}{\isbuiltin(\tty)}
\end{mathpar}

\end{formal}

\isempty{\subsection{Comments}}

\section{TypingRule.NamedType \label{sec:TypingRule.NamedType} }

    \subsection{Prose}
    A named type is a type that is declared by using the \texttt{type of} syntax.

    \subsection{Example}
    The type \texttt{ticks} in ``\texttt{type ticks of integer;}'' is a named type.


      \CodeSubsection{\NamedBegin}{\NamedEnd}{../types.ml}

\begin{formal}
      \subsection{Formally}
\begin{mathpar}
\inferrule{\astlabel(\tty) = \TNamed}{\isnamed(\tty)}
\end{mathpar}
\end{formal}

    \subsection{Comments}
    This is related to \identd{vmzx}.

\section{TypingRule.AnonymousType \label{sec:TypingRule.AnonymousType}}

    \subsection{Prose}
    An anonymous type is a type which is not declared using the type syntax.

    \subsection{Example}
    The tuple type \texttt{(integer, integer)} is an anonymous type.


      \CodeSubsection{\AnonymousBegin}{\AnonymousEnd}{../types.ml}

\begin{formal}
      \subsection{Formally}
      \begin{mathpar}
\inferrule{\astlabel(\tty) \neq \TNamed}{\isanonymous(\tty)}
      \end{mathpar}
\end{formal}

    \subsection{Comments}
    This is related to \identd{VMZX}.

\section{TypingRule.SingularType}

The partial function $\tstruct : \ty \partialto \ty$, which assigns a \emph{structure} to a type, is defined in Section~\ref{sec:structure}.

    \subsection{Prose}
    A type $\tty$ is singular if one of the following applies:
    \begin{itemize}
    \item $\tty$ is a builtin singular type;
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is a named type;
      \item the structure of $\tty$ is a builtin singular type.
      \end{itemize}
    \end{itemize}

    \subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all singular types:
\begin{verbatim}
type A of integer;
type B of A;
type C of B;
\end{verbatim}


      \CodeSubsection{\SingularBegin}{\SingularEnd}{../types.ml}

\begin{formal}
      \subsection{Formally}
\begin{mathpar}
\inferrule{\isbuiltin(\tty)}{\issingular(\tenv, \tty)}\\
\and
\inferrule{\isnamed(\tty) \\ \isbuiltinsingular(\tstruct(\tenv, \vt))}{
\issingular(\tenv, \tty)}
\end{mathpar}

\end{formal}

    \subsection{Comments}
    This is related to \identr{GVZK}.

\section{TypingRule.AggregateType}

    \subsection{Prose}
    A type $\tty$ is aggregate in an environment $\tenv$ if one of the following applies:
    \begin{itemize}
    \item $\tty$ is a builtin aggregate type;
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is a named type;
      \item the structure of $\tty$ is a builtin aggregate.
      \item the structure of $\tty$ is a builtin aggregate.
      \end{itemize}
    \end{itemize}

    \subsection{Example}
In the following example, the types \texttt{A}, \texttt{B}, and \texttt{C} are all aggregate types:
\begin{verbatim}
type A of (integer, integer);
type B of A;
type C of B;
\end{verbatim}


      \CodeSubsection{\AggregateBegin}{\AggregateEnd}{../types.ml}

\begin{formal}
      \subsection{Formally}


\begin{mathpar}
\inferrule{\isbuiltinaggregate(\tty)}{\isaggregate(\tenv, \tty)}\\
\and
\inferrule{\isnamed(\tty) \\ \isbuiltinaggregate(\tstruct(\tenv, \tty))}{\isaggregate(\tenv, \tty)}
\end{mathpar}
\end{formal}

    \subsection{Comments}
    This is related to \identr{GVZK}.

\newcommand\vtp[0]{\texttt{t}'}

\section{TypingRule.NonPrimitiveType}

    \subsection{Prose}
    \subsection{Prose}
    A type $\tty$ is non-primitive if one of the following applies:
    \begin{itemize}
    \item $\tty$ is a named type;
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is a tuple type \texttt{li};
      \item there exists a non-primitive type in \texttt{li};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is an array of type $\tty'$
      \item $\tty'$ is non-primitive;
      \item $\tty'$ is non-primitive;
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is a record with fields \texttt{fields};
      \item there exists a non-primitive type in \texttt{fields};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item $\tty$ is an exception with fields \texttt{fields};
      \item there exists a non-primitive type in \texttt{fields};
      \end{itemize}
    \end{itemize}

    \subsection{Example}


The following types are non-primitive:

\begin{tabular}{ll}
  \textbf{Type definition} & \textbf{Reason for being non-primitive}\\
  \hline
\texttt{type A of integer} & Named types are non-primitive\\
\texttt{(integer, A)} & The second component, \texttt{A}, has non-primitive type\\
\texttt{array[6] of A}  & Element type \texttt{A} has a non-primitive type\\
\texttt{record \{ a : A \}} & The field \texttt{a} has a non-primitive type
\end{tabular}


      \CodeSubsection{\NonPrimitiveBegin}{\NonPrimitiveEnd}{../types.ml}

\begin{formal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{\astlabel(\tty) = \TNamed}{\isnonprimitive(\tty)}
\and
\inferrule{\vt \in \texttt{li} \\ \isnonprimitive(\vt)}{\isnonprimitive(\TTuple(\texttt{li}))}
\and
\inferrule{\isnonprimitive(\tty')}{\isnonprimitive(\TArray(\Ignore, \tty'))}
\and
\inferrule{(\Ignore,\vt) \in \texttt{fields} \\ \isnonprimitive(\vt) \\ L \in \{\TRecord, \TException\}}{\isnonprimitive(L(\texttt{fields}))}
\end{mathpar}

\end{formal}

    \subsection{Comments}
    This is related to \identd{GWXK}.

\section{TypingRule.PrimitiveType}

    \subsection{Prose}
    A type \texttt{ty} is primitive if it is not non-primitive.

    \subsection{Example}
The following types are primitive:

\begin{tabular}{ll}
  \textbf{Type definition} & \textbf{Reason for being non-primitive}\\
  \hline
\texttt{integer} & Integers are primitive\\
\texttt{(integer, integer)} & All component types are primitive\\
\texttt{array[5] of integer} & The array element type is primitive\\
\texttt{record \{ticks : integer\}} & The single field \texttt{ticks} has a primitive type
\end{tabular}


      \CodeSubsection{\PrimitiveBegin}{\PrimitiveEnd}{../types.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{\neg\isnonprimitive(\tty)}{\isprimitive(\tty)}
\end{mathpar}
\end{formal}

    \subsection{Comments}
    This is related to \identd{GWXK}.

\section{TypingRule.Structure \label{sec:structure}}

    \subsection{Prose}
    \texttt{ty} is a type and its \hypertarget{def-tstruct}{\emph{structure}} is $\tstruct(\ty)$ and one of the following
    applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a named type \texttt{x};
      \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{x} is not declared in the global environment;
          \item an error ``\texttt{Undefined Identifier}'' is raised;
          \end{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{x} is declared in the global environment as some type \texttt{ty'};
          \item \texttt{t\_struct} is the structure of \texttt{ty'};
          \end{itemize}
       \end{itemize}
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a builtin singular type;
      \item \texttt{t\_struct} is \texttt{ty};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a tuple type with \texttt{tys};
      \item \texttt{t\_struct} is a tuple type with the structure of each element in \texttt{tys};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{ty} is an array type of length \texttt{e} with element type
          \texttt{t};
        \item \texttt{t\_struct} is an array type with of length \texttt{e}
          with element type the structure of \texttt{t};
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is a record with \texttt{fields};
      \item \texttt{t\_struct} is a record with its fields sorted by their names and associated with the structure of their corresponding types;
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{ty} is an exception with \texttt{fields};
      \item \texttt{t\_struct} is a record with with its fields sorted by their names and associated with the structure of their corresponding types;
      \end{itemize}
    \end{itemize}

    \subsection{Example}
    In this example:
    \texttt{type T1 of integer;} is the named type \texttt{T1}
whose structure is \texttt{integer}.

    In this example:
    \texttt{type T2 of (integer, T1);}
    is the named type \texttt{T2} whose structure is (integer, integer). In this
    example, \texttt{(integer, T1)} is non-primitive since it uses \texttt{T1}, which is builtin aggregate.

    In this example:
    \texttt{var x: T1;}
    the type of \texttt{x} is the named (hence non-primitive) type \texttt{T1}, whose structure
    is \texttt{integer}.

    In this example:
    \texttt{var y: integer;}
    the type of \texttt{y} is the anonymous primitive type \texttt{integer}.

    In this example:
    \texttt{var z: (integer, T1);}
    the type of \texttt{z} is the anonymous non-primitive type
\texttt{(integer, T1)} whose structure is \texttt{(integer, integer)}.


      \CodeSubsection{\StructureBegin}{\StructureEnd}{../types.ml}

\begin{emptyformal}
      \subsection{Formally}
Let $\sortbyid([i=1..k: (\id_i,\tty_i)]) = [i=1..k: (\id_i',\tty_i')]$ be the input list sorted according to the identifier component (lexicographically).

\begin{mathpar}
\inferrule{G^\tenv.\declaredtypes(\vx) = \tty' \\ \tstruct(\tenv, \tty)=\tty'}{\tstruct(\tenv, \TNamed(\vx)) = \tty'}
\and
\inferrule{\isbuiltinsingular(\tty)}{\tstruct(\tenv, \tty) = \tty}
\and
\inferrule{}{\tstruct(\tenv, \TTuple(\texttt{subtypes})) =  \TTuple([\tstruct(\tenv, \vt) \;|\; \vt \in \texttt{subtypes}])}
\and
\inferrule{}{\tstruct(\tenv, \TArray(\ve, \vt)) = \TArray(\ve, \tstruct(\tenv, \vt))}
\and
\inferrule{L \in \{\TRecord, \TException\}}{\tstruct(\tenv, L(\fields)) = \\
 L(\sortbyid([\tstruct(\tenv, \vt) \;|\; (\id,\vt) \in \fields]))}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    The structure of a type is the equivalent primitive type that can hold the same values.

    The structure of a type is the equivalent primitive type that can hold the same values.

    This is related to \identd{FXQV}.

\section{TypingRule.Anonymize \label{sec:anonymize}}
\subsection{Prose}
\texttt{ty} is a type and the anonymous type that underlies it is \texttt{ta} and one of the following
applies:
\begin{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{ty} is a named type \texttt{x};
        \item One of the following applies:
        \item All of the following apply:
        \begin{itemize}
        \item \texttt{ty'} is the type declared for \texttt{x};
        \item \texttt{ty'} is the type declared for \texttt{x};
        \item \texttt{ta} is the underlying type of \texttt{ty'};
        \end{itemize}
        \item All of the following apply:
        \begin{itemize}
        \item \texttt{x} is not declared in the global environment;
        \item \texttt{x} is not declared in the global environment;
        \item an error ``\texttt{Undefined Identifier}'' is raised;
        \end{itemize}
        \item All of the following apply:
        \begin{itemize}
        \item \texttt{ty} is not a named type;
        \item \texttt{ta} is \texttt{ty};
      \end{itemize}
    \end{itemize}
\end{itemize}


\subsection{Example}
Consider the following example:
\begin{verbatim}
type T1 of integer;
type T2 of T1;
type T3 of (integer, T2);
\end{verbatim}

The underlying types of \texttt{integer}, \texttt{T1}, and \texttt{T2} is \texttt{integer}.

The underlying type of \texttt{(integer, T2)} and \texttt{T3} is
\texttt{(integer, T2)}.  Notice how the underlying type does not replace
\texttt{T2} with its own underlying type, in contrast to the structure of
\texttt{T2}, which is \texttt{(integer, integer)}.


  \CodeSubsection{\AnonymizeBegin}{\AnonymizeEnd}{../types.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  \tty = \TNamed(\vx) \\
  G^\tenv.\declaredtypes(\vx) = \tty' \\
  \makeanonymous(\tenv, \tty') = \ta}
{\makeanonymous(\tenv, \tty) = \ta}
\and
\inferrule{\astlabel(\tty) \neq \TNamed}
{\makeanonymous(\tenv, \tty) = \tty}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This is a helper function, which we use to inspect the type that is akin to the
structure of the input type, but without losing the names of named types that
may appear internally.

\section{TypingRule.Domain}

  \subsection{Prose}
  The \emph{dynamic domain} of a type is the set of values which storage elements of that type may hold
  The \emph{dynamic domain} of a type is the set of values which storage elements of that type may hold
  \underline{in a given runtime environment}.
  %
  The \emph{static domain} of a type is the set of values which storage elements of that type may hold
  \underline{across all possible runtime environments}.
  %
  The reason that for this distinction is that the sets of values
  considered for bitvector types, array types, constrained integers, and constrained bitvectors,
  can be parameterized by configuration variables and subprogram parameters whose values are only determined during runtime.
  considered for bitvector types, array types, constrained integers, and constrained bitvectors,
  can be parameterized by configuration variables and subprogram parameters whose values are only determined during runtime.

  When the dynamic domain of a type equals the static domain of a type, we will simply refer to both
  types of domains as the \emph{domain} of that type.

  \paragraph{Subsumption Testing.}
  One of the conditions for determining whether an assignment is type-correct is whether the dynamic domain of the
  right hand side type is contained in the dynamic domain of the left hand side type~\ref{sec:TypingRule.DomainSubtypeSatisfaction},
  for any given runtime environment.
  %
  This requires symbolic reasoning over the constraints associated with the types.
  We approximate this symbolic reasoning by employing a conservative symbolic reasoning procedure,
  which we refer to as a \emph{subsumption test}.
  If the subsumption test returns a positive answer, it means that the containment between the runtime domains holds across all
  runtime environment.
  Otherwise, the subsumption test returns a ``don't know'' answer, which is interpreted by the type checker pessimistically,
  effectively assuming that there might be a counterexample.

  \subsection{Example}
  The domain of \texttt{integer} is the infinite set of all integers.

  The domain of \texttt{bits(1)} is the set \texttt{{‘1’, ‘0’}}.

  The domain of \texttt{integer {2,16}} is the set containing the integers \texttt{2} and \texttt{16}.

  THe domain of \texttt{enumeration \{GREEN, ORANGE, RED\}} is the set containing the values
  \texttt{GREEN}, \texttt{ORANGE}, and \texttt{RED} and so is the runtime domain
  \texttt{GREEN}, \texttt{ORANGE}, and \texttt{RED} and so is the runtime domain
  of \texttt{type TrafficLights of enumeration \{GREEN, ORANGE, RED\}}.

  The static domain of \texttt{bits({2,16})} is the set containing all 2-bit and all 16-bit binary sequences.

  The domain of \texttt{(integer, integer)} is the set containing all pairs of integers.

  The domain of \texttt{record \{a: integer;  b: boolean\}} contains all functions that map \texttt{a} to an integer and \texttt{b} to a Boolean value.

  The dynamic domain of a subprogram parameter \texttt{N: integer} is the (singleton) set containing the value $c$,
  which is assigned to \texttt{N} by a given runtime environment. The static domain of that parameter
  is the infinite set of all integers.


      \CodeSubsection{\DomainBegin}{\DomainEnd}{../types.ml}

\begin{emptyformal}
      \subsection{Formally}
      \newcommand\subsumes[0]{\texttt{subsumes}}
      \newcommand\reasoner[0]{\texttt{reasoner}}

      We denote a runtime environment that assigns values to global storage elements (more specifically, config variables)
      and subprogram parameters by $\denv \in \dynamicenvs$.
      We denote by $\tenv \in \staticenvs$ a static environment, which assigns identifiers to types.
      We denote the runtime domain of a type $\vt$ in the environments $\tenv$ and $\denv$ by $\dynamicdomain(\tenv, \denv, \vt)$.

      For two types $\vt$ and $\vs$, a symbolic reasoning engine \reasoner\ and a static environment \tenv,
      we write $\subsumes(\reasoner, \tenv, \vt, \vs)$ to mean that the symbolic reasoning
      engine \reasoner\ has returned a positive answer. That is, the following holds:
      \[
        \begin{array}{l}
        \subsumes(\reasoner, \tenv, \vt, \vs) \Rightarrow \\
       \forall \denv\in\dynamicenvs.\ \dynamicdomain(\tenv, \denv, \vt) \supseteq \dynamicdomain(\tenv, \denv, \vs) \enspace.
        \end{array}
      \]
      In this case, we say that \vt\ \emph{subsumes} \vs.

      In this document, we leave the symbolic reasoning engine unspecified. We will define it in detail in a future version.

We denote by $\denv[N]$ the integer value given to the underconstrained parameter $N$ in the environment $\denv$.

\begin{mathpar}
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TBool) = \{\texttt{FALSE}, \texttt{TRUE}\} }
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TString) = \{ s\ \;|\; \texttt{"}s\texttt{"} \in \texttt{<string\_lit>} \} }
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TReal) = \Q }
\and
\inferrule[Domain of Unconstrained integer]{}{\dynamicdomain(\tenv, \denv, \unconstrainedinteger) = \Z }
\and
\inferrule[Domain of a Well-constrained integer]{}{ \denv(\tenv, \TInt(\langle [c_{1..k}] \rangle)) = \bigcup_{i=1}^k \evalconstraint{\tenv, \denv, c_i}}
\and
\inferrule[Domain of Underconstrained integer]{}{\dynamicdomain(\tenv, \denv, \TInt(\langle \emptylist_N \rangle)) = \{ \llbracket\denv\rrbracket N \} }
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TEnum([\id_{1..k}])) = \{\id_{1..k}\}}
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TBits(c, \textit{bfl})) = \\ \{ b_{1..k} \;|\; b_1,\ldots,b_k \in \{0,1\}, \;\;\; k \in \evalconstraint{\tenv, E, c} \} }
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TTuple([\tty_{1..k}])) = \bigtimes_{i=1}^k \dynamicdomain(\tenv, \denv,\tty_i) }
\and
\inferrule{}{ \dynamicdomain(\tenv, \denv, \TArray(\ve, \tty)) = \\ \{ v_{1..k}\;|\; k = \evalexpr{E, \ve}, \; v_{1..k} \in \dynamicdomain(\tenv, \denv, \tty)  \} }
\and
\inferrule{L \in \{\TRecord, \TException\}}{ \dynamicdomain(\tenv, \denv, L(\{f_1:\tty_1,\ldots,f_k:\tty_k\})) = \\ \lambda f\in\identifier.\ \dynamicdomain(\tenv, \denv, [f_1\mapsto\tty_1,\ldots,f_k\mapsto\tty_k](f))}
\and
\inferrule{G^\tenv.\declaredtypes(\id)=\tty}{\dynamicdomain(\tenv, \denv, \TNamed(\id)) = \dynamicdomain(\tenv, \denv, \tty)}
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identd{BMGM}, \identr{PHRL}, \identr{PZNR},
  \identr{RLQP}, \identr{LYDS}, \identr{SVDJ}, \identi{WLPJ}, \identr{FWMM},
  \identi{WPWL}, \identi{CDVY}, \identi{KFCR}, \identi{BBQR}, \identr{ZWGH},
  \identr{DKGQ}, \identr{DHZT}, \identi{HSWR}, \identd{YZBQ}.

\section{Constrained Types}

\subsection{Prose}
  \begin{itemize}
  \item A constrained type is a type whose definition depends on an expression, e.g. certain integers and bitvectors.
  \item A type which is not constrained is unconstrained.
  \item A constrained type with a non-empty constraint is well-constrained.
  \item An under-constrained integer type is an implicit type of a subprogram parameter.
  \end{itemize}

  \subsection{Example}
    Bitvector storage element’s widths are constrained integers.


    \CodeSubsection{\ConstrainedBegin}{\ConstrainedEnd}{../AST.mli}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{}{\isunconstrainedinteger(\tenv, \unconstrainedinteger)}
\and
\inferrule{}{\isunderconstrainedinteger(\tenv, \TInt(\langle \emptylist \rangle))}
\and
\inferrule{i=1..k: \isstaticallyevaluable(\tenv, c_i)}{\iswellconstrainedinteger(\tenv, \TInt(\langle [c_{1..k}]\rangle))}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identd{ZTPP}, \identr{WJYH}, \identr{HJPN}, \identr{CZTX}, \identr{TPHR}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Relations Over Types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We first define the following relations over types (and operators):
\begin{itemize}
  \item Subtype~\ref{sec:TypingRule.Subtype}
  \item Structural Subtype Satisfaction~\ref{sec:TypingRule.Subtype}
  \item Domain Subtype Satisfaction~\ref{sec:TypingRule.DomainSubtypeSatisfaction}
  \item Subtype Satisfaction~\ref{sec:TypingRule.SubtypeSatisfaction}
  \item Type Satisfaction~\ref{sec:TypingRule.TypeSatisfaction}
  \item Type Clash~\ref{sec:TypingRule.TypeClash}
  \item Lowest Common Ancestor~\ref{sec:TypingRule.LowestCommonAncestor}
  \item Checking adequacy of a unary operator for a type~\ref{sec:TypingRule.CheckUnop}
  \item Checking adequacy of a binary operator for a pair of types~\ref{sec:TypingRule.CheckBinop}
\end{itemize}

\section{TypingRule.Subtype\label{sec:TypingRule.Subtype}}

  \subsection{Prose}
The \emph{subtype} relation is a partial order over \underline{named types}.
The \emph{supertype} is the symmetric relation. That is, \tty\ is a  of \tsy\ if and only if \tsy\ is a subtype of \tty.

  \subsection{Example}
In the following example \texttt{subInt} is a subtype of itself and of \texttt{superInt}:
\begin{verbatim}
type superInt of integer;
type subInt of integer subtypes superInt;
\end{verbatim}



    \CodeSubsection{\SubtypeBegin}{\SubtypeEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

To model subtyping, the global environment contains the partial function \\
$\subtypes$, which maps a type name to the name of its supertype, if it has
one.

We define the subtyping relation between two named types in a given environment as follows:
\begin{mathpar}
\inferrule{\id \in \identifier}{\subtypes(\tenv, \TNamed(\id), \TNamed(\id))}
\and
\inferrule{G^\tenv.\subtypes(\vtone, \vttwo)}
{\subtypes(\tenv, \TNamed(\vtone), \TNamed(\vttwo))}
\and
\inferrule{\subtypes(\tenv, \tty_1, \tty_2) \\ \subtypes(\tenv, \tty_2, \tty_3)}{\subtypes(\tenv, \tty_1, \tty_3)}
\and
\inferrule{\tty \neq \tty' \\ \subtypes(\tenv, \tty, \tty') \\ \subtypes(\tenv, \tty', \tty)}{\TypeError(\texttt{"subtyping cycle exists!"})}
\end{mathpar}

  \subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive, viz,
  every type is also a subtype of itself.

  Since the subtype relation is a partial order, it is transitive, viz, if A is
  a subtype of B and B is a subtype of C then A is a subtype of C.

  As a consequence, there is no need to declare the reflexive and transitive
  subtype relations explicitly. All other subtype relations must be explicitly
  declared.

  Since the subtype relation is a partial order, it is antisymmetric. Therefore
  it is an error if all of the following apply:
  \begin{itemize}
  \item \texttt{id1} is a subtype of \texttt{id2};
  \item \texttt{id2} is a subtype of \texttt{id1}.
  \end{itemize}

  This is related to \identr{NXRX}, \identi{KGKS}, \identi{MTML}, \identi{JVRM}, \identi{CHMP}.

\section{TypingRule.Supertype}

  \subsection{Prose}
  \texttt{t} is a supertype of \texttt{s} if and only if \texttt{s} is a subtype of \texttt{t}.


\todocomment{
ROMAN: This rule doesn't exist in the code. Also, it is redundant, since it just applies to the same arguments in reverse order. I recommend removing this section.
}

  \subsection{Example}



\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive. Therefore the
  supertype relation also is reflexive, viz, every type is also a supertype of
  itself.

  This is related to \identi{KGKS}.

\section{TypingRule.StructuralSubtypeSatisfaction\label{sec:TypingRule.SubtypeSatisfaction}}

\subsection{Prose}
\texttt{t} structurally-subtype-satisfies \texttt{s} in environment \tenv, if one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of an integer type;
    \item \texttt{t} has the underlying type of an integer type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of an integer type;
    \item \texttt{t} has the underlying type of an integer type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a string type;
    \item \texttt{t} has the underlying type of a string type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a boolean type;
    \item \texttt{t} has the underlying type of a boolean type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of an enumeration type;
    \item \texttt{t} has the underlying type of an enumeration type;
    \item \texttt{s} and \texttt{t} have the same enumeration literals.
   \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a bitvector type with determined width \texttt{w};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t} has the underlying type of a bitvector type of determined width \texttt{w};
      \item \texttt{t} has the underlying type of a bitvector type of undetermined width.
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a bitvector type with undetermined width;
    \item \texttt{t} has the underlying type of a bitvector type.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a bitvector type with bitfields \texttt{bitfields} and width \texttt{width};
    \item \texttt{t} has the underlying type of a bitvector type with width \texttt{width};
    \item for every bitfield \texttt{f} in \texttt{bitfields} there is a bitfield \texttt{f'} in \texttt{t} and
      all of the following apply:
      \begin{itemize}
      \item \texttt{f'} has the same name, width and offset as \texttt{f};
      \item \texttt{f'} type-satisfies \texttt{f}.
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of an array type with elements of type \texttt{E};
    \item \texttt{t} has the underlying type of an array type with elements of type \texttt{E};
    \item \texttt{t} has the same element indices as \texttt{s}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a tuple type;
    \item \texttt{t} has the underlying type of a tuple type;
    \item \texttt{t} has the same number of elements as \texttt{s};
    \item for each element \texttt{e} in \texttt{s} there is an element \texttt{e'} in \texttt{t} and \texttt{e'}
      type-satisfies \texttt{e}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of a record type;
    \item \texttt{t} has the underlying type of a record type;
    \item for each field \texttt{f} in \texttt{s} there is an element \texttt{f'} in \texttt{t} and \texttt{f'} has
      the same type as \texttt{f}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} has the underlying type of an exception type;
    \item \texttt{t} has the underlying type of an exception type;
    \item for each field \texttt{f} in \texttt{s} there is an element \texttt{f'} in \texttt{t} and \texttt{f'} has
      the same type as \texttt{f}.
    \end{itemize}
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\StructuralSubtypeSatisfactionBegin}{\StructuralSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}


We write $\structsubtypesat(\tenv, \vs, \vt)$ to denote that type $\vs$ \\ structurally-subtype-satisfies type $\vt$ in the environment $\tenv$.


\begin{mathpar}
\inferrule{\makeanonymous(\tenv, \vs)=\TInt(\Ignore) \\ \makeanonymous(\tenv, \vt)=\TInt(\Ignore) }{\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule[(The case of \TInt, \TReal, \TString, \TBool, and \TEnum)]
{\makeanonymous(\tenv, \vs)=\vs' \\ \makeanonymous(\tenv, \vt)=\vs'}{\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule{\astlabel(\makeanonymous(\tenv, \vs))=\TBits \\ \astlabel(\makeanonymous(\tenv, \vt))=\TBits}{\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule{\makeanonymous(\tenv, \vs)=\TBits(c_s, \vls) \\ \makeanonymous(\tenv, \vt)=\TBits(c_t, \vlt)\\
\bitwidthequal(\tenv, c_s, c_t) \\ \bitfieldsincluded(\tenv, \vls, \vlt)}{\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule{
  \makeanonymous(\tenv, \vs)=\TArray(\vls,e_s) \\
  \makeanonymous(\tenv, \vs)=\TArray(\vlt,e_t) \\
  \exprequal(\tenv, \vls, \vlt) \\
  \makeanonymous(\tenv, \vs)=\TArray(\vls,e_s) \\
  \makeanonymous(\tenv, \vs)=\TArray(\vlt,e_t) \\
  \exprequal(\tenv, \vls, \vlt) \\
  \typeequal(\tenv, e_s, e_t)}
  {\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule[($\typesatisfies(\tenv, \vs \vt)$ is defined in Section~\ref{sec:TypingRule.TypeSatisfaction})]
{ \makeanonymous(\tenv, \vs)=\TTuple(\vs_{1..k}) \\
  \makeanonymous(\tenv, \vt)=\TTuple(\vt_{1..k}) \\
  \makeanonymous(\tenv, \vt)=\TTuple(\vt_{1..k}) \\
  \typesatisfies(\tenv, \vs_1, \vt_1) \ldots \typesatisfies(\tenv, \vs_k, \vt_k)}
  {\structsubtypesat(\tenv, \vs, \vt)}
\and
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \makeanonymous(\tenv, \vs)=L((i_1,\vs_1),\ldots,(i_k,\vs_k)) \\
  \makeanonymous(\tenv, \vt)=L((j_1,\vt_1),\ldots,(j_n,\vt_n)) \\
  f : 1..k \rightarrow_{\textsf{one-to-one}} 1..n \\
  i_1 = j_{f(1)},\ldots,i_k = j_{f(k)} \\
  \makeanonymous(\tenv, \vs)=L((i_1,\vs_1),\ldots,(i_k,\vs_k)) \\
  \makeanonymous(\tenv, \vt)=L((j_1,\vt_1),\ldots,(j_n,\vt_n)) \\
  f : 1..k \rightarrow_{\textsf{one-to-one}} 1..n \\
  i_1 = j_{f(1)},\ldots,i_k = j_{f(k)} \\
  \typeequal(\tenv, \vs_1, \vt_{f(1)}),\ldots,\typeequal(\tenv, \vs_k, \vt_{f(k)})
}
{\structsubtypesat(\tenv, \vs, \vt)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{TRVR}, \identi{SJDC}, \identi{MHYB}, \identi{TWTZ}, \identi{GYSK}, \identi{KXSD}.

\section{TypingRule.DomainSubtypeSatisfaction\label{sec:TypingRule.DomainSubtypeSatisfaction}}

\subsection{Prose}
 \texttt{t} domain-subtype-satisfies \texttt{s} in environment \tenv\ if one of the following applies:
 \begin{itemize}
 \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} does not have the structure of an aggregate type or bitvector type;
    \item the domain of \texttt{t} is subsumed by the domain of \texttt{s}.
    \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{s} has the structure of a bitvector type with undetermined width;
      \item \texttt{t} has the structure of a bitvector type with undetermined width;
      \end{itemize}
   \item the domain of \texttt{t} is subsumed by the domain of \texttt{s}.
   \end{itemize}
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\DomainSubtypeSatisfactionBegin}{\DomainSubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
We denote that \texttt{t} domain-subtype-satisfies \texttt{s} in environment
\tenv\ by \\ $\domsubtypesat(\tenv, \vt, \vs)$.

\begin{mathpar}
\inferrule{\tstruct(\tenv, \vs)=\vs' \\ \astlabel(\vs') \in \{\TTuple, \TArray, \TRecord, \TException\} }{\domsubtypesat(\tenv, \vt, \vs)}
\and
\inferrule{\tstruct(\tenv, \vt)=\vt' \\
\tstruct(\tenv, \vs)=\vs'  \\
  \astlabel(\vs') \in \{\TReal, \TString, \TBool, \TEnum, \TInt\} \\
  \subsumes(\reasoner, \tenv, \vs', \vt')\\
  }{\domsubtypesat(\tenv, \vt, \vs)}
\and
\inferrule{\astlabel(\vt) = \astlabel(\vs) = \TBits \\
\texttt{undetermined\_width}(\tenv, \vs)\\
\subsumes(\reasoner, \tenv, \vs, \vt)
\subsumes(\reasoner, \tenv, \vs, \vt)
}
{\domsubtypesat(\tenv, \vt, \vs)}
\and
\inferrule{\astlabel(\vt) = \astlabel(\vt) = \TBits \\
\texttt{undetermined\_width}(\tenv, \vt)\\
\subsumes(\reasoner, \tenv, \vs, \vt)
\texttt{undetermined\_width}(\tenv, \vt)\\
\subsumes(\reasoner, \tenv, \vs, \vt)
}
{\domsubtypesat(\tenv, \vt, \vs)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identd{TRVR}.

\section{TypingRule.SubtypeSatisfaction\label{sec:subtypesatisfaction}}

  \subsection{Prose}
    \texttt{t} subtype-satisfies \texttt{s} if all of the following apply:
    \begin{itemize}
    \item \texttt{t} structural-subtype-satisfies \texttt{s};
    \item \texttt{t} domain-subtype-satisfies \texttt{s}.
    \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SubtypeSatisfactionBegin}{\SubtypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
We denote that type $\vt$ subtype-satisfies type $\vs$ in an environment $\tenv$ by $\subtypesat(\tenv, \vt, \vs)$.
\begin{mathpar}
\inferrule{\structsubtypesat(\tenv, \vt, \vs)\\ \domsubtypesat(\tenv, \vt, \vs)}{\subtypesat(\tenv, \vt, \vs)}
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
    This is related to \identd{TRVR}, \identi{KNXJ}.

\section{TypingRule.TypeSatisfaction \label{sec:TypingRule.TypeSatisfaction}}

\subsection{Prose}

\texttt{t} \hypertarget{def-typesatisfies}{type-satisfies} \texttt{s} if one of the following applies:


 \begin{itemize}
 \item \texttt{t} is a subtype of \texttt{s};
 \item All of the following apply:
    \begin{itemize}
    \item \texttt{t} subtype-satisfies \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{s} is an anonymous type;
      \item \texttt{t} is an anonymous type;
      \end{itemize}
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{t} is an anonymous bitvector with no bitfields;
    \item \texttt{s} has the structure of a bitvector (with or without bitfields);
    \item \texttt{s} has the same width as \texttt{t}.
    \end{itemize}
  \end{itemize}

\subsection{Example: TypingRule.TypeSatisfaction1.asl}
    In the specification:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction1.asl}
    \texttt{var pair: pairT = (1, dataT1)} is legal since the right-hand-side has
    anonymous, non-primitive type \texttt{(integer, T1)}.

\subsection{Example: TypingRule.TypeSatisfaction2.asl}
    In the specification:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction2.asl}
    \texttt{pair = (1, dataAsInt);} is legal since the right-hand-side has anonymous,
    primitive type \texttt{(integer, integer)}.

\subsection{Example: TypingRule.TypeSatisfaction3.asl}
    In the specification:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TypeSatisfaction3.asl}
    \texttt{pair = (1, dataT2);} is illegal since the right-hand-side has anonymous,
    non-primitive type \texttt{(integer, T2)} which does not subtype-satisfy named
    type \texttt{pairT}.


    \CodeSubsection{\TypeSatisfactionBegin}{\TypeSatisfactionEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
We denote that type $\vt$ type-satisfies type $\vs$ in an environment $\tenv$ by \\ $\typesatisfies(\tenv, \vt, \vs)$.
\begin{mathpar}
\inferrule{\subtypes(\tenv, \vt, \vs)}{\typesatisfies(\tenv, \vt, \vs)}
\and
\inferrule{\isanonymous(\tenv, \vt) \\ \subtypesat(\tenv, \vt, \vs)}{\typesatisfies(\tenv, \vt, \vs)}
\and
\inferrule{\isanonymous(\tenv, \vs) \\ \subtypesat(\tenv, \vt, \vs)}{\typesatisfies(\tenv, \vt, \vs)}
\and
\inferrule{w_t,w_s \in \bitsconstraint \\
  \tstruct(\tenv, \vt)=\TBits(w_t, \emptylist) \\
  \tstruct(\tenv, \vs)=\TBits(w_s, \Ignore) \\
  \bitwidthequal(\tenv, w_s, w_t)}
{\typesatisfies(\tenv, \vt, \vs)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  Since the subtype relation is a partial order, it is reflexive. Therefore
  every type \texttt{t} is a subtype of itself, and as a consequence, every type \texttt{t}
  type-satisfies itself.

  type-satisfies itself.

  This is related to \identr{FMXK} and \identi{NLFD}.


\section{TypingRule.TypeClash\label{sec:TypingRule.TypeClash}}

  \subsection{Prose}
  \texttt{t} type-clashes with \texttt{s} if one of the following applies:
  \begin{itemize}
  \item \texttt{s} and \texttt{t} both have the structure of integers;
  \item \texttt{s} and \texttt{t} both have the structure of reals;
  \item \texttt{s} and \texttt{t} both have the structure of strings;
  \item \texttt{s} and \texttt{t} both have the structure of enumeration types with the same enumeration literals;
  \item \texttt{s} and \texttt{t} both have the structure of bitvectors;
  \item \texttt{s} and \texttt{t} both have the structure of booleans;
  \item \texttt{s} and \texttt{t} both have the structure of arrays whose element types type-clash;
  \item \texttt{s} and \texttt{t} both have the structure of tuples of the same length whose
    corresponding element types type-clash;
  \item \texttt{s} is a subtype of \texttt{t};
  \item \texttt{s} is a supertype of \texttt{t}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\TypeClashBegin}{\TypeClashEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) = \vt' \\
  \tstruct(\tenv, \vt) = \vt' \\
  \tstruct(\tenv, \vs) = \vs' \\
  \astlabel(\vt')=\astlabel(\vs') \in \{\TInt, \TReal, \TString, \TBits, \TEnum\}
}{\typeclashes(\tenv, \vt, \vs)}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TArray(\Ignore, \vt') \\
  \tstruct(\tenv, \vt) = \TArray(\Ignore, \vt') \\
  \tstruct(\tenv, \vs) = \TArray(\Ignore, \vs') \\
  \typeclashes(\tenv, \vt', \vs')
}{\typeclashes(\tenv, \vt, \vs)}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k: \typeclashes(\tenv, \vt_i, \vs_i)
}{\typeclashes(\tenv, \vt, \vs)}
\and
\inferrule{\subtypes(\tenv, \vs, \vt)}{\typeclashes(\tenv, \vt, \vs)}
\and
\inferrule{\subtypes(\tenv, \vt, \vs)}{\typeclashes(\tenv, \vt, \vs)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  Note that if \texttt{t} subtype-satisfies \texttt{s} then \texttt{t} and \texttt{s} type-clash, but not the other
  way around.

  Note that type-clashing is an equivalence relation. Therefore if \texttt{t}
  type-clashes with \texttt{A} and \texttt{B} then it is also the case that \texttt{A} and \texttt{B} type-clash.

  This is related to \identd{VPZZ}, \identi{PQCT} and \identi{WZKM}.

\section{TypingRule.LowestCommonAncestor \label{sec:TypingRule.LowestCommonAncestor}}

\subsection{Prose}
  Annotating a given conditional expression (see Section~\ref{sec:TypingRule.ECond}),
  requires finding a single type such that can be used to annotate the results of both sub-expressions.
  This leads to the notion of a \emph{lowest common ancestor} of two types.

  The lowest common ancestor of types \texttt{s} and \texttt{t} is \texttt{ty} and one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} and \texttt{t} are the same type;
    \item \texttt{ty} is \texttt{s}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} and \texttt{t} are both named types;
    \item \texttt{ty} is a common supertype of \texttt{s} and \texttt{t};
    \item \texttt{ty} is a subtype of all other common supertypes of \texttt{s} and \texttt{t}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} and \texttt{t} both have the structure of array types with the same index type
      and the same element types;

    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is a named type;
        \item \texttt{t} is an anonymous type;
        \item \texttt{ty} is \texttt{s}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is a named type;
        \item \texttt{ty} is \texttt{t}.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} and \texttt{t} both have the structure of tuple types with the same number of elements;
    \item The types of the elements of \texttt{s} type-satisfy the types of the elements of \texttt{t};
    \item The types of the elements of \texttt{t} type-satisfy the types of the elements of \texttt{s};
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is a named type;
        \item \texttt{t} is an anonymous type;
        \item \texttt{ty} is \texttt{s}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is a named type;
        \item \texttt{ty} is \texttt{t}.
        \end{itemize}

     \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is an anonymous type;
	\item \texttt{ty} is the tuple type where the type of each element is the lowest common
	  ancestor of the types of the corresponding elements of \texttt{s} and \texttt{t}.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{s} and \texttt{t} both have the structure of well-constrained integer types;
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is a named type;
        \item \texttt{t} is an anonymous type;
        \item \texttt{ty} is \texttt{s}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is a named type;
        \item \texttt{ty} is \texttt{t}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is an anonymous type;
	\item \texttt{ty} is the well-constrained integer type whose runtime domain is the union of the
	  runtime domains of \texttt{s} and \texttt{t}, for every runtime environment.
        \end{itemize}
      \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either \texttt{s} or \texttt{t} have the structure of an unconstrained integer type;
    \item One of the following applies:

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is a named type;
        \item \texttt{s} has the structure of an unconstrained integer type;
        \item \texttt{t} is an anonymous type;
        \item \texttt{ty} is \texttt{s}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is a named type;
        \item \texttt{t} has the structure of an unconstrained integer type;
        \item \texttt{ty} is \texttt{t}.
        \end{itemize}

      \item All of the following apply:
        \begin{itemize}
        \item \texttt{s} is an anonymous type;
        \item \texttt{t} is an anonymous type;
	\item \texttt{ty} is the unconstrained integer type.
        \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item Either \texttt{s} or \texttt{t} have the structure of an under-constrained integer type;
    \item \texttt{ty} is the under-constrained integer type.
    \end{itemize}

  \item \texttt{ty} is undefined.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LowestCommonAncestorBegin}{\LowestCommonAncestorEnd}{../types.ml}

\begin{emptyformal}
    \subsection{Formally}

Since we do not impose a canonical representation on types (e.g., \texttt{Integer {1, 2}} is equivalence to \texttt{integer {1..2}}),
the lowest common ancestor is not unique.
We define $\lca(\tenv, \vt, \vs)$ to be a type that is type-equivalent to the lowest common ancestor of $\vt$ and $\vs$, $\vt'$:
\[
  \typeequal(\tenv, \vt', \lca(\tenv, \vt, \vs)) \enspace.
\]

\begin{mathpar}
\inferrule[Lowest common ancestor reflexivity]{}{\lca(\tenv, \vt, \vt) = \vt}
\and
\inferrule[(The least common subtype, if one exists.)]{
  \astlabel(\vt)=\astlabel(\vs)=\TNamed \\\\
  \Supers(\vs) = \{\vs' \;|\; \subtypes(\tenv, \vs, \vs')\}\\
  \Supers(\vt) = \{\vt' \;|\; \subtypes(\tenv, \vt, \vt')\}\\\\
  \Supers(\vs) \cap \Supers(\vt) \neq \emptyset
}
{\lca(\tenv, \vt, \vs) = \min_{\subtypes} (\Supers(\vs) \cap \Supers(\vt))}
\end{mathpar}

Rules for arrays:
\begin{mathpar}
\inferrule{\tstruct(\tenv, \vt) = \TArray(\vlt, \vtt) \\
  \tstruct(\tenv, \vs) = \TArray(\vls, \vts) \\
  \typeequal(\tenv, \vlt, \vls) \\
  \typeequal(\tenv, \vtt, \vts) \\
  \astlabel(\tstruct(\tenv, \vt)) = \TNamed \\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{\tstruct(\tenv, \vt) = \TArray(\vlt, \vtt) \\
  \tstruct(\tenv, \vs) = \TArray(\vls, \vts) \\
  \typeequal(\tenv, \vlt, \vls) \\
  \typeequal(\tenv, \vtt, \vts) \\
  \astlabel(\tstruct(\tenv, \vs)) = \TNamed \\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\end{mathpar}

Rules for tuples:
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesatisfies(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesatisfies(\tenv, \vt_i, \vs_i) \\
  \astlabel(\vt) = \TNamed \\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesatisfies(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesatisfies(\tenv, \vt_i, \vs_i) \\
  \astlabel(\vs) = \TNamed \\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \tstruct(\tenv, \vt) = \TTuple(\vt_{1..k}) \\
  \tstruct(\tenv, \vs) = \TTuple(\vs_{1..k}) \\
  i=1..k:\typesatisfies(\tenv, \vs_i, \vt_i) \\
  i=1..k:\typesatisfies(\tenv, \vt_i, \vs_i) \\
  \isanonymous(\vt)\\
  \isanonymous(\vs)\\
  i=1..k: \lca(\tenv, \vt_i, \vs_i)=\vz_i
}
{\lca(\tenv, \vt, \vs) = \TTuple(\vz_{1..k})}
\end{mathpar}

Rules for well-constrained integers:
\begin{mathpar}
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vt) = \TNamed\\
  \isanonymous(\vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vs) = \TNamed\\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \iswellconstrainedinteger(\tstruct(\tenv, \vt))  \\
  \iswellconstrainedinteger(\tstruct(\tenv, \vs))  \\
  \astlabel(\vs) = \TNamed\\
  \isanonymous(\vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule[(We use + to denote the list concatenation.)]
{
  \tstruct(\tenv, \vt) = \TInt(\langle \texttt{cs\_t} \rangle) \\
  \tstruct(\tenv, \vs) = \TInt(\langle \texttt{cs\_s} \rangle) \\
  \isanonymous(\vt)\\
  \isanonymous(\vs)}
{\lca(\tenv, \vt, \vs) = \TInt(\langle \texttt{cs\_t} + \texttt{cs\_s} \rangle)}
\end{mathpar}

Rules for unconstrained integers:
\begin{mathpar}
\inferrule{
  \astlabel(\vs) = \TNamed \\
  \tstruct(\tenv, \vs) = \isunconstrainedinteger \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \isanonymous(\tenv, \vt)
}
{\lca(\tenv, \vt, \vs) = \vs}
\and
\inferrule{
  \astlabel(\vt) = \TNamed \\
  \tstruct(\tenv, \vt) = \isunconstrainedinteger \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
  \isanonymous(\tenv, \vs)
}
{\lca(\tenv, \vt, \vs) = \vt}
\and
\inferrule{
  \isanonymous(\tenv, \vs) \\
  \isanonymous(\tenv, \vt) \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vs) = \isunconstrainedinteger \\
}
{\lca(\tenv, \vt, \vs) = \unconstrainedinteger}
\and
\inferrule{
  \isanonymous(\tenv, \vs) \\
  \isanonymous(\tenv, \vt) \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
  \tstruct(\tenv, \vt) = \isunconstrainedinteger \\
}
{\lca(\tenv, \vt, \vs) = \unconstrainedinteger}
\end{mathpar}

Rules for underconstrained integers:
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \vt) = \isunderconstrainedinteger \\
  \tstruct(\tenv, \vs) = \TInt(\Ignore) \\
}
{\lca(\tenv, \vt, \vs) = \isunderconstrainedinteger}
\and
\inferrule{
  \tstruct(\tenv, \vs) = \isunderconstrainedinteger \\
  \tstruct(\tenv, \vt) = \TInt(\Ignore) \\
}
{\lca(\tenv, \vt, \vs) = \isunderconstrainedinteger}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{YZHM}.

\section{TypingRule.CheckUnop \label{sec:TypingRule.CheckUnop}}

\subsection{Goal}
  Determining the result type of applying a unary operator when the type of its operand is known.
  Similarly, we determine the negation of integer constraints.

\subsection{Prose}
  \texttt{t} is the result of checking compatibility of a unary operator \texttt{op} with
  type \texttt{t1} and one of the following applies:
  \begin{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{op} is \texttt{BNOT};
      \item \texttt{t1} type-satisfies \texttt{boolean};
      \item \texttt{t} is \texttt{boolean};
    \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{op} is \texttt{NEG};
    \item \texttt{t1} type-satisfies \texttt{real};
    \item \texttt{t} is \texttt{real};
  \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{NEG};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t1} type-satisfies \texttt{integer};
      \item \texttt{t1} type-satisfies \texttt{real};
      \end{itemize}
     \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of an unconstrained integer;
         \item \texttt{t} is an unconstrained integer;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of a constrained integer;
         \item \texttt{t} is a constrained integer whose constraint is ;
         \end{itemize}
       \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{NEG};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t1} type-satisfies \texttt{integer};
      \item \texttt{t1} type-satisfies \texttt{real};
      \end{itemize}
     \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of an unconstrained integer;
         \item \texttt{t} is an unconstrained integer;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
         \item \texttt{t1} has the structure of a constrained integer;
         \item \texttt{t} is a constrained integer whose constraint is ;
         \end{itemize}
       \end{itemize}
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{NOT};
    \item \texttt{t1} has the structure of a bitvector;
    \item \texttt{t} is \texttt{t1}.
    \end{itemize}
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\CheckUnopBegin}{\CheckUnopEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}


\begin{mathpar}
\inferrule{\typesatisfies(\tenv, \vt, \TBool)}{\CheckUnop(\tenv, \texttt{"!"}, \vt) = \TBool}
\and
\inferrule{\typesatisfies(\tenv, \vt, \TReal)}{\CheckUnop(\tenv, \texttt{"-"}, \vt) = \TReal}
\and
\inferrule{\typesatisfies(\tenv, \vt, \unconstrainedinteger)}{\CheckUnop(\tenv, \texttt{"-"}, \vt) = \unconstrainedinteger}
\end{mathpar}

We define the following helper relations for negating integer constraints:
\begin{mathpar}
\inferrule{}{\CheckUnop(\tenv, \texttt{"-"}, \texttt{Constraint\_Exact}(\ve)) = \texttt{Constraint\_Exact}(\texttt{E\_Unop}(\texttt{"-"}, \ve))}
\and
\inferrule{}{\CheckUnop(\tenv, \texttt{"-"}, \texttt{Constraint\_Range}(\ve1,\ve2)) = \\
 \texttt{Constraint\_Range}(\texttt{E\_Unop}(\texttt{"-"}, \ve2),\texttt{E\_Unop}(\texttt{"-"}, \ve1))}
\end{mathpar}

We now apply these relations to handle well-constrained integers:
\begin{mathpar}
  \inferrule{\typesatisfies(\tenv, \vt, \TInt(\langle [c_{1..k}] \rangle)) \\
i=1..k: \CheckUnop(\texttt{"-"}, c_i) : d_i}{\CheckUnop(\tenv, \texttt{"-"}, \vt) : \TInt(\langle [d_{1..k}] \rangle)}
\end{mathpar}

\begin{mathpar}
  \inferrule{\astlabel(\tstruct(\tenv, \vt)) = \TBits}{\CheckUnop(\tenv, \texttt{"NOT"}, \vt) = \vt}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CheckBinop \label{sec:TypingRule.CheckBinop}}

\subsection{Goal}
  Determine the result type of a binary operator, give the types of its operands.


\subsection{Prose}
  \texttt{t} is the result of checking compatibility of a binary operator \texttt{op} with
  types \texttt{t1} and \texttt{t2} and one of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{AND}, \texttt{OR}, \texttt{EQ} or \texttt{IMPL};
    \item \texttt{t1} type-satisfies \texttt{boolean};
    \item \texttt{t2} type-satisfies \texttt{boolean};
    \item \texttt{t} is \texttt{boolean}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{AND}, \texttt{OR}, or \texttt{EOR};
    \item \texttt{t1} has the structure of a bitvector;
    \item \texttt{t2} has the structure of a bitvector;
    \item \texttt{t1} and \texttt{t2} have the same bitvector width \texttt{w};
    \item \texttt{t} is the bitvector type of width \texttt{w}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{PLUS} or \texttt{MINUS};
    \item \texttt{t1} has the structure of a bitvector of width \texttt{w};
    \item One of the following applies:
      \begin{itemize}
	    \item All of the following apply:
          \begin{itemize}
		    \item \texttt{t2} has the structure of a bitvector;
    		\item \texttt{t1} and \texttt{t2} have the same bitvector width \texttt{w};
    		\item \texttt{t} is the bitvector type of width \texttt{w}.
          \end{itemize}
    	\item \texttt{t2} type-satisfies \texttt{integer};
      \end{itemize}
    \item \texttt{t} is the bitvector type of width \texttt{w}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{EQ\_OP} or \texttt{NEQ};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{t1} is equal to \texttt{t2};
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{integer};
        \item \texttt{t2} type-satisfies \texttt{integer};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of a bitvector;
        \item \texttt{t2} has the structure of a bitvector;
        \item \texttt{t1} and \texttt{t2} have the same bitvector width;
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{boolean};
        \item \texttt{t2} type-satisfies \texttt{boolean};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} enumerates local declarations \texttt{li1};
        \item \texttt{t2} enumerates local declarations \texttt{li2};
        \item \texttt{li1} equals \texttt{li2};
        \end{itemize}
      \end{itemize}
    \item \texttt{t} is \texttt{boolean}.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{LEQ}, \texttt{GEQ}, \texttt{GT} or \texttt{LT};
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{integer};
        \item \texttt{t2} type-satisfies \texttt{integer};
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} type-satisfies \texttt{real};
        \item \texttt{t2} type-satisfies \texttt{real};
        \end{itemize}
      \end{itemize}
    \item \texttt{t} is boolean.
    \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{MUL}, \texttt{DIV}, \texttt{DIVRM}, \texttt{MOD}, \texttt{SHL}, \texttt{SHR}, \texttt{POW}, \texttt{PLUS} or \texttt{MINUS};
    \item \texttt{struct1} is the structure of \texttt{t1};
    \item \texttt{struct2} is the structure of \texttt{t2};
    \item One of the following applies:
      \begin{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of an unconstrained integer;
        \item \texttt{t2} has the structure of an integer;
        \item \texttt{t} is an unconstrained integer;
        \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of an integer;
        \item \texttt{t2} has the structure of an unconstrained integer;
        \item \texttt{t} is an unconstrained integer;
        \end{itemize}
      \item One of the following applies:
       \begin{itemize}
      \item One of the following applies:
       \begin{itemize}
       \item All of the following apply:
          \begin{itemize}
          \item \texttt{t1} has the structure of an under-constrained integer;
          \item \texttt{t2} has the structure of a constrained integer;
          \item \texttt{t} is an under-constrained integer;
          \end{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item \texttt{t1} has the structure of a constrained integer;
          \item \texttt{t2} has the structure of an under-constrained integer;
          \item \texttt{t} is an under-constrained integer;
          \end{itemize}
       \end{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{t1} has the structure of a well-constrained integer;
           \item \texttt{t2} has the structure of a well-constrained integer;
	       \item \texttt{t} is a constrained integer whose constraint is calculated by
	       applying the operation to all possible value pairs;
           \end{itemize}
      \item All of the following apply:
        \begin{itemize}
        \item \texttt{t1} has the structure of \texttt{real};
        \item \texttt{t2} has the structure of \texttt{real};
        \item \texttt{op} is \texttt{PLUS}, \texttt{MINUS} or \texttt{MUL};
        \item \texttt{t} is \texttt{real};
        \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t1} has the structure of \texttt{real};
       \item \texttt{t2} has the structure of \texttt{integer};
       \item \texttt{op} is \texttt{POW};
       \item \texttt{t} is \texttt{real};
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \item All of the following apply:
    \begin{itemize}
    \item \texttt{op} is \texttt{RDIV};
    \item \texttt{t1} type-satisfies \texttt{real};
    \item \texttt{t2} type-satisfies \texttt{real};
    \item \texttt{t} is \texttt{real}.
    \end{itemize}
\end{itemize}

  \subsection{Example}


    \CodeSubsection{\CheckBinopBegin}{\CheckBinopEnd}{../Typing.ml}

\begin{formal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \texttt{op} \in  \{\texttt{"\&\&"}, \texttt{"||"}, \texttt{"-->"}, \texttt{"<->"}\}\\
  \typesatisfies(\tenv, \vt1, \TBool) \\
  \typesatisfies(\tenv, \vttwo, \TBool)
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBool}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"AND"}, \texttt{"OR"}, \texttt{"EOR"}, \texttt{"XOR"}\}\\
  \tstruct(\tenv, \vtone) = \TBits(\vw, \Ignore) \\
  \tstruct(\tenv, \vttwo) = \TBits(\vw', \Ignore) \\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBits(w_1, \emptylist)}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"+"}, \texttt{"-"}\}\\
  \tstruct(\tenv, \vtone) = \TBits(\vw, \Ignore) \\
  \tstruct(\tenv, \vttwo) = \TBits(\vw', \Ignore) \\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBits(w_1, \emptylist)}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"+"}, \texttt{"-"}\}\\
  \tstruct(\tenv, \vtone) = \TBits(\vw, \Ignore) \\
  \typesatisfies(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBits(\vw, \emptylist)}
\end{mathpar}

\begin{mathpar}
\inferrule[(This rule also handles the case of enumeration types.)]
{\texttt{op} \in  \{\texttt{"="}, \texttt{"!="}\}}
{\CheckBinop(\tenv, \texttt{op}, \vt, \vt) = \TBool}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"="}, \texttt{"!="}\}\\
  \typesatisfies(\tenv, \vtone, \unconstrainedinteger)\\
  \typesatisfies(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBool}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"="}, \texttt{"!="}\}\\
  \tstruct(\tenv, \vtone)=\TBits(\vw, \Ignore)\\
  \tstruct(\tenv, \vttwo)=\TBits(\vw', \Ignore))\\
  \bitwidthequal(\tenv, \vw, \vw')
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TBool}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \texttt{op} \in  \{\texttt{"<"}, \texttt{"<="}, \texttt{">"}, \texttt{">="}\}\\
  \typesatisfies(\tenv, \vtone, \unconstrainedinteger)\\
  \typesatisfies(\tenv, \vttwo, \unconstrainedinteger)
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \unconstrainedinteger}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"<"}, \texttt{"<="}, \texttt{">"}, \texttt{">="}\}\\
  \typesatisfies(\tenv, \vtone, \TReal)\\
  \typesatisfies(\tenv, \vttwo, \TReal)
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TReal}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \texttt{op} \in  \{\texttt{"*"}, \texttt{"DIV"}, \texttt{"DIVRM"}, \texttt{"MOD"}, \texttt{"<<"},  \texttt{">>"}, \texttt{"\^{}"}, \texttt{"+"}, \texttt{"-"}\}\\
  \tstruct(\tenv, \vtone) = \unconstrainedinteger\\
  \astlabel(\tstruct(\tenv, \vttwo)) = \TInt
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \unconstrainedinteger}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"*"}, \texttt{"DIV"}, \texttt{"DIVRM"}, \texttt{"MOD"}, \texttt{"<<"},  \texttt{">>"}, \texttt{"\^{}"}, \texttt{"+"}, \texttt{"-"}\}\\
  \astlabel(\tstruct(\tenv, \vtone)) = \TInt\\
  \tstruct(\tenv, \vttwo) = \unconstrainedinteger
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \unconstrainedinteger}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"*"}, \texttt{"DIV"}, \texttt{"DIVRM"}, \texttt{"MOD"}, \texttt{"<<"},  \texttt{">>"}, \texttt{"\^{}"}, \texttt{"+"}, \texttt{"-"}\}\\
  \tstruct(\tenv, \vtone) = \TInt(\langle \texttt{cs\_1} \rangle) \\
  \tstruct(\tenv, \vttwo) = \TInt(\langle \texttt{cs\_2} \rangle)\\
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TInt(\constraintbinop(\texttt{cs\_1}, \texttt{cs\_2}))}
\and
\inferrule{
  \texttt{op} \in  \{\texttt{"+"}, \texttt{"-"}, \texttt{"*"}\}\\
  \tstruct(\tenv, \vtone) = \TReal\\
  \tstruct(\tenv, \vttwo) = \TReal
}
{\CheckBinop(\tenv, \texttt{op}, \vtone, \vttwo) = \TReal}
\and
\inferrule{
  \tstruct(\tenv, \vtone) = \TReal\\
  \astlabel(\tstruct(\tenv, \vttwo)) = \TInt
}
{\CheckBinop(\tenv, \texttt{"\^{}"}, \vtone, \vttwo) = \TReal}
\and
\inferrule{
  \typesatisfies(\tenv, \vtone, \TReal)\\
  \typesatisfies(\tenv, \vttwo, \TReal)\\
}
{\CheckBinop(\tenv, \texttt{"RDIV"}, \vtone, \vttwo) = \TReal}
\end{mathpar}

\end{formal}

\subsection{Comments}
  This is related to \identr{BKNT}, \identr{ZYWY}, \identr{BZKW},
  \identr{KFYS}, \identr{KXMR}, \identr{SQXN}, \identr{MRHT}, \identr{JGWF},
  \identr{TTGQ}, \identi{YHML}, \identi{YHRP}, \identi{VMZF}, \identi{YXSY},
  \identi{LGHJ}, \identi{RXLG}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and one of the following applies:
\begin{itemize}
  \item TypingRule.TString (see Section~\ref{sec:TypingRule.TString});
  \item TypingRule.TReal (see Section~\ref{sec:TypingRule.TReal});
  \item TypingRule.TBool (see Section~\ref{sec:TypingRule.TBool});
  \item TypingRule.TNamed (see Section~\ref{sec:TypingRule.TNamed});
  \item TypingRule.TInt (see Section~\ref{sec:TypingRule.TInt});
  \item TypingRule.TBits (see Section~\ref{sec:TypingRule.TBits});
  \item TypingRule.TTuple (see Section~\ref{sec:TypingRule.TTuple});
  \item TypingRule.TArray (see Section~\ref{sec:TypingRule.TArray});
  \item TypingRule.TEnumDecl (see Section~\ref{sec:TypingRule.TEnumDecl});
  \item TypingRule.TRecordExceptionDecl (see
    Section~\ref{sec:TypingRule.TRecordExceptionDecl});
  \item TypingRule.TNonDecl (see Section~\ref{sec:TypingRule.TNonDecl});
  \item TypingRule.TBitField (see Section~\ref{sec:TypingRule.TBitField}).
\end{itemize}


\section{TypingRule.TString \label{sec:TypingRule.TString}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the string type \TString.
  \item \texttt{new\_ty} is the string type \TString.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{string} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TString.asl}


\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}


\isempty{\subsection{Comments}}

\section{TypingRule.TReal \label{sec:TypingRule.TReal}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the real type \TReal.
  \item \texttt{new\_ty} is the real type \TReal.
\end{itemize}


\subsection{Example}
In the following example, all the uses of \texttt{real} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TReal.asl}



\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TBool \label{sec:TypingRule.TBool}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the boolean type;
  \item \texttt{new\_ty} is the boolean type.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{boolean} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBool.asl}


\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TNamed \label{sec:TypingRule.TNamed}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the a named type \texttt{x};
  \item One of the following applies:
    \begin{itemize}
      \item \texttt{x} is bound in \texttt{tenv} to a type;
      \item an error ``\texttt{Undefined Identifier}'' is raised.
    \end{itemize}
  \item \texttt{new\_ty} is \texttt{ty}.
\end{itemize}

\subsection{Example}
In the following example, all the uses of \texttt{MyType} are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNamed.asl}


\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TInt \label{sec:TypingRule.TInt}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and one of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{ty} is the unconstrained integer type;
      \item \texttt{new\_ty} is the unconstrained integer type.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{ty} is a under-constrained integer type;
      \item \texttt{new\_ty} is the under-constrained integer type \texttt{ty}.
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{ty} is the well-constrained integer type constrained by
        \texttt{constraints};
      \item \texttt{constraints'} is the result of annotating each of the
        constraints in \texttt{constraints};
      \item \texttt{new\_ty} is the well-constrained integer type constrained
        by \texttt{constraints}.
    \end{itemize}
\end{itemize}

\subsection{Example}

In the following examples, all the uses of integer types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntWellConstrained.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TIntUnderConstrained.asl}


\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\isempty{\subsection{Comments}}


\section{TypingRule.TBits \label{sec:TypingRule.TBits}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the bit-vector type with width given by the expression
    \texttt{e\_width} and the bitfields given by \texttt{bitfields};
  \item \texttt{e\_width'} is the result of annotating the statically-evaluable integer expression \texttt{e\_width};
  \item \texttt{bitfields'} is the result of annotating the bitfields \texttt{bitfields}
  \item \texttt{new\_ty} is the bit-vector type with width given by the expression
    \texttt{e\_width'} and the bitfields given by \texttt{bitfields'};
\end{itemize}

\subsection{Example}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBits.asl}



In the following example, all the uses of bitvector types are valid:
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TTuple \label{sec:TypingRule.TTuple}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the tuple type with member types \texttt{tys};
  \item \texttt{tys'} is the result of annotating all the types in
    \texttt{tys};
  \item \texttt{new\_ty} is the tuple type with member types \texttt{tys'}.
\end{itemize}

\subsection{Example}
In the following example, all the uses of tuple types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TTuple.asl}



\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TArray \label{sec:TypingRule.TArray}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item All of the following holds:
    \begin{itemize}
      \item \texttt{ty} is the array type indexed by integer bounded by the
        expression \texttt{e} and of elements of type \texttt{t};
      \item \texttt{t'} is the result of annotating the type \texttt{t} in
        environment \texttt{env};
      \item \texttt{e'} is the result of annotating the statically evaluable
        integer expression \texttt{e};
      \item \texttt{new\_ty} is the array type indexed by integer bounded by
        the expression \texttt{e'} and of elements of type \texttt{t'};
    \end{itemize}
  \item All of the following holds:
    \begin{itemize}
      \item \texttt{ty} is the array type indexed by an enumeration type named
        \texttt{s} and of elements of type \texttt{t};
      \item \texttt{s} is bound in \texttt{env} to an enumeration type;
      \item \texttt{t'} is the result of annotating the type \texttt{t} in
        environment \texttt{env};
      \item \texttt{new\_ty} is the array type indexed by an enumeration type
        named \texttt{s} and of elements of type \texttt{t'};
    \end{itemize}
\end{itemize}

\subsection{Example}
In the following example, all the uses of array types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TArray.asl}


\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TEnumDecl \label{sec:TypingRule.TEnumDecl}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item \texttt{ty} is the enumeration type with enumeration literals
    \texttt{li};
  \item This is the declaration of \texttt{ty};
  \item One of the following applies:
    \begin{itemize}
      \item \texttt{li} does not contains any duplicate enumeration literal.
      \item an error ``\texttt{Already declared identifier}'' is raised;
    \end{itemize}
  \item \texttt{new\_ty} is the enumeration type \texttt{ty}.
\end{itemize}

\subsection{Example}
In the following example, all the uses of enumeration types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TEnumDecl.asl}



\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TRecordExceptionDecl \label{sec:TypingRule.TRecordExceptionDecl}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and one of the following applies:
\begin{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{ty} is the record type with fields \texttt{fields};
      \item This is the declaration of \texttt{ty};
      \item One of the following applies:
        \begin{itemize}
          \item \texttt{fields} does not contains any duplicate field.
          \item an error ``\texttt{Already declared identifier}'' is raised;
        \end{itemize}
      \item \texttt{fields'} is the result of annotating each type in
        \texttt{fields};
      \item \texttt{new\_ty} is the record type with fields \texttt{fields'};
    \end{itemize}
  \item All of the following apply:
    \begin{itemize}
      \item \texttt{ty} is the exception type with fields \texttt{fields};
      \item This is the declaration of \texttt{ty};
      \item One of the following applies:
        \begin{itemize}
          \item \texttt{fields} does not contains any duplicate field.
          \item an error ``\texttt{Already declared identifier}'' is raised;
        \end{itemize}
      \item \texttt{fields'} is the result of annotating each type in
        \texttt{fields};
      \item \texttt{new\_ty} is the exception type with fields \texttt{fields'};
    \end{itemize}
\end{itemize}


\subsection{Example}
In the following example, all the uses of record or exception types are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TRecordExceptionDecl.asl}



\CodeSubsection{\TRecordExceptionDeclBegin}{\TRecordExceptionDeclEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TNonDecl \label{sec:TypingRule.TNonDecl}}

\subsection{Prose}
Annotating a type~\texttt{ty} in an environment~\texttt{env} results in a
rewritten type~\texttt{new\_ty} and all of the following apply:
\begin{itemize}
  \item One of the following applies:
    \begin{itemize}
      \item \texttt{ty} is a record type;
      \item \texttt{ty} is an exception type;
      \item \texttt{ty} is an enumeration type;
    \end{itemize}
  \item This is not the declaration of \texttt{ty};
  \item An error ``Cannot use anonymous form of enumerations, record, or exceptions here.'' is raised.
\end{itemize}

\subsection{Example}

In the following example, the use of a record type out of a declaration is invalid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TNonDecl.asl}


\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


\section{TypingRule.TBitField \label{sec:TypingRule.TBitField}}

\subsection{Prose}


\subsection{Example}
In the following example, all the uses of bitvector types with bitfields are valid:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.TBitField.asl}



\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}


\isempty{\subsection{Comments}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textsf{annotate\_expr} specifies how to annotate an expression \texttt{e} in
an environment \tenv.  Formally, the result of annotating the expression
\texttt{e} in \tenv\ is either the pair \texttt{t, new\_e}, where \texttt{t} is a type and
\texttt{new\_e} is a rewritten expression, or an error, and one of the following applies:
\begin{itemize}
\item TypingRule.ELit (see Section~\ref{sec:TypingRule.ELit});
\item TypingRule.ELocalVarConstant (see Section~\ref{sec:TypingRule.ELocalVarConstant})
\item TypingRule.ELocalVar (see Section~\ref{sec:TypingRule.ELocalVar})
\item TypingRule.EGlobalVarConstant (see Section~\ref{sec:TypingRule.EGlobalVarConstant})
\item TypingRule.EGlobalVar (see Section~\ref{sec:TypingRule.EGlobalVar})
\item TypingRule.EUndefIdent (see Section~\ref{sec:TypingRule.EUndefIdent})
\item TypingRule.Binop (see Section~\ref{sec:TypingRule.Binop})
\item TypingRule.Unop (see Section~\ref{sec:TypingRule.Unop})
\item TypingRule.ECond (see Section~\ref{sec:TypingRule.ECond})
\item TypingRule.ESlice (see Section~\ref{sec:TypingRule.ESlice})
\item TypingRule.ECall (see Section~\ref{sec:TypingRule.ECall})
\item TypingRule.EGetArray (see Section~\ref{sec:TypingRule.EGetArray})
\item TypingRule.EStructuredNotStructured (see Section~\ref{sec:TypingRule.EStructuredNotStructured})
\item TypingRule.EStructuredMissingField (see Section~\ref{sec:TypingRule.EStructuredMissingField})
\item TypingRule.ERecord (see Section~\ref{sec:TypingRule.ERecord})
\item TypingRule.EGetRecordField (see Section~\ref{sec:TypingRule.EGetRecordField})
\item TypingRule.EGetBadRecordField (see Section~\ref{sec:TypingRule.EGetBadRecordField})
\item TypingRule.EGetBadBitField (see Section~\ref{sec:TypingRule.EGetBadBitField})
\item TypingRule.EGetBadField (see Section~\ref{sec:TypingRule.EGetBadField})
\item TypingRule.EGetBitField (see Section~\ref{sec:TypingRule.EGetBitField})
\item TypingRule.EGetBitFieldNested (see Section~\ref{sec:TypingRule.EGetBitFieldNested})
\item TypingRule.EGetBitFieldTyped (see Section~\ref{sec:TypingRule.EGetBitFieldTyped})
\item TypingRule.EConcatEmpty (see Section~\ref{sec:TypingRule.EConcatEmpty})
\item TypingRule.EConcat (see Section~\ref{sec:TypingRule.EConcat})
\item TypingRule.ETuple (see Section~\ref{sec:TypingRule.ETuple})
\item TypingRule.EUnknown (see Section~\ref{sec:TypingRule.EUnknown})
\item TypingRule.EPattern (see Section~\ref{sec:TypingRule.EPattern})
\item TypingRule.CTC (see Section~\ref{sec:TypingRule.CTC})
\end{itemize}

The annotation rewrites the input expression in the following cases, making the annotation of statements simpler:
\begin{itemize}
  \item Variables with constant values are substituted for their constant values.
  \item Slicing expressions that correspond to calling a getter are replaced with respective call expressions.
  \item Slicing expressions that correspond to array accesses are replaced with array access expressions.
\end{itemize}

\section{TypingRule.Lit \label{sec:TypingRule.Lit}}

Annotating literals is done via the function $\annotateliteral{\cdot}$,
which we use in this chapter as well as in subsequent chapters.
This is a helper rule for TypingRule.ELit.
\subsection{Prose}
The result of annotating a literal \texttt{l} is \texttt{t} and one of the following apply:
\begin{itemize}
\item \texttt{l} is an integer literal \texttt{n} and \texttt{t} is the well-constrained integer type, constraining
its set to the single value \texttt{n};
\item \texttt{l} is a Boolean literal and \texttt{t} is the Boolean type;
\item \texttt{l} is a real literal and \texttt{t} is the real type;
\item \texttt{l} is a string literal and \texttt{t} is the string type;
\item \texttt{l} is a string literal and \texttt{t} is the string type;
\item \texttt{l} is a bitvector literal of length \texttt{n} and \texttt{t} is the bitvector type of fixed width \texttt{n}.
\end{itemize}

\subsection{Example: TypingRule.Lit.asl}
In the following example, we show several literals and their corresponding types in comments:
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Lit.asl}


  \CodeSubsection{\LitBegin}{\LitEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{}{\annotateliteral{\Elit{n}}= \TInt(\langle[\texttt{Constraint\_Exact}(\Elit{n})]\rangle)}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lbool(\Ignore)}}= \TBool}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lreal(\Ignore)}}= \TReal}
    \and
    \inferrule{}{\annotateliteral{\eliteral{\lstring(\Ignore)}}= \TString}
    \and
    \inferrule{\vl = \eliteral{\lbitvector(b_{1..n})}}
    {\annotateliteral{\vl}= \TBits(\texttt{Bitwidth\_SingleExpr}(\Elit{n}), \emptylist)}
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.ELit \label{sec:TypingRule.ELit}}
  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} is a literal expression \texttt{v};
  \item \texttt{t} is the type of the literal \texttt{v};
  \item \texttt{new\_e} is \texttt{e}.
  \end{itemize}
  \subsection{Example}

  \CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{\annotateliteral{\vv} \typearrow \vt}
{\annotateexpr{\tenv, \ELiteral(\vv)} \typearrow (\vt, \ELiteral(\vv))}
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ELocalVarConstant \label{sec:TypingRule.ELocalVarConstant}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a local variable \texttt{x};
  \item \texttt{x} is bound to a local constant~\texttt{v} of type \texttt{ty} in the local environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is the Literal \texttt{v}.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\ELocalVarConstantBegin}{\ELocalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \vv\\
  L^\tenv.\storagetypes(\vx) = (\tty, \texttt{LDK\_Constant})
  }
{\annotateexpr{\tenv, \EVar(\vx)} = (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ELocalVar \label{sec:TypingRule.ELocalVar}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a local variable \texttt{x};
  \item \texttt{x} is not bound to a local constant;
  \item \texttt{x} has type \texttt{ty} in the local environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is \texttt{e}.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\ELocalVarBegin}{\ELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  L^\tenv.\constantvalues(\vx) = \bot\\
  L^\tenv.\storagetypes(\vx) =  (\tty, k) \\
  k \in \{\texttt{LDK\_Var}, \texttt{LDK\_Let}\}
  }
{\annotateexpr{\tenv, \EVar(\vx)} = (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantVal \label{sec:TypingRule.EGlobalVarConstant}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a global variable \texttt{x};
  \item \texttt{x} is bound to a global constant~\texttt{v} of type \texttt{ty} in the global environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is the Literal \texttt{v}.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\EGlobalVarConstantBegin}{\EGlobalVarConstantEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\storagetypes(\vx) = (\tty, \texttt{GDK\_Constant})\\
  G^\tenv.\constantvalues(\vx) = \vv
  }
{\annotateexpr{\tenv, \EVar(\vx)} = (\tty, \eliteral{\vv})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVarConstantNoVal \label{sec:TypingRule.EGlobalVarConstantNoVal}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a global variable \texttt{x};
  \item \texttt{x} is not bound to constant in the global environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is \texttt{e}.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\EGlobalVarConstantNoValBegin}{\EGlobalVarConstantNoValEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\storagetypes(\vx) = (\tty, \texttt{GDK\_Constant})\\
  G^\tenv.\constantvalues(\vx) = \bot
  }
{\annotateexpr{\tenv, \EVar(\vx)} = (\tty, \EVar(\vx))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGlobalVar \label{sec:TypingRule.EGlobalVar}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a global variable \texttt{x};
  \item \texttt{x} is not bound to a global constant;
  \item \texttt{x} has type \texttt{ty} in the global environment given by \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is \texttt{e}.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\EGlobalVarBegin}{\EGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  G^\tenv.\constantvalues(\vx) = \bot\\
  G^\tenv.\storagetypes(\vx) = (\tty, k)\\
  k \neq \texttt{GDK\_Constant}
  }
{\annotateexpr{\tenv, \EVar(\vx)} = (\tty, \EVar(\vx))}
\end{mathpar}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUndefIdent \label{sec:TypingRule.EUndefIdent}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} is a variable \texttt{x};
  \item \texttt{x} is not bound in \texttt{env};
  \item an error ``\texttt{Undefined Identifier}'' is raised.
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Binop \label{sec:TypingRule.Binop}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a binary operation \texttt{op} over two expressions \texttt{e1} and \texttt{e2};
  \item \texttt{t1,e1'} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t2,e2'} is the result of annotating \texttt{e2} in \texttt{env};
  \item \texttt{t} is the result of checking compatibility of \texttt{op} with \texttt{t1} and \texttt{t2} as per Section~\ref{sec:TypingRule.CheckBinop};
  \item \texttt{new\_env} denotes \texttt{op} over \texttt{e1'} and \texttt{e2'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veone') \terminateas \TypeErrorConfig\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwo') \terminateas \TypeErrorConfig\\\\
  \CheckBinop(\tenv, \op, \vtone, \vttwo) \typearrow \vt
  }
{\annotateexpr{\tenv, \EBinop(\op, \veone, \vetwo)} \typearrow (\vt, \EBinop(\op, \veone', \vetwo'))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.Unop \label{sec:TypingRule.Unop}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a unary operation \texttt{op} over an expression \texttt{e'};
  \item \texttt{t'',e''} is the result of annotating \texttt{e'} in \texttt{env};
  \item \texttt{t} is the result of checking compatibility of \texttt{op} with \texttt{t''} as per Section~\ref{sec:TypingRule.CheckUnop};
  \item \texttt{new\_e} denotes \texttt{op} over \texttt{e''}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve'} = (\vt'', \ve'')\\
  \CheckUnop(\tenv, \op, \vt'') = \vt
  }
{\annotateexpr{\tenv, \texttt{E\_Unop}(\op, \ve')} = (\vt, \texttt{E\_Unop}(\op, \ve''))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.ECond \label{sec:TypingRule.ECond}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a conditional expression with condition \texttt{e\_cond} with two options \texttt{e\_true} and \texttt{e\_false};
  \item \texttt{t\_cond, e'\_cond} is the result of annotating \texttt{e\_cond} in \texttt{env};
  \item \texttt{t\_true, e'\_true} is the result of annotating \texttt{e\_true} in \texttt{env};
  \item \texttt{t\_false, e'\_false} is the result of annotating \texttt{e\_false} in \texttt{env};
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t} is the lowest common ancestor of \texttt{t\_true} and \texttt{t\_false};
      \item \texttt{new\_e} is the condition \texttt{e'\_cond} with two options \texttt{e'\_true} and \texttt{e'\_false}.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item there is no lowest common ancestor of \texttt{t\_true} and \texttt{t\_false};
      \item an error ``\texttt{Unreconciliable Types}'' is raised.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} = (\tcond, \econd')\\
  \annotateexpr{\tenv, \etrue} = (\ttrue, \etrue')\\
  \annotateexpr{\tenv, \efalse} = (\tfalse, \efalse')\\
  \lca(\ttrue, \tfalse) = \vt
  }
{\annotateexpr{\texttt{E\_Cond}(\econd, \etrue, \efalse)} = (\vt, \texttt{E\_Cond}(\econd', \etrue', \efalse'))}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{XZVT}.

\section{TypingRule.ESlice \label{sec:TypingRule.ESlice}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t, new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the slicing of expression \texttt{e'} by the slices \texttt{slices};
  \item \texttt{t\_e',e'} is the result of annotating the expression \texttt{e'} in \texttt{env};
  \item the structure of \texttt{t\_e'} is that of a bitvector or an integer;
  \item an error ``\texttt{Conflicting Types}'' is raised or \texttt{t\_e'} has the structure of an integer or a bitvector and all of the following apply:
  \item \texttt{w} is the width of \texttt{slices};
  \item \texttt{slices'} is the result of annotating \texttt{slices} in \texttt{env};
  \item \texttt{t} is the bitvector type of width \texttt{w};
  \item \texttt{new\_e} is the slicing of expression \texttt{e'} by the slices \texttt{slices'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
The rule below makes use of slice annotation (\annotateslices), which is defined in Chapter~\ref{ch:typingslices}.
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} = (\vt, \ve')\\
  \astlabel(\tstruct(\tenv, \vt)) \in \{\TInt, \TBits\}\\
  \sliceswidth(\tenv, \texttt{slices}) = \vw\\
  \annotateslices(\tenv, \texttt{slices}) = \texttt{slices}'
  }
{\annotateexpr{\tenv, \texttt{E\_Slice}(\ve, \texttt{slices})} = \\\
 (\TBits(\texttt{BitWidth\_SingleExpr}(\vw), \emptylist), \texttt{E\_Slice}(\ve', \texttt{slices}'])}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  The width of \texttt{slices} might be a symbolic expression if one of the
  widths references a \texttt{let} identifier with a non-compile-time-constant
  initialiser expression.

  This is related to \identi{MJWM}.

\section{TypingRule.ECall \label{sec:TypingRule.ECall}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a call to a subprogram named \texttt{name} with arguments \texttt{args} and
    parameters \texttt{eqs};
  \item \texttt{name', args', eqs', ty} is the result of annotating the call of
    that subprogram in \texttt{env} (annotating calls is defined in Chapter~\ref{ch:TypingSubprogramCalls});
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is the call to the subprogram named \texttt{name'} with arguments \texttt{args'}
    and parameters \texttt{eqs'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{ \annotatecall{\tenv, \name, \vargs, \eqs, \texttt{ST\_Function}} = (\name, \vargs', \eqs', \langle \vt \rangle)  }
{\annotateexpr{\tenv, \texttt{E\_Call}(\name, \vargs, \eqs)} =
(\vt, \texttt{E\_Call}(\name, \vargs', \eqs'))}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{CFYP}, \identr{BQJG}.

\section{TypingRule.EGetArray \label{sec:TypingRule.EGetArray}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} or an error and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the slicing of expression \texttt{e'} by the slices \texttt{slices};
  \item \texttt{t\_e',e''} is the result of annotating the expression \texttt{e'} in \texttt{env};
  \item \texttt{t\_e'} has the structure of an array with index \texttt{size} and element type \texttt{ty}';
  \item the expression \texttt{size} can be annotated with the type \texttt{wanted\_t\_index};
  \item an error ``Conflicting Types'' is raised or \texttt{slices} is a single expression \texttt{e\_index} and all of the following apply:
  \item \texttt{t\_index', e\_index'} is the result of annotating \texttt{e\_index} in \texttt{env};
  \item an error ``\texttt{Conflicting Types}'' or \texttt{t\_index'} type-satisfies \texttt{wanted\_t\_index} as per Section~\ref{sec:TypingRule.TypeSatisfaction} and all of the following apply:
  \item \texttt{new\_e} is an access to array \texttt{e''} at index \texttt{e\_index'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
We first define helper rules to annotate the index of an array expression:
\begin{mathpar}
\inferrule{G^\tenv.\declaredtypes(n) = \vt}
{\annotatearrayindex(\tenv, \EVar(n)) = \vt}
\and
\inferrule{G^\tenv.\declaredtypes(n) = \bot\\
l_f = \Elit{0} \\
\vlt = \texttt{E\_Binop}(\texttt{"-"}, \EVar(n), \Elit{1})
}
{\annotatearrayindex(\tenv, \EVar(n)) = \TInt(\langle[\texttt{Constraint\_Range}(l_f, \vlt)]\rangle)}
\and
\inferrule{\astlabel(\ve) \neq \texttt{E\_Var} \\
l_f = \Elit{0} \\
\vlt = \texttt{E\_Binop}(\texttt{"-"}, \ve, \Elit{1})
}
{\annotatearrayindex(\tenv, \ve) = \TInt(\langle[\texttt{Constraint\_Range}(l_f, \vlt)]\rangle)}
\end{mathpar}

And now define the rule to annotate the array access expression:
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \texttt{e}} = (\texttt{t\_e}', \texttt{e}'')\\
  \tstruct(\tenv, \texttt{t\_e}') = \TArray(\texttt{size}, \texttt{ty}')\\
  \annotatearrayindex(\tenv, \texttt{size}) = \texttt{wanted\_t\_index}\\
  \annotateexpr{\tenv, \eindex} = (\texttt{t\_{index}}', \texttt{e\_{index}}')\\
  \typesatisfies(\tenv, \texttt{t\_{index}}', \texttt{wanted\_t\_index})\\
  }
{\annotateexpr{\tenv, \texttt{E\_Slice}(\texttt{e}', [\SliceSingle(\eindex)])} =\\\\
 (\texttt{ty'}, \texttt{E\_GetArray}(\texttt{e''}, \texttt{e\_{index}}'))
 }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EStructuredNotStructured \label{sec:TypingRule.EStructuredNotStructured}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression or an exception expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is neither a record nor an exception type;
  \item an error ``\texttt{Conflicting Types}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EStructuredNotStructuredBegin}{\EStructuredNotStructuredEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

  This is related to \identr{WBCQ}.

\section{TypingRule.EStructuredMissingField \label{sec:TypingRule.EStructuredMissingField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression or an exception expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is the name of a record or exception type with fields \texttt{field\_types};
  \item one field in \texttt{field\_types} is not initialised by \texttt{fields};
  \item an error ``\texttt{Missing Field}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EStructuredMissingFieldBegin}{\EStructuredMissingFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WBCQ}.

\section{TypingRule.ERecord \label{sec:TypingRule.ERecord}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the record expression of type \texttt{ty} with fields \texttt{fields};
  \item \texttt{ty} is the name of a record type with fields \texttt{field\_types};
  \item For each field named \texttt{name} associated with the expression \texttt{e'} in
    \texttt{field\_types}, all of the following apply:
    \begin{itemize}
    \item \texttt{t',e''} is the result of annotating \texttt{e'} in \texttt{env};
    \item \texttt{t\_spec'} is the type associated to \texttt{name} in \texttt{field\_types};
    \item \texttt{t'} type-satisfies \texttt{t\_spec'} as per Section~\ref{sec:TypingRule.TypeSatisfaction};
    \item \texttt{fields'} associates \texttt{name} to \texttt{e''};
    \end{itemize}
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is the record expression of type \texttt{ty} with fields \texttt{fields'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
L \in \{\TRecord, \TException\}\\
i=1..k: \annotateexpr{\vt_i, \ve_i} = (\vt_i',\ve_i')\\
i=1..k: \typesatisfies(\tenv, \vt_i', \vt_i)
}
{\annotateexpr{\tenv, L(\tty, [i=1..k: (f_i,\ve_i)])} = (\tty, L(\tty, [i=1..k: (f_i,\ve_i')]))}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WBCQ}.


\section{TypingRule.EGetRecordField \label{sec:TypingRule.EGetRecordField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has an underlying type of an exception or record type with fields \texttt{fields};
  \item \texttt{field\_name} is declared in \texttt{fields};
  \item \texttt{t} is the type corresponding to \texttt{field\_name} in \texttt{fields};
  \item \texttt{new\_e} is the access of field \texttt{field\_name} on expression \texttt{e2}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \veone} = (\texttt{t\_e1}, \vetwo)\\
\makeanonymous(\tenv, \texttt{t\_e1}) = L(\fields)\\
L \in \{\TRecord, \TException\}\\
(\fieldname,\vt) \in \fields
}
{\annotateexpr{\tenv, \texttt{E\_GetField}(\veone, \fieldname)} = (\vt, \texttt{E\_GetField}(\fieldname, \vetwo))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadRecordField \label{sec:TypingRule.EGetBadRecordField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{t\_e2} has the structure of an exception or record type with fields \texttt{fields};
  \item \texttt{t\_e2} is an Exception or a Record type with fields \texttt{fields};
  \item \texttt{field\_name} is not declared in \texttt{fields};
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadBitField \label{sec:TypingRule.EGetBadBitField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1} has the structure a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{t\_e2} has the structure a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is not declared in \texttt{bitfields};
  \item an error ``\texttt{Bad Field}'' is raised.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBadField \label{sec:TypingRule.EGetBadField}}

 \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
   \begin{itemize}
   \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
   \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t\_e1} does not have the structure of a record or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

 \subsection{Example}


    \CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitField \label{sec:TypingRule.EGetBitField}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item the underlying type of \texttt{t\_e1} is a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name}
    in \\ \texttt{bitfields};
  \item \texttt{e3} denotes the slicing of the expression \texttt{e2} by the slices \texttt{slices};
  \item \texttt{t,new\_e} is the result of annotating \texttt{e3}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \veone} = (\texttt{t\_e1}, \vetwo)\\
\makeanonymous(\tenv, \texttt{t\_e1}) = \TBits(\Ignore, \bitfields)\\
\fieldname = \texttt{BitField\_Simple}(\Ignore, \slices) \in \bitfields\\
\texttt{e3} = \texttt{E\_Slice}(\vetwo, \slices)\\
\annotateexpr{\tenv, \texttt{e3}} = (\vt, \newe)
}
{\annotateexpr{\tenv, \texttt{E\_GetField}(\veone, \fieldname)} = (\vt, \newe)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldNested \label{sec:TypingRule.EGetBitFieldNested}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the access of field \texttt{field\_name} on expression \texttt{e1};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the structure of a bitvector type with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name} in \\
    \texttt{bitfields};
  \item \texttt{e3} denotes the slicing of the expression \texttt{e2} by the slices \texttt{slices};
  \item \texttt{t4, e4} is the result of annotating \texttt{e3} in \texttt{env};
  \item \texttt{bitfields'} gives the bitfields corresponding to the bitfield \texttt{field\_name}
    in \texttt{bitfields};
  \item \texttt{t} is the bitvector type with the width of \texttt{t4} and the bitfields \texttt{bitfields'}
  \item \texttt{new\_e} is \texttt{e4}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EGetBitFieldTyped \label{sec:TypingRule.EGetBitFieldTyped}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes \texttt{e1, field\_name};
  \item \texttt{t\_e1, e2} is the result of annotating \texttt{e1} in \texttt{env};
  \item \texttt{t\_e1} has the underlying type of a bitvector with bitfields \texttt{bitfields};
  \item \texttt{field\_name} is declared in \texttt{bitfields};
  \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field\_name} in \\
    \texttt{bitfields};
  \item \texttt{t} is the type associated with \texttt{field\_name} in \texttt{bitfields};
  \item \texttt{t\_e3,e3} is the result of annotating \texttt{e2,slices} in \texttt{env};
  \item \texttt{t} is the type corresponding to the bitfield \texttt{field\_name} in \texttt{bitfields};
  \item \texttt{t\_e3} type-satisfies \texttt{t} in \texttt{env};
  \item \texttt{new\_e} is \texttt{e3}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} = (\texttt{t\_e1}, \vetwo)\\
  \makeanonymous(\tenv, \texttt{t\_e1}) = \TBits(\Ignore, \bitfields)\\
  \fieldname = \texttt{BitField\_Type}(\Ignore, \slices, \vt) \in \bitfields\\
  \annotateexpr{\texttt{E\_Slice}(\vetwo, \slices)} = (\texttt{t\_e3}, \texttt{e3})\\
  \typesatisfies(\tenv, \texttt{t\_e3}, \vt)
}
{\annotateexpr{\tenv, \texttt{E\_GetField}(\veone, \fieldname)} = (\vt, \texttt{e3})}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcatEmpty \label{sec:TypingRule.EConcatEmpty}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the empty concatenation;
  \item \texttt{t} is \texttt{bits(0)};
  \item \texttt{new\_e} is \texttt{e}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EConcatEmptyBegin}{\EConcatEmptyEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{\ve = \texttt{E\_Concat}(\emptylist)}
{
\annotateexpr{\tenv, \ve} = (\TBits(\texttt{BitWidth\_SingleExpr}(\Elit{0}, \emptylist)), \ve)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EConcat \label{sec:TypingRule.EConcat}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the concatenation of a non-empty list of expressions \texttt{li};
  \item \texttt{ts, es} is the list of types and the list of corresponding expressions resulting from annotating each element of \texttt{li} in \texttt{env};
  \item all elements of \texttt{ts} have the structure of a bitvector type;
  \item \texttt{w} is the sum of the widths of the bitvector types in \texttt{ts};
  \item \texttt{t} is \texttt{bits(w)};
  \item \texttt{new\_e} is the concatenation expression for \texttt{es}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EConcatBegin}{\EConcatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\[
\inferrule{
\texttt{li} = [i=1..k: \texttt{el}_i]\\
[\annotateexpr{\tenv, \texttt{el}_i} = (\ve_i, \vt_i)\;|\; i=1..k]\\
\texttt{ts} = [i=1..k: \vt_i]\\
\texttt{es} = [i=1..k: \ve_i]\\
i=1..k: \astlabel(\tstruct(\tenv, \vt_i)) = \TBits\\
\getbitvectorwidth(\tenv, \texttt{ts}) = \vw
}
{
\annotateexpr{\tenv, \texttt{E\_Concat}(\texttt{li})} = (\TBits(w, \emptylist)),
\annotateexpr{\tenv, \texttt{E\_Concat}(\texttt{li})} = (\TBits(w, \emptylist)),
\texttt{E\_Concat}(\texttt{es}, \langle\rangle)
}
\]
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{NYNK} and \identr{KCZS}.

  The sum of the widths of the bitvector types~\texttt{ts} might be a symbolic
expression that is unresolvable to an integer. For example:
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.EConcatUnresolvableToInteger.asl}


\section{TypingRule.ETuple \label{sec:TypingRule.ETuple}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a tuple \texttt{li};
  \item \texttt{ts, es} is the result of annotating in \texttt{env} each expression in \texttt{li};
  \item \texttt{t} is \texttt{ts};
  \item \texttt{new\_e} is \texttt{es}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule[Empty Tuple Expression]{}
  {
  \annotateexpr{\tenv, \texttt{E\_Tuple}([])} = (\TTuple([]), \texttt{E\_Tuple}([]))
  }
\and
\inferrule{
  \texttt{li} = [i=1..k: \texttt{el}_i]\\
  [\annotateexpr{\tenv, \texttt{el}_i} = (\ve_i, \vt_i)\;|\; i=1..k]\\
  \texttt{ts} = [i=1..k: \vt_i]\\
  \texttt{es} = [i=1..k: \ve_i]
}
{
\annotateexpr{\tenv, \texttt{E\_Tuple}(\texttt{li})} = (\TTuple(\texttt{ts}), \texttt{E\_Tuple}(\texttt{es}))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EUnknown \label{sec:TypingRule.EUnknown}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an expression \texttt{UNKNOWN} of type \texttt{ty};
  \item \texttt{ty'} is the structure of \texttt{ty} in \texttt{env};
  \item \texttt{t} is \texttt{ty};
  \item \texttt{new\_e} is an expression \texttt{UNKNOWN} of type \texttt{ty'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EUnknownBegin}{\EUnknownEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \tstruct(\tenv, \tty) = \tty'
}
{\annotateexpr{\tenv, \texttt{E\_Unkown}(\tty)} = (\tty, \texttt{E\_Unkown}(\tty'))}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.EPattern \label{sec:TypingRule.EPattern}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes whether the expression \texttt{e'} matches \texttt{patterns};
  \item \texttt{t\_e', e''} is the result of annotating \texttt{e'} in \texttt{env};
  \item \texttt{patterns'} is the result of annotating \texttt{patterns, t\_e'} in \texttt{env};
  \item \texttt{t} is \texttt{boolean};
  \item \texttt{new\_e} denotes whether the expression \texttt{e''} matches \texttt{patterns'}.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.CTC \label{sec:TypingRule.CTC}}

  \subsection{Prose}
  The result of annotating the expression \texttt{e} in \texttt{env} is
\texttt{t,new\_e} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an expression \texttt{e'} and a type \texttt{t'};
  \item \texttt{t'',new\_e} is the result of annotating \texttt{e'} in \texttt{env};
  \item One of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t''} is a structural subtype of \texttt{t} in \texttt{env};
      \item \texttt{t''} is a domain subtype of \texttt{t} in \texttt{env};
      \item \texttt{t} is \texttt{t'}
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{t''} is a structural subtype of \texttt{t'} in \texttt{env};
      \item \texttt{t''} is not a domain subtype of \texttt{t'} in \texttt{env};
      \item an execution-time check that the expression evaluates to a value in the
        runtime domain of the required type is required.
      \item \texttt{new\_e} is the expression denoting a Checked Type
        Conversion of \texttt{new\_e'} in the type \texttt{t'}.
     \end{itemize}
   \item All of the following apply:
     \begin{itemize}
     \item \texttt{t''} is not a structural subtype of \texttt{t'} in \texttt{env};
     \item a ``\texttt{ConflictingTypes}'' error is raised.
     \end{itemize}
   \end{itemize}
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\CTCBegin}{\CTCEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \ve'} = (\vt'', \newe)\\
\domsubtypesat(\tenv, \vt'', \vt)\\
\structsubtypesat(\tenv, \vt'', \vt)
}
{
\annotateexpr{\tenv, \texttt{E\_CTC}(\ve', \vt')} = (\vt', \texttt{E\_CTC}(\ve'', \vt'))
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{VBLL}, \identi{KRLL}, \identg{PFRQ}, \identi{XVBG},
  \identr{GYJZ}, \identi{SZVF}, \identr{PZZJ}, \identr{YCPX}, \identi{ZLBW},
  \identi{TCST}, \identi{CGRH}, \identi{YJBB}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Left-Hand-Side Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a left-hand side expression~\texttt{le} in an environment~\texttt{env}, assuming \texttt{t\_e}
to be the type of the corresponding right-hand-side (\texttt{annotate\_lexpr env le t\_e}),
results in a rewritten expression \texttt{new\_le} and one of the following applies:
\begin{itemize}
\item TypingRule.LEDiscard (see Section~\ref{sec:TypingRule.LEDiscard}),
\item TypingRule.LELocalVar (see Section~\ref{sec:TypingRule.LELocalVar}),
\item TypingRule.LEGlobalVar (see Section~\ref{sec:TypingRule.LEGlobalVar}),
\item TypingRule.LEDestructuring (see Section~\ref{sec:TypingRule.LEDestructuring}),
\item TypingRule.LESlice (see Section~\ref{sec:TypingRule.LESlice}),
\item TypingRule.LESetArray (see Section~\ref{sec:TypingRule.LESetArray}),
\item TypingRule.LESetBadStructuredField (see Section~\ref{sec:TypingRule.LESetBadStructuredField}),
\item TypingRule.LESetStructuredField (see Section~\ref{sec:TypingRule.LESetStructuredField}),
\item TypingRule.LESetBadBitField (see Section~\ref{sec:TypingRule.LESetBadBitField}),
\item TypingRule.LESetBitField (see Section~\ref{sec:TypingRule.LESetBitField}),
\item TypingRule.LESetBitFieldNested (see Section~\ref{sec:TypingRule.LESetBitFieldNested}),
\item TypingRule.LESetBitFieldTyped (see Section~\ref{sec:TypingRule.LESetBitFieldTyped}),
\item TypingRule.LESetBadField (see Section~\ref{sec:TypingRule.LESetBadField}),
\item TypingRule.LEConcat (see Section~\ref{sec:TypingRule.LEConcat}).
\end{itemize}

Some of the rules require viewing left-hand-side expressions as their corresponding right-hand side expressions.
The correspondence is defined in the ASL Syntax Reference~\cite[Chapter 5]{ASLAbstractSyntaxReference}
and given by the function $\torexpr : \lexpr \rightarrow \expr$.

\section{TypingRule.LEDiscard \label{sec:TypingRule.LEDiscard}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes an expression which can be discarded;
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Discard}\\
  \newle \eqdef \vle
}
{
  \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LELocalVar \label{sec:TypingRule.LELocalVar}}

   \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a local variable \texttt{x};
   \item \texttt{x} is locally declared as a mutable variable of type \texttt{ty} in \texttt{env};
   \item \texttt{ty} type-satisfies \texttt{t\_e};
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LELocalVarBegin}{\LELocalVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle \eqname \texttt{LE\_Var}(\id)\\
  L^\tenv.\storagetypes(\id) = (\tty, \texttt{LDK\_Var})\\
  \typesatisfies(\tenv, \vte, \tty)\\
  \newle \eqdef \vle
}
{ \annotatelexpr{\tenv, \vle, \vte} \typearrow \newle }
\end{mathpar}

\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WDGQ}, \identr{GNTS}, \identi{MMKF},
  \identi{DGWJ}, \identi{KKCC} and \identr{LXQZ}.

\section{TypingRule.LEGlobalVar \label{sec:TypingRule.LEGlobalVar}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a global variable \texttt{x};
   \item \texttt{x} is globally declared as a variable of type \texttt{ty} in \texttt{env};
   \item \texttt{t\_e} type-satisfies \texttt{ty};
   \item \texttt{new\_le} is \texttt{le}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEGlobalVarBegin}{\LEGlobalVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Var}(\id)\\
  G^\tenv.\storagetypes(\id) = (\vt', \Ignore)\\
  \typesatisfies(\tenv, \vt', \vte)\\
  \newle = \vle
}
{ \annotatelexpr{\tenv, \vle, \vte} = \newle }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WDGQ}.

\section{TypingRule.LEDestructuring \label{sec:TypingRule.LEDestructuring}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes a tuple \texttt{les};
   \item \texttt{t\_e} has the structure of a tuple type \texttt{sub\_tys};
   \item the elements of \texttt{sub\_tys} type-satisfies the type of the elements of \texttt{les};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} have the same length;
       \item \texttt{new\_le} is the result of annotating \texttt{les} with \texttt{sub\_tys} in \texttt{env}
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{les} and \texttt{sub\_tys} do not have the same length;
       \item an error ``\texttt{Bad Arity LEDestructuring}'' is raised.
       \end{itemize}
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_Destructuring}(\les)\\
  \vte = \TTuple(\subtys)\\
  \les = [\ve_{1..k}]\\
  \subtys = [\vt_{1..k}]\\
  i=1..k: \annotateexpr{\tenv, \ve_i,\vt_i} = \ve'_i\\
  \les' = [i=1..k: \ve'_i]\\
  \newle = \texttt{LE\_Destructuring}(\les')
}
{ \annotatelexpr{\tenv, \vle, \vte} = \newle }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESlice \label{sec:TypingRule.LESlice}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices \texttt{slices};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector type;
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{width} is the width of the slices \texttt{slices} in \texttt{env};
   \item \texttt{t} is the bitvector type of width \texttt{width};
   \item \texttt{te} type-satisfies \texttt{t};
   \item \texttt{slices2} is the result of annotating \texttt{slices} in \texttt{env};
   \item \texttt{new\_le} is the slicing of \texttt{le2} by \texttt{slices2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \leslice(\vleone, \slices)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
  \astlabel(\tstruct(\tenv, \vtleone)) = \TBits\\
  \annotatelexpr{\tenv, \vleone, \vtleone} = \vletwo\\
  \sliceswidth(\tenv, \slices) = \vwidth\\
  \vt = \TBits(\texttt{BitWidth\_SingleExpr}(\vwidth, \emptylist))\\
  \typesatisfies(\tenv, \vt, \vte)\\
  \texttt{slices2} = [\annotateslices(\tenv, \vs) \;|\; \vs \in \slices]\\
  \newle = \leslice(\vletwo, \texttt{slices2})
}
{ \annotatelexpr{\tenv, \vle, \vte} = \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetArray \label{sec:TypingRule.LESetArray}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the slicing of a left-hand-side expression \texttt{le1} by the slices \texttt{slices};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an array type of size \texttt{size} and item type \texttt{t};
   \item \texttt{te} type-satisfies \texttt{t};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
  % ROMAN: The following is not what the code does so I replaced it with subsequent item.
  %  \item One of the following applies:
  %    \begin{itemize}
  %    \item \texttt{wanted\_t\_index} is an enumeration type of name \texttt{size};
  %    \item \texttt{wanted\_t\_index} is the type \texttt{integer {0..size-1}};
  %    \end{itemize}
  \item the expression \texttt{size} can be annotated with the type \texttt{wanted\_t\_index};
  \item \texttt{slices} is a single expression \texttt{e\_index};
   \item \texttt{t\_index', e\_index'} is the result of annotating \texttt{e\_index} in \texttt{env};
   \item \texttt{wanted\_t\_index} type-satisfies \texttt{t\_index'}, which guarantees that the index
   is within the bounds of the array;
   \item \texttt{new\_le} is an access to array \texttt{le2} at index \texttt{e\_index'}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \leslice(\vleone, \slices)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
  \tstruct(\tenv, \vtleone) = \TArray(\size, \vt)\\
  \typesatisfies(\tenv, \vte, \vt)\\
  \annotatelexpr{\tenv, \vleone} = \vletwo\\
  \annotatearrayindex(\tenv, \size) = \wantedtindex\\
  \slices = [\SliceSingle(\eindex)]\\
  \annotateexpr{\tenv, \eindex} = (\tindex', \eindex')\\
  \typesatisfies(\tenv, \tindex', \wantedtindex)\\
  \newle = \texttt{LS\_SetArray}(\vletwo, \eindex')
}
{\annotatelexpr{\tenv, \vle, \vte} = \newle}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadStructuredField \label{sec:TypingRule.LESetBadStructuredField}}

  \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields \texttt{fields};
   \item \texttt{field} is not declared in \texttt{fields};
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadStructuredFieldBegin}{\LESetBadStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetStructuredField \label{sec:TypingRule.LESetStructuredField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of an exception or a record type with fields \texttt{fields};
   \item \texttt{field} is bound to type \texttt{t} in \texttt{fields};
   \item \texttt{t} type-satisfies \texttt{t\_e};
   \item \texttt{new\_le} is the access to the field \texttt{field} in \texttt{le2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
  \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
  \annotatelexpr{\tenv, \vleone} = \vletwo\\
  L \in \{\TRecord, \TException\}\\
  \tstruct(\tenv, \vtleone) = L(\{\vfield:t, \ldots\})\\
  \typesatisfies(\tenv, \vte, \vt)\\
  \newle = \texttt{LE\_SetField}(\vletwo, \vfield)
}
{
  \annotatelexpr{\tenv, \vle, \vte} = \newle
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadBitField \label{sec:TypingRule.LESetBadBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{field} is not declared in \texttt{bitfields};
   \item an error ``\texttt{Bad Field}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadBitFieldBegin}{\LESetBadBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitField \label{sec:TypingRule.LESetBitField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{field} is declared in \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{t} is the bitvector type of width \texttt{w};
   \item \texttt{t} type-satisfies \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldBegin}{\LESetBitFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} = \vletwo\\
    \tstruct(\tenv, \vtleone) = \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Simpled}(\vfield, \vslices) \in \bitfields\\
    \sliceswidth(\tenv, \vslices) = \vw\\
    \vt = \TBits(\texttt{BitWidth\_SingleExpr(\vw), \bitfields})\\
    \typesatisfies(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \newle = \annotatelexpr{\vletwo, \vslices}
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} = \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldNested \label{sec:TypingRule.LESetBitFieldNested}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{bitfields'} gives the bitfields corresponding to \texttt{field} in \texttt{bitfields};
   \item \texttt{t} is the bitvector type of width \texttt{w} and bitfields \texttt{bitfields'};
   \item \texttt{t} type-satisfies \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldNestedBegin}{\LESetBitFieldNestedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} = \vletwo\\
    \tstruct(\tenv, \vtleone) = \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Nested}(\vfield, \vslices, \bitfields') \in \bitfields\\
    \sliceswidth(\tenv, \vslices) = \vw\\
    \vt = \TBits(\texttt{BitWidth\_SingleExpr(w), \bitfields'})\\
    \typesatisfies(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \newle = \annotatelexpr{\vletwo, \vslices}
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} = \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBitFieldTyped \label{sec:TypingRule.LESetBitFieldTyped}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} has the structure of a bitvector with bitfields \texttt{bitfields};
   \item \texttt{slices} gives the slices corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{w} is the width of \texttt{slices};
   \item \texttt{t'} is the bitvector type of width \texttt{w};
   \item \texttt{t} gives the type corresponding to the bitfield \texttt{field} in
      \texttt{bitfields};
   \item \texttt{t} type-satisfies \texttt{t'};
   \item \texttt{t} type-satisfies \texttt{t\_e};
   \item \texttt{le2} is the slicing of \texttt{le1} by \texttt{slices};
   \item \texttt{new\_le} is the result of annotating \texttt{le2} in \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBitFieldTypedBegin}{\LESetBitFieldTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vle = \texttt{LE\_SetField}(\vleone, \vfield)\\
    \annotateexpr{\tenv, \torexpr(\vleone)} = (\vtleone, \Ignore)\\
    \annotatelexpr{\tenv, \vleone} = \vletwo\\
    \tstruct(\tenv, \vtleone) = \TBits(\Ignore, \bitfields)\\
    \texttt{BitField\_Type}(\vfield, \vslices, \vt) \in \bitfields\\
    \sliceswidth(\tenv, \vslices) = \vw\\
    \vt' = \TBits(\texttt{BitWidth\_SingleExpr(w), \emptylist})\\
    \typesatisfies(\tenv, \vt', \vt)\\
    \typesatisfies(\tenv, \vte, \vt)\\
    \vletwo = \texttt{LE\_Slice}(\vleone, \vslices)\\
    \newle = \annotatelexpr{\vletwo, \vslices}
  }
  {
    \annotatelexpr{\tenv, \vle, \vte} = \newle
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LESetBadField \label{sec:TypingRule.LESetBadField}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:
   \begin{itemize}
   \item \texttt{le} denotes the access to the field named \texttt{field} in \texttt{le1};
   \item \texttt{t\_le1} is the type result of annotating the right-hand-side expression corresponding to \texttt{le1} in \texttt{env};
   \item \texttt{le2} is the result of annotating \texttt{le1} in \texttt{env};
   \item \texttt{t\_le1} does not have the structure of a record, or an exception or a bitvector type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LEConcat \label{sec:TypingRule.LEConcat}}

    \subsection{Prose}
   Annotating~\texttt{le} in an environment~\texttt{env}, assuming
\texttt{t\_e} to be the type of the corresponding right-hand-side
(\texttt{annotate\_lexpr version env le t\_e}), results in \texttt{new\_le} and
all of the following apply:

  \subsection{Example}


    \CodeSubsection{\LEConcatBegin}{\LEConcatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}

\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Slices \label{ch:typingslices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a slice~\texttt{slice} in an environment~\texttt{env}
(\texttt{annotate\_slice env slice}) results in the slicing of the pair \texttt{(offset,length)} and one of the following applies:
\begin{itemize}
\item TypingRule.SliceSingle (see Section~\ref{sec:TypingRule.SliceSingle}),
\item TypingRule.SliceLength (see Section~\ref{sec:TypingRule.SliceLength}),
\item TypingRule.SliceRange (see Section~\ref{sec:TypingRule.SliceRange}),
\item TypingRule.SliceStar (see Section~\ref{sec:TypingRule.SliceStar}).
\end{itemize}

\section{TypingRule.SliceSingle \label{sec:TypingRule.SliceSingle}}

  \subsection{Prose}
   Annotating a slice~\texttt{slice} in an environment~\texttt{env}
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset, length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives an index \texttt{i};
   \item \texttt{(offset, length)} is the result of applying TypingRule.SliceLength to \texttt{i, i+:1}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceSingleBegin}{\SliceSingleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXKG}: The notation \texttt{b[i]} is syntactic sugar for \texttt{b[i +: 1]}.

\section{TypingRule.SliceLength \label{sec:TypingRule.SliceLength}}

  \subsection{Prose}
   Annotating a slice~\texttt{slice} in an environment~\texttt{env}
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives \texttt{offset} and \texttt{length};
   \item \texttt{t\_offset, offset'} is the result of annotating \texttt{offset} in \texttt{env};
   \item \texttt{t\_length, length'} is the result of annotating \texttt{length} in \texttt{env};
   \item \texttt{t\_offset} has the structure of an integer type;
   \item \texttt{t\_length} has the structure of an integer type;
   \item \texttt{length} is statically evaluable.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceLengthBegin}{\SliceLengthEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\newcommand\eoffset[0]{\texttt{offset}}
\newcommand\elength[0]{\texttt{length}}
\newcommand\toffset[0]{\texttt{t\_offset}}
\newcommand\tlength[0]{\texttt{t\_length}}
\begin{mathpar}
\inferrule{
\annotateexpr{\tenv, \eoffset} = (\toffset, \eoffset')\\
\annotateexpr{\tenv, \elength} = (\tlength, \elength')\\
\tstruct(\tenv, \toffset) = \TInt(\Ignore)\\
\tstruct(\tenv, \tlength) = \TInt(\Ignore)\\
\isstaticallyevaluable(\tenv, \elength)
}
{
\annotateslices(\tenv, \texttt{Slice\_Length}(\eoffset, \elength)) = \texttt{Slice\_Length}(\eoffset, \elength')
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SliceRange \label{sec:TypingRule.SliceRange}}

  \subsection{Prose}
      Annotating a slice~\texttt{slice} in an environment~\texttt{env}
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives a range \texttt{(j, i)};
   \item \texttt{pre\_length} is \texttt{i +: j-i+1};
   \item \texttt{offset, length} is the result of applying the rule TypingRule.SliceLength to \texttt{i,pre\_length}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceRangeBegin}{\SliceRangeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXKG}: The notation \texttt{b[j:i]} is syntactic sugar for \texttt{b[i +: j-i+1]}.

\section{TypingRule.SliceStar \label{sec:TypingRule.SliceStar}}

  \subsection{Prose}
      Annotating a slice~\texttt{slice} in an environment~\texttt{env}
(\texttt{annotate\_slice env slice}) results in the pair \texttt{(offset,
length)} and all of the following apply:
   \begin{itemize}
   \item \texttt{slice} gives \texttt{(factor, pre\_length)};
   \item \texttt{pre\_offset} is \texttt{factor * pre\_length};
   \item \texttt{offset, length} is the result of applying the rule TypingRule.SliceLength to \texttt{(pre\_offset, pre\_length)}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SliceStarBegin}{\SliceStarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    \identr{GXQG}: The notation \texttt{b[i *: n]} is syntactic sugar for \texttt{b[i*n +: n]}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and one of the following applies:
\begin{itemize}
\item TypingRule.PAll (see Section~\ref{sec:TypingRule.PAll}),
\item TypingRule.PAny (see Section~\ref{sec:TypingRule.PAny}),
\item TypingRule.PGeq (see Section~\ref{sec:TypingRule.PGeq}),
\item TypingRule.PLeq (see Section~\ref{sec:TypingRule.PLeq}),
\item TypingRule.PNot (see Section~\ref{sec:TypingRule.PNot}),
\item TypingRule.PRange (see Section~\ref{sec:TypingRule.PRange}),
\item TypingRule.PSingle (see Section~\ref{sec:TypingRule.PSingle}),
\item TypingRule.PMask (see Section~\ref{sec:TypingRule.PMask}),
\item TypingRule.PTupleBadArity (see Section~\ref{sec:TypingRule.PTupleBadArity}),
\item TypingRule.PTuple (see Section~\ref{sec:TypingRule.PTuple}),
\item TypingRule.PTupleConflict (see Section~\ref{sec:TypingRule.PTupleConflict}),
\end{itemize}

\section{TypingRule.PAll \label{sec:TypingRule.PAll}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern matching everything;
   \item \texttt{new\_p} is \texttt{p}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PAllBegin}{\PAllEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PAny\label{sec:TypingRule.PAny}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything in a list \texttt{li};
   \item \texttt{new\_li} is the result of mapping the result of annotating \texttt{p} in \texttt{env} onto \texttt{li};
   \item \texttt{new\_p} is the pattern which matches anything in \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PAnyBegin}{\PAnyEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PGeq \label{sec:TypingRule.PGeq}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything greater than or equal to an expression \texttt{e};
   \item \texttt{t\_e, e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{e'} is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to \texttt{e'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything greater than or equal to \texttt{e'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PGeqBegin}{\PGeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

 \section{TypingRule.PLeq \label{sec:TypingRule.PLeq}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything lesser than or equal to an expression \texttt{e};
   \item \texttt{t\_e, e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{e'} is a compile-time constant expression;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to \texttt{e'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t} and \texttt{t\_e} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything lesser than or equal to \texttt{e'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PLeqBegin}{\PLeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PNot \label{sec:TypingRule.PNot}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches the negation of a pattern \texttt{q};
   \item \texttt{new\_q} is the result of annotating \texttt{q} in \texttt{env};
   \item \texttt{new\_p} is pattern which matches the negation of \texttt{new\_q}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PNotBegin}{\PNotEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PRange \label{sec:TypingRule.PRange}}

    \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches anything within the range given by
      expressions \texttt{e1} and \texttt{e2};
   \item \texttt{t\_e1, e1'} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t\_e2, e2'} is the result of annotating \texttt{e2} in \texttt{env};
   \item e1' and e2' are compile-time constant expressions;
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of an integer;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions \texttt{e1'} and \texttt{e2'}.
           \end{itemize}
     \item All of the following apply:
           \begin{itemize}
           \item both \texttt{t\_e1} and \texttt{t\_e2} have the structure of a real;
           \item \texttt{new\_p} is the pattern which matches anything within the range given by
      expressions \texttt{e1'} and \texttt{e2'}.
           \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PRangeBegin}{\PRangeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PSingle \label{sec:TypingRule.PSingle}}

    \subsection{Prose}
      Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
      \begin{itemize}
        \item \texttt{p} is the pattern that matches the expression \texttt{e};
        \item \texttt{t\_e, e'} is the result of annotating the expression \texttt{e} in \texttt{env};
        \item One of the following applies:
          \begin{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the real type;
                \item \texttt{t} has the structure of the real type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of the boolean type;
                \item \texttt{t} has the structure of the boolean type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an integer type;
                \item \texttt{t} has the structure of an integer type;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of a bitvector type;
                \item \texttt{t} has the structure of a bitvector type;
                \item the bitvector types \texttt{t\_e} and \texttt{t} have the same length;
              \end{itemize}
            \item All of the following apply:
              \begin{itemize}
                \item \texttt{t\_e} has the structure of an enumeration type;
                \item \texttt{t} has the structure of an enumeration type;
                \item the enumeration types \texttt{t\_e} and \texttt{t} have the same literals;
              \end{itemize}
          \end{itemize}
        \item \texttt{new\_p} is \texttt{p};
      \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PSingleBegin}{\PSingleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.PMask \label{sec:TypingRule.PMask}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a mask \texttt{m};
   \item \texttt{t} has the structure of a bitvector type;
   \item \texttt{n} is the length of mask \texttt{m};
   \item \texttt{t\_m} is the bitvector type of width \texttt{n};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_m};
       \item \texttt{new\_p} is \texttt{p}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PMaskBegin}{\PMaskEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This is related to \identi{VMKF}.

\section{TypingRule.PTupleBadArity \label{sec:TypingRule.PTupleBadArity}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of different size to the size of \texttt{li};
   \item an error ``\texttt{Bad Arity}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleBadArityBegin}{\PTupleBadArityEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTuple \label{sec:TypingRule.PTuple}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{ts} is a list of the same size as \texttt{li};
   \item \texttt{new\_li} is the result of annotating \texttt{li} with \texttt{ts};
   \item \texttt{new\_p} is the pattern which matches the tuple \texttt{new\_li}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleBegin}{\PTupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}


\section{TypingRule.PTupleConflict \label{sec:TypingRule.PTupleConflict}}

  \subsection{Prose}
   Annotating a pattern \texttt{t} in an environment~\texttt{env} given a type \texttt{t} (\texttt{annotate\_pattern}) results in a pattern \texttt{new\_p} and all of the following apply:
   \begin{itemize}
   \item \texttt{p} is the pattern which matches a tuple \texttt{li};
   \item \texttt{t} has the type structure of a tuple type \texttt{ts};
   \item \texttt{t\_struct} is not a tuple type;
   \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\PTupleConflictBegin}{\PTupleConflictEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Local Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type~\texttt{ty}, in an
environment~\texttt{env} (\annotatelocaldeclitem{\ldk, \ldi, \tty}) results in \texttt{new\_env, new\_ldi} and one of the following applies:
\begin{itemize}
\item TypingRule.LDDiscard (see Section~\ref{sec:TypingRule.LDDiscard}),
\item TypingRule.LDVar (see Section~\ref{sec:TypingRule.LDVar}),
\item TypingRule.LDTyped (see Section~\ref{sec:TypingRule.LDTyped}),
\item TypingRule.LDTuple (see Section~\ref{sec:TypingRule.LDTuple}).
\end{itemize}

This is related to \identr{YSPM}.

\section{TypingRule.LDDiscard \label{sec:TypingRule.LDDiscard}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} is a local declaration which can be discarded;
   \item \texttt{new\_env} is \texttt{env};
   \item \texttt{new\_ldi} is \texttt{ldi}.
   \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDDiscard.asl}


    \CodeSubsection{\LDDiscardBegin}{\LDDiscardEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \ldi = \texttt{LDI\_Discard}(\langle\rangle)\\
  }
  {\annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} = (\tenv, \ldi)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDVar \label{sec:TypingRule.LDVar}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
   \begin{itemize}
   \item \texttt{ldi} denotes a variable \texttt{x};
   \item \texttt{x} is not declared in \texttt{env};
   \item \texttt{new\_env} is \texttt{env} modified so that \texttt{x} is locally declared of type \texttt{ty};
   \item \texttt{new\_ldi} is the declaration of variable \texttt{x} with type \texttt{ty}.
   \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDVar.asl}


    \CodeSubsection{\LDVarBegin}{\LDVarEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \ldi = \texttt{LDI\_Var}(\vx)\\
    L^\tenv.\storagetypes(\vx) = \bot\\
    \newtenv = (G^\tenv, L^\tenv.\storagetypes[\vx \mapsto (\tty, \ldk)])
  }
  {
    \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} = (\newtenv, \texttt{LDI\_Var}(\vx))
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{YSPM}, \identd{FXST}.

\section{TypingRule.LDTyped\label{sec:TypingRule.LDTyped}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration
    keyword \texttt{ldk}, given a type~\texttt{ty}, in an
    environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
    the following apply:
    \begin{itemize}
      \item \texttt{ldi} denotes a local declaration item \texttt{ldi'} and a type \texttt{t};
      \item \texttt{t} can be initialized with \texttt{ty} in \texttt{env};
      \item \texttt{new\_env}, \texttt{new\_ldi'} is the result of the annotation of
        \texttt{ldi'} with the local declaration keyword \texttt{ldk}, given
        the type~\texttt{t}, in the environment~\texttt{env};
      \item \texttt{new\_ldi} is the local declaration denoting \texttt{new\_ldi'} and the type \texttt{t}.
    \end{itemize}

    \subsection{Example}
      \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTyped.asl}


      \CodeSubsection{\LDTypedBegin}{\LDTypedEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \ldi = \texttt{LDI\_Typed}(\ldi', \vt)\\
  \canbeinitializedwith(\tenv, \vt, \tty)\\
  \annotatelocaldeclitem{\tenv, \ldi', \ldk, \vt} = (\newtenv, \newldi')\\
  \newldi = \texttt{LDI\_Typed}(\newldi', \vt)\\
}
{
  \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} = (\newtenv, \newldi)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.LDTuple\label{sec:TypingRule.LDTuple}}

  \subsection{Prose}
    Annotating a local declaration~\texttt{ldi} with a local declaration keyword \texttt{ldk}, given a type~\texttt{ty}, in
an environment~\texttt{env} results in \texttt{new\_env, new\_ldi} and all of
the following apply:
  \begin{itemize}
  \item \texttt{ldi} denotes a list \texttt{ldis};
  \item \texttt{ty} has the structure of a tuple type of the same length as~\texttt{ldis};
  \item \texttt{new\_env} is \texttt{env} modified so that each element in \texttt{ldis} is annotated with the corresponding type in \texttt{ty};
  \item \texttt{new\_ldi} is \texttt{ldis} where each element is declared with
the corresponding type in ~\texttt{ty}.
  \end{itemize}

  \subsection{Example}
    \VerbatimInput{../tests/ASLTypingReference.t/TypingRule.LDTuple.asl}


    \CodeSubsection{\LDTupleBegin}{\LDTupleEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \ldi = \texttt{LDI\_Tuple}(\ldis, \langle\rangle)\\
  \ldis = [\ldi_{1..k}]\\
  \tstruct(\tenv, \tty) = \TTuple([\vt_{1..k}])\\
  \newtenv_0 = \tenv\\
  \annotatelocaldeclitem{\newtenv_0, \ldi_1, \ldk, \vt_1} = (\newtenv_1, \ldi_1)\\
  \ldots\\
  \annotatelocaldeclitem{\newtenv_{k-1}, \ldi_{k-1}, \ldk, \vt_{k-1}} = (\newtenv_k, \ldi_k)\\
  \newtenv = \newtenv_k\\
  \newldi = [\ldi_{1..k}]
}
{
  \annotatelocaldeclitem{\tenv, \ldi, \ldk, \tty} = (\newtenv, \texttt{LDI\_Tuple}(\newldi, \langle\rangle))
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and one of the following applies:
\begin{itemize}
\item TypingRule.SPass (see Section~\ref{sec:TypingRule.SPass}),
\item TypingRule.SAssign (see Section~\ref{sec:TypingRule.SAssign}),
\item TypingRule.SReturnNone (see Section~\ref{sec:TypingRule.SReturnNone}),
\item TypingRule.SReturnOne (see Section~\ref{sec:TypingRule.SReturnOne}),
\item TypingRule.SReturnSome (see Section~\ref{sec:TypingRule.SReturnSome}),
\item TypingRule.SSeq (see Section~\ref{sec:TypingRule.SSeq}),
\item TypingRule.SCall (see Section~\ref{sec:TypingRule.SCall}),
\item TypingRule.SCond (see Section~\ref{sec:TypingRule.SCond}),
\item TypingRule.SCase (see Section~\ref{sec:TypingRule.SCase}),
\item TypingRule.SAssert (see Section~\ref{sec:TypingRule.SAssert}),
\item TypingRule.SWhile (see Section~\ref{sec:TypingRule.SWhile}),
\item TypingRule.SRepeat (see Section~\ref{sec:TypingRule.SRepeat}),
\item TypingRule.SFor (see Section~\ref{sec:TypingRule.SFor}),
\item TypingRule.SThrowNone (see Section~\ref{sec:TypingRule.SThrowNone}),
\item TypingRule.SThrowSome (see Section~\ref{sec:TypingRule.SThrowSome}),
\item TypingRule.STry (see Section~\ref{sec:TypingRule.STry}).
\item TypingRule.SDeclSome (see Section~\ref{sec:TypingRule.SDeclSome}),
\item TypingRule.SDeclNone (see Section~\ref{sec:TypingRule.SDeclNone}),
\end{itemize}

\section{TypingRule.SPass \label{sec:TypingRule.SPass}}

    \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a pass statement;
    \item \texttt{new\_s} is \texttt{s};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example}


    \CodeSubsection{\SPassBegin}{\SPassEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{}{\annotatestmt{\tenv, \SPass} \typearrow (\SPass,\tenv)}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SAssign \label{sec:TypingRule.SAssign}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is an assignment \texttt{le = re} under language version \texttt{ver};
   \item \texttt{t\_e, e1} is the result of annotating \texttt{re} in \texttt{env};
   \item \texttt{reduced} is the result of inlining a setter call in \texttt{le};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} gives a statement \texttt{s};
       \item \texttt{new\_s} is \texttt{s};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}

     \item All of the following apply:
       \begin{itemize}
       \item \texttt{reduced} does not give a statement \texttt{s};
       \item One of the following applies:
         \begin{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv1;
           \item \texttt{env1} is \texttt{env};
           \end{itemize}
         \item All of the following apply:
           \begin{itemize}
           \item \texttt{ver} is ASLv0;
	   \item \texttt{env1} is the result of annotating undeclared variables by using
	      the first assignments to such variables as declarations;
           \end{itemize}
         \end{itemize}

       \item \texttt{le1} is the result of annotating \texttt{le} with \texttt{t\_e} in \texttt{env1};
       \item \texttt{new\_s} is the assignment \texttt{le1 = e1};
       \item \texttt{new\_env} is \texttt{env1}.
       \end{itemize}
    \end{itemize}
  \end{itemize}

  \subsection{Example}


  \CodeSubsection{\SAssignBegin}{\SAssignEnd}{../Typing.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Assign}(\vle, \vre)\\
    \annotateexpr{\tenv, \vre} = (\vte, \veone)\\
    \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \vs \rangle\\
    \news = \vs\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news,\newtenv)
  }
\and
\inferrule{
  \vs = \texttt{S\_Assign}(\vle, \vre)\\
  \annotateexpr{\tenv, \vre} = (\vte, \veone)\\
  \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \rangle\\
  \version = \texttt{ASLv1}\\
  \tenvone = \tenv\\
  \annotatelexpr{\tenv, \vle, \vte} = \vleone\\
  \news = \texttt{S\_Assign}(\vleone, \veone)
  \newtenv = \tenvone
}
{
  \annotatestmt{\tenv, \vs} = (\news,\newtenv)
}
\and
\inferrule{
  \vs = \texttt{S\_Assign}(\vle, \vre)\\
  \annotateexpr{\tenv, \vre} = (\vte, \veone)\\
  \inlinesetter{\tenv, \vle, \veone} = \reduced = \langle \rangle\\
  \version = \texttt{ASLv0}\\
  \tenvone = \tenv'\\
  \annotatelexpr{\tenv, \vle, \vte} = \vleone\\
  \news = \texttt{S\_Assign}(\vleone, \veone)
  \newtenv = \tenvone
}
{
  \annotatestmt{\tenv, \vs} = (\news,\newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SReturnNone \label{sec:TypingRule.SReturnNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{return} statement with no value and no return type;
   \item \texttt{new\_s} is a \texttt{return} statement with no value;
   \item the enclosing subprogram does not have a \texttt{return} type (it is either a setter
      or a procedure);
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnNoneBegin}{\SReturnNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs = \texttt{S\_Return}(\langle\rangle)\\
  L^\tenv.\returntype = \langle\rangle\\
  \newtenv = \tenv
}
{\annotatestmt{\tenv, \vs} = (\texttt{S\_Return}(\langle\rangle), \newtenv)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTPK}.


\section{TypingRule.SReturnOne \label{sec:TypingRule.SReturnOne}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{s} is a \texttt{return} statement with some value;
       \item the enclosing subprogram does not have a return type;
       \end{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{s} is a \texttt{return} statement with no value;
       \item the enclosing subprogram has a \texttt{return} type;
       \end{itemize}
     \end{itemize}
   \item an error ``\texttt{Bad Return Statement}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnOneBegin}{\SReturnOneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTPK}.

\section{TypingRule.SReturnSome \label{sec:TypingRule.SReturnSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{return} statement with some value \texttt{e};
   \item the enclosing subprogram has a return type \texttt{t};
   \item \texttt{t\_e',e'} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_e'} type-satisfies \texttt{t};
       \item \texttt{new\_s} is a \texttt{return} statement with value \texttt{e'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SReturnSomeBegin}{\SReturnSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Return}(\langle \ve \rangle)\\
    L^\tenv.\returntype = \langle \vt \rangle\\
    \annotateexpr{\tenv, \ve} = (\vte', \ve')\\
    \typesatisfies(\tenv, \vte', \vt)\\
    \news = \texttt{S\_Return}(\langle \ve' \rangle)\\
    \newtenv = \tenv
  }
  {\annotatestmt{\tenv, \vs} = (\news, \newtenv)}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identr{FTPK}.

\section{TypingRule.SSeq \label{sec:TypingRule.SSeq}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a statement \texttt{s1; s2};
   \item \texttt{new\_s1, env1} is the result of annotating \texttt{s1} in \texttt{env};
   \item \texttt{new\_s2, env2} is the result of annotating \texttt{s2} in \texttt{env1};
   \item \texttt{new\_s} is a then statement over two statements \texttt{new\_s1} and \texttt{new\_s2};
   \item \texttt{new\_env} is \texttt{env2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SSeqBegin}{\SSeqEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
\inferrule{
  \vs = \SSeq(\vsone, \vstwo)\\
  \annotatestmt{\tenv, \vs1} \typearrow (\newsone, \tenvone)\\
  \annotatestmt{\tenvone, \vs2} \typearrow (\newstwo, \tenvtwo)\\
  \news = \SSeq(\newsone, \newstwo)\\
  \newtenv = \tenvtwo
}
{
  \annotatestmt{\tenv, \vs} \typearrow (\news, \newtenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.SCall \label{sec:TypingRule.SCall}}

    \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a call to a subprogram named \texttt{name} with arguments \texttt{args} and parameters \texttt{eqs};
   \item \texttt{new\_name, new\_args, new\_eqs} is the result of annotating the call
      to the procedure \texttt{name} with arguments \texttt{args} and parameters
\texttt{eqs};
   \item \texttt{new\_s} is the call to a subprogram named \texttt{new\_name} with arguments
      \texttt{new\_args} and parameters \texttt{new\_eqs};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCallBegin}{\SCallEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Call}(\name, \vargs, \eqs)\\
    \annotatecall{\tenv, \name, \vargs, \eqs} = (\newname, \newargs, \neweqs)\\
    \news = \texttt{S\_Call}(\newname, \newargs, \neweqs)
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \tenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identd{VXKM}.

\section{TypingRule.SCond \label{sec:TypingRule.SCond}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a condition \texttt{e} with two statements \texttt{s1} and \texttt{s2};
   \item \texttt{t\_cond, e\_cond} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_cond} type-satisfies \texttt{t\_bool};
       \item \texttt{s1'} is the result of annotating \texttt{s1} in \texttt{env};
       \item \texttt{s2'} is the result of annotating \texttt{s2} in \texttt{env};
       \item \texttt{new\_s} is the condition \texttt{e\_cond} with two statements \texttt{s1'} and \texttt{s2'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCondBegin}{\SCondEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Cond}(\ve, \vsone, \vstwo)\\
    \annotateexpr{\tenv, \ve} = (\tcond, \econd)\\
    \typesatisfies(\tenv, \tcond, \TBool)\\
    \annotatestmt{\tenv, \vsone} = (\vsone', \Ignore)\\
    \annotatestmt{\tenv, \vstwo} = (\vstwo', \Ignore)\\
    \news = \texttt{S\_Cond}(\econd, \vsone', \vstwo')\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{NBDJ}.

\section{TypingRule.SCase \label{sec:TypingRule.SCase}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a case statement with expression \texttt{e} and cases \texttt{cases};
   \item \texttt{t\_e, e1} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{cases1, env1} is the result of annotating each case in \texttt{cases} given \texttt{t\_e};
   \item \texttt{new\_s} is a case statement with expression \texttt{e1} and cases \texttt{cases1};
   \item \texttt{new\_env} is \texttt{env1}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SCaseBegin}{\SCaseEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{WGSY}.

\section{TypingRule.SAssert \label{sec:TypingRule.SAssert}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is an assert statement with expression \texttt{e};
   \item \texttt{t\_e',e'} is the result of annotating \texttt{e} in \texttt{env};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t\_e'} type-satisfies \texttt{t\_bool};
       \item \texttt{new\_s} is an assert statement with expression \texttt{e'};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SAssertBegin}{\SAssertEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Assert}(\ve)\\
    \annotateexpr{\tenv, \ve} = (\vte', \ve')\\
    \typesatisfies(\tenv, \vte', \TBool)\\
    \news = \texttt{S\_Assert}(\ve')\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{JQYF}.


\section{TypingRule.SWhile \label{sec:TypingRule.SWhile}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{while} statement with expression \texttt{e1} and statement block \texttt{s1};
   \item \texttt{t, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item One of the following applies:
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_bool};
       \item \texttt{s2} is the result of annotating \texttt{s1} in \texttt{env};
       \item \texttt{new\_s} is a \texttt{while} statement with expression \texttt{e2} and statement block \texttt{s2};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SWhileBegin}{\SWhileEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_While}(\veone, \vsone)\\
    \annotateexpr{\tenv, \veone} = (\vt, \vetwo)\\
    \typesatisfies(\tenv, \vte, \TBool)\\
    \annotateblock{\tenv, \vsone} = \vstwo\\
    \news = \texttt{S\_While}(\vetwo, \vstwo)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTVN}.

\section{TypingRule.SRepeat \label{sec:TypingRule.SRepeat}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{repeat} statement with expression \texttt{e1} and statement block \texttt{s1};
   \item \texttt{s2} is the result of annotating \texttt{s1} in \texttt{env};
   \item \texttt{t, e2} is the result of annotating \texttt{e1} in \texttt{env};
   \item One of the following applies:
     \begin{itemize}
     \item All of the following apply:
       \begin{itemize}
       \item \texttt{t} type-satisfies \texttt{t\_bool};
       \item \texttt{new\_s} is a \texttt{repeat} statement with expression \texttt{e2} and statement block \texttt{s2};
       \item \texttt{new\_env} is \texttt{env}.
       \end{itemize}
     \item an error ``\texttt{Conflicting Types}'' is raised.
     \end{itemize}
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SRepeatBegin}{\SRepeatEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Repeat}(\veone, \vsone)\\
    \annotateexpr{\tenv, \veone} = (\vt, \vetwo)\\
    \typesatisfies(\tenv, \vte, \TBool)\\
    \annotateblock{\tenv, \vsone} = \vstwo\\
    \news = \texttt{S\_Repeat}(\vetwo, \vstwo)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{FTVN}.

\section{TypingRule.SFor \label{sec:TypingRule.SFor}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a \texttt{for} statement with index \texttt{id}, direction \texttt{dir}, two expressions
      \texttt{e1} and \texttt{e2} and a statement block \texttt{s'};
   \item \texttt{t1,e1'} is the result of annotating \texttt{e1} in \texttt{env};
   \item \texttt{t2,e2'} is the result of annotating \texttt{e2} in \texttt{env};
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t1 was provided}'' or \texttt{t1} has the structure of an integer type and all of the following apply:
   \item an error is raised: ``\texttt{ASL Typing Error : A subtype of integer was expected, t2 was provided}'' or \texttt{t2} has the structure of an integer type and all of the following apply:
   \item One of the following applies:
     \begin{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item \texttt{t1} has the structure of an unconstrained integer type;
           \item \texttt{ty} is the unconstrained integer type;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item \texttt{t2} has the structure of an unconstrained integer type;
           \item \texttt{ty} is the unconstrained integer type;
         \end{itemize}
       \item All of the following apply:
         \begin{itemize}
           \item \texttt{t1} has the structure of a constrained integer type with constraint \texttt{cs1};
           \item \texttt{t2} has the structure of a constrained integer type with constraint \texttt{cs2};
           \item One of the following applies:
             \begin{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{to};
                   \item \texttt{bot\_cs} is \texttt{cs1};
                   \item \texttt{top\_cs} is \texttt{cs2};
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{dir} is \texttt{down to};
                   \item \texttt{bot\_cs} is \texttt{cs2};
                   \item \texttt{top\_cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item One of the following applies:
             \begin{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{top\_cs} contains a an expression that is not evaluable at compile-time;
                   \item \texttt{cs} is the empty constraint;
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{bot} is less or equal than \texttt{top};
                   \item \texttt{cs} is the constraint \texttt{bot .. top};
                 \end{itemize}
               \item All of the following apply:
                 \begin{itemize}
                   \item \texttt{bot} is the minimum of the constraints \texttt{bot\_cs};
                   \item \texttt{top} is the maximum of the constraints \texttt{top\_cs};
                   \item \texttt{top} is strictly less than \texttt{bot}
                   \item \texttt{cs} is \texttt{cs1};
                 \end{itemize}
             \end{itemize}
           \item \texttt{ty} is the constrained integer type with constraint \texttt{cs};
         \end{itemize}
     \end{itemize}
   \item an error is raised ``\texttt{ASL Typing Error: cannot declare already \\ declared element "id".}'' or \texttt{id} is not bound in \texttt{env} and all of the following apply:
   \item \texttt{env'} is \texttt{env} modified so that \texttt{id} is locally declared of type \texttt{ty};
   \item \texttt{s''} is the result of annotating \texttt{s'} in \texttt{env'};
   \item \texttt{new\_s} is a for statement with index \texttt{id}, direction \texttt{dir}, two expressions \texttt{e1'} and \texttt{e2'} and statement \texttt{s''};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SForBegin}{\SForEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
% \[
%   \inferrule{
%     \annotateexpr{\tenv, \veone} = (\vtone, \veone')\\
%     \annotateexpr{\tenv, \vetwo} = (\vttwo, \vetwo')\\
%     \tstruct(\tenv, \vtone) = \TInt(\Ignore)\\
%     \tstruct(\tenv, \vttwo) = \TInt(\Ignore)\\
%     \news = \texttt{S\_For}(..., ...)\\
%     \newtenv = \tenv
%   }
%   {
%     \annotatestmt{\tenv, \texttt{S\_For}(\id, \dir, \veone, \vetwo, \vs')} = (\news, \newtenv)
%   }
% \]
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{VTJW}.


\section{TypingRule.SThrowNone \label{sec:TypingRule.SThrowNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a throw statement with no expression;
   \item \texttt{new\_s} is \texttt{s};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SThrowNoneBegin}{\SThrowNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Throw}(\langle\rangle)\\
    \news = \vs\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  Note that \identr{BRCJ} is done in~\cite[SemanticsRule.TopLevel]{ASLSemanticsReference}.

\section{TypingRule.SThrowSome \label{sec:TypingRule.SThrowSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a throw statement with expression \texttt{e};
   \item \texttt{t\_e,e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{t\_e} has the structure of an exception type;
   \item \texttt{new\_s} is a throw statement with expression \texttt{e'} and type \texttt{t\_e};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SThrowSomeBegin}{\SThrowSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Throw}(\langle (\ve, \Ignore) \rangle)\\
    \annotateexpr{\tenv, \ve} = (\vte, \ve')\\
    \astlabel(\tstruct(\tenv, \vte)) = \TException\\
    \news = \texttt{S\_Throw}(\langle (\ve', \langle\vte\rangle) \rangle)\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{NXRC}.


\section{TypingRule.STry \label{sec:TypingRule.STry}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a try statement with statement \texttt{s'}, catchers \texttt{catchers} and block \texttt{otherwise};
   \item \texttt{s''} is the result of annotating \texttt{s'} in \texttt{env};
   \item \texttt{otherwise'} is the result of annotating \texttt{otherwise} in \texttt{env};
   \item \texttt{catchers'} is the result of annotating \texttt{catchers} in \texttt{env};
   \item \texttt{new\_s} is a try statement with statement \texttt{s''}, catchers \texttt{catchers'} and block \texttt{otherwise'};
   \item \texttt{new\_env} is \texttt{env}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\STryBegin}{\STryEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Try}(\vs', \catchers, \otherwise)\\
    \annotatestmt{\tenv, \vs'} = \vs''\\
    \catchers = [\annotatecatcher{\tenv, \vc} \;|\; \vc \in \catchers]\\
    \otherwise = \langle \annotateblock{\tenv, \vo} \;|\; \vo \in \otherwise\rangle\\
    \news = \texttt{S\_Try}(\vs'', \catchers', \otherwise')\\
    \newtenv = \tenv
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{WVXS}.

\section{TypingRule.SDeclSome \label{sec:TypingRule.SDeclSome}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a declaration with local identifiers \texttt{ldi} and an expression \texttt{e};
   \item \texttt{t\_e,e'} is the result of annotating \texttt{e} in \texttt{env};
   \item \texttt{env', ldi'} is the result of declaring the local identifiers of \texttt{ldi} in \texttt{env};
   \item \texttt{new\_s} is a declaration with \texttt{ldk}, \texttt{ldi'} and an expression \texttt{e'};
   \item \texttt{new\_env} is \texttt{env'}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SDeclSomeBegin}{\SDeclSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Decl}(\texttt{LDK\_Constant}, \ldi, \langle\ve\rangle)\\
    \annotateexpr{\tenv, \ve} = (\vte, \ve')\\
    \vv = \reduceconstants{\tenv, \ve}\\
    \declarelocalconstant{\tenv, \ldi} = (\tenv', \vte, \vv, \ldi')\\
    \news = \texttt{S\_Decl}(\texttt{LDK\_Constant}, \ldi', \langle\ve'\rangle)\\
    \newtenv = \tenv'
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}
This is related to \identr{YSPM}.

\section{TypingRule.SDeclNone \label{sec:TypingRule.SDeclNone}}

  \subsection{Prose}
Annotating statement~\texttt{s} in an environment~\texttt{env}
(\texttt{annotate\_stmt env s}) results in a statement \texttt{new\_s} and an
environment \texttt{new\_env} and all of the following apply:
   \begin{itemize}
   \item \texttt{s} is a declaration statement with local identifiers \texttt{ldi} and no initial expression;
   \item \texttt{env', s'} is the result of annotating uninitialised local declarations \texttt{ldi} in \texttt{env};
   \item \texttt{new\_s} is \texttt{s'};
   \item \texttt{new\_env} is \texttt{env'}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SDeclNoneBegin}{\SDeclNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vs = \texttt{S\_Decl}(\texttt{LDK\_Constant}, \ldi, \langle\rangle)\\
    \annotatelocaldeclitemuninit{\tenv, \ldi} = (\tenv', \vs')\\
    \news = \vs'\\
    \newtenv = \tenv'
  }
  {
    \annotatestmt{\tenv, \vs} = (\news, \newtenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Blocks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TypingRule.Block \label{sec:TypingRule.Block}}

  \subsection{Prose}
    Annotating a block \texttt{s} in an environment \texttt{env}, given a type
\texttt{return\_type} \\ (\texttt{annotate\_block env return\_type s}), is the
result of annotating the statement \texttt{s} in \texttt{env}.

  \subsection{Example: TypingRule.Block0.asl}
\VerbatimInput{../tests/ASLTypingReference.t/TypingRule.Block0.asl}


    \CodeSubsection{\BlockBegin}{\BlockEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \annotatestmt{\tenv, \vs} = (\vs', \Ignore)
  }
  {
    \annotateblock{\tenv, \vs, \texttt{return\_type}} = \vs'
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    A local identifier declared with var, let or constant is in scope
from the point immediately after its declaration until the end of the
immediately enclosing block.

    From that follows that we can discard the environment at the end of
an enclosing block.

    This is related to \identr{JBXQ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Catchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating catchers \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and one of the following applies:
\begin{itemize}
\item TypingRule.CatcherNone (see Section~\ref{sec:TypingRule.CatcherNone}),
\item TypingRule.CatcherSome (see Section~\ref{sec:TypingRule.CatcherSome}).
\end{itemize}

\section{TypingRule.CatcherNone \label{sec:TypingRule.CatcherNone}}

  \subsection{Prose}
   Annotating catcher \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env
return\_type (name\_opt, ty, stmt)}) results in \texttt{(name\_opt, ty,
new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item \texttt{ty} has the structure of an exception type;
   \item \texttt{name\_opt} gives no name;
   \item \texttt{env'} is \texttt{env};
   \item \texttt{new\_stmt} is the result of annotating \texttt{stmt} in \texttt{env'} with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\CatcherNoneBegin}{\CatcherNoneEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \astlabel(\tstruct(\tty)) = \TException\\
    \texttt{name\_opt} = \langle\rangle\\
    \tenv' = \tenv\\
    \texttt{new\_stmt'} = \annotateblock{\tenv', \texttt{stmt}}
  }
  {
    \annotatecatcher{\tenv, \texttt{name\_opt}, \tty, \texttt{stmt}} = (\texttt{name\_opt}, \tty, \texttt{new\_stmt'})
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{SDJK}.

\section{TypingRule.CatcherSome \label{sec:TypingRule.CatcherSome}}

  \subsection{Prose}
   Annotating catcher \texttt{(name\_opt, ty, stmt)} in an environment
\texttt{env} given a type \texttt{return\_type} (\texttt{annotate\_catchers env return\_type (name\_opt, ty, stmt)})
results in \texttt{(name\_opt, ty, new\_stmt)} and all of the following apply:
   \begin{itemize}
   \item \texttt{ty} has the structure of an exception type;
   \item \texttt{name\_opt} gives a name \texttt{name};
   \item \texttt{name} is not already declared in \texttt{env};
   \item \texttt{name} has type \texttt{ty} in \texttt{env}; \todocomment{ROMAN: doesn't appear in the code}
   \item \texttt{env'} is \texttt{env} modified to have \texttt{name} locally declared as immutable of type \texttt{ty};
   \item \texttt{new\_stmt} is the result of annotating \texttt{stmt} in \texttt{env'} with \texttt{return\_type}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\CatcherSomeBegin}{\CatcherSomeEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    L^\tenv.\storagetypes(\id) = G^\tenv.\storagetypes(\id) = G^\tenv.\subprograms(\id) = \bot
  }
  {
    \checkvarnotinenv{\tenv, \id}
  }
  \and
  \inferrule{
    \astlabel(\tstruct(\tty)) = \TException\\
    \texttt{name\_opt} = \langle\name\rangle\\
    \checkvarnotinenv{\tenv, \name}\\
    \tenv' = (G^\tenv, L^\tenv.\storagetypes[\name \mapsto (\tty, \texttt{LDK\_Let})])\\
    \texttt{new\_stmt'} = \annotateblock{\tenv', \texttt{stmt}}
  }
  {
    \annotatecatcher{\tenv, \texttt{name\_opt}, \tty, \texttt{stmt}} = (\texttt{name\_opt}, \tty, \texttt{new\_stmt'})
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
    This is related to \identr{SDJK}, \identr{WVXS}, \identi{FCGK}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprogram Calls \label{ch:TypingSubprogramCalls}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
parameters \texttt{eqs}, and call type \texttt{call\_type} (\texttt{annotate\_call}) results in \texttt{(name1,
args, eqs2, ret\_ty1)} or an error is raised and one of the following applies:
\begin{itemize}
\item TypingRule.FCallBadArity (see Section~\ref{sec:TypingRule.FCallBadArity}),
\item TypingRule.FCallGetter (see Section~\ref{sec:TypingRule.FCallGetter}),
\item TypingRule.FCallSetter (see Section~\ref{sec:TypingRule.FCallSetter}),
\item TypingRule.FCallMismatch (see Section~\ref{sec:TypingRule.FCallMismatch}).
\end{itemize}

\section{TypingRule.FCallBadArity \label{sec:TypingRule.FCallBadArity}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args}
and parameters \texttt{eqs} (\texttt{annotate\_call}) results in
\texttt{(name1, args, eqs2, ret\_ty1)} or an error is raised and all of the
following apply:
   \begin{itemize}
   \item \texttt{name} is bound in \texttt{env} to a function with argument types \texttt{callee\_arg\_types};
   \item the lists \texttt{callee\_arg\_types} and \texttt{args} do not have the same length;
   \item an error ``\texttt{Bad Arity}'' is raised.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\FCallBadArityBegin}{\FCallBadArityEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{TypingRule.FCallGetter \label{sec:TypingRule.FCallGetter}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
  parameters \texttt{eqs}, and call-type \texttt{call\_type}
  (\texttt{annotate\_call}) results in \texttt{(name1, args, eqs2, ret\_ty1)}
  or an error is raised and all of the following apply:
   \begin{itemize}
   \item \texttt{caller\_arg\_types, arg1} is the result of annotating \texttt{args} in \texttt{env};
   \item \texttt{name} is bound in \texttt{env} to a subprogram with argument types
      \\ \texttt{callee\_arg\_types};
   \item \texttt{eqs2} is \texttt{eqs1} appended with the equations deduced by
     using the types of the actual arguments \texttt{caller\_arg\_types} to
     defined parameters in \\ \texttt{callee\_arg\_types};
   \item \texttt{call\_type} is either a function or a getter type;
   \item \texttt{ret\_ty1} is the result of renaming \texttt{ty} in \texttt{eqs2}.
   \end{itemize}

  \subsection{Example}


    \CodeSubsection{\FCallGetterBegin}{\FCallGetterEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This is related to \identi{VFDP}, \identd{TRFW}, \identr{KMDB},
  \identi{YMHX}, \identr{CCVD}, \identr{QYBH}, \identr{PFWQ}, \identr{ZLWD},
  \identi{FLKF}, \identd{PMBL}, \identr{MWBN}, \identr{TZSP}, \identr{SBWR},
  \identi{CMLP}, \identr{BQJG}, \identr{RTCF}.


\section{TypingRule.FCallSetter \label{sec:TypingRule.FCallSetter}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with arguments \texttt{args},
  parameters \texttt{eqs}, and call-type \texttt{call\_type}
  (\texttt{annotate\_call}) results in \texttt{(name1, args, eqs2, ret\_ty1)}
  or an error is raised and all of the following apply:
  \begin{itemize}
    \item \texttt{caller\_arg\_types, arg1} is the result of annotating
      \texttt{args} in \texttt{env};
    \item \texttt{name} is bound in \texttt{env} to a subprogram with a unique
      name \texttt{name1} whose argument types \texttt{callee\_arg\_types}
      type-clash \texttt{caller\_arg\_types} and whose return type is
      \texttt{ret\_ty};
    \item \texttt{eqs1} is the list made of both \texttt{eqs} and
      \texttt{extra\_nargs};
    \item \texttt{eqs2} is \texttt{eqs1} appended with the equations deduced by
      using the types of the actual arguments \texttt{caller\_arg\_types} to
      defined parameters in \\ \texttt{callee\_arg\_types};
    \item \texttt{call\_type} is a setter or procedure type;
    \item \texttt{ret\_ty} is None;
    \item \texttt{ret\_ty1} is None.
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\FCallSetterBegin}{\FCallSetterEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\end{emptyformal}

\subsection{Comments}
  This is related to \identi{VFDP}, \identd{TRFW}, \identr{KMDB},
  \identi{YMHX}, \identr{CCVD}, \identr{QYBH}, \identr{PFWQ}, \identr{ZLWD},
  \identi{FLKF}, \identd{PMBL}, \identr{MWBN}, \identr{TZSP}, \identr{SBWR},
  \identi{CMLP}, \identr{RTCF}.

\section{TypingRule.FCallMismatch \label{sec:TypingRule.FCallMismatch}}

  \subsection{Prose}
  Annotating the call to subprogram \texttt{name} with call type \texttt{call\_type} \\ (\texttt{annotate\_call}) results in an error and
  one of the following apply:
  \begin{itemize}
    \item All of the following apply: \begin{itemize} \item \texttt{call\_type}
          is a function or a getter;
        \item \texttt{name} is bound in \texttt{env} a subprogram without a return-type;
        \item A ``Mismatched return value'' error is raised.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
        \item \texttt{call\_type} is a procedure or a setter;
        \item \texttt{name} is bound in \texttt{env} a subprogram with a return type;
        \item A ``Mismatched return value'' error is raised.
      \end{itemize}
  \end{itemize}

  \subsection{Example}


    \CodeSubsection{\FCallMismatchBegin}{\FCallMismatchEnd}{../Typing.ml}

  \subsection{Formally}

  \subsection{Comments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Subprograms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Annotating a subprogram \texttt{f} in an environment \texttt{env}
(\texttt{annotate\_subprogram}) results in \texttt{f'}.

\section{TypingRule.Subprogram \label{sec:TypingRule.Subprogram}}

  \subsection{Prose}
Annotating a subprogram \texttt{f} in an environment \texttt{env}
(\texttt{annotate\_subprogram}) results in \texttt{f}, \texttt{new\_body} and all of
the following apply:
 \begin{itemize}
   \item \texttt{env1} is \texttt{env} modified to have an empty local
     environment and a return type given by \texttt{f};
   \item \texttt{env2} is \texttt{env1} with every formal argument given by
     \texttt{f} declared as immutable with its type;
   \item \texttt{env3} is \texttt{env2} modified to add explicit parameters
     given by \texttt{f};
   \item \texttt{env4} is \texttt{env3} modified to resolve dependently typed
     identifiers in the arguments given by \texttt{f};
   \item \texttt{env5} is \texttt{env4} modified to resolve dependently typed
     identifiers in the result type given by \texttt{f};
   \item \texttt{body} is the body given by \texttt{f};
   \item \texttt{new\_body} is the result of annotating \texttt{body} in
     \texttt{env5}.
   \item \texttt{f'} is the function \texttt{f} with \texttt{new\_body} substituted for \texttt{body}.
 \end{itemize}
 \end{itemize}

  \subsection{Example}


    \CodeSubsection{\SubprogramBegin}{\SubprogramEnd}{../Typing.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{}{ \texttt{param\_type}(\langle\rangle) = \isunconstrainedinteger }
  \and
  \inferrule{}{ \texttt{param\_type}(\langle\tty\rangle) = \tty }
  \and
  \inferrule{
    \texttt{env1} = (G^\tenv, [\constantvalues \mapsto \lambda \id.\ \bot, \storagetypes \mapsto \lambda \id.\ \bot, \returntype = \vf.\returntype])\\
    \vf.\text{args} = [i=1..k: (\va_i, \tty_i)]\\
    i=1..k: \checkvarnotinenv{\texttt{env1}, \va_i}\\
    \texttt{env2} = (G^\texttt{env1}, \texttt{env1}[\storagetypes \mapsto [i=1..k: \va_i \mapsto (\texttt{LDK\_Let}, \tty_i)] )]\\
    \vf.\text{parameters} = [j=1..n: (\vp_j, \tyopt_j)]\\
    j=1..k: \checkvarnotinenv{\texttt{env2}, \vp_j}\\
    \texttt{env3} = (G^\texttt{env2}, \texttt{env2}[\storagetypes \mapsto [j=1..n: \vp_i \mapsto (\texttt{LDK\_Let}, \texttt{param\_type}(\tyopt_j))] )]\\
    \texttt{env4} = \texttt{add\_dependently\_typed}(\texttt{env3}, \vf.\text{args})\\
    \texttt{env5} = \texttt{resolve\_dependently\_typed\_in\_res}(\texttt{env4}, \vf.\text{return\_type})\\
    \vf.\text{return\_type} = \texttt{SB\_ASL} \vs\\
    \texttt{new\_body} = \annotateblock{\texttt{env4}, \vs}\\
    (\Ignore, \name, \Ignore, \Ignore) \in G^\texttt{env5}.\subprogramrenamings(\vf.\name, [i=1..k: \tty_i])\\
    \vf' = \vf[\text{body}\mapsto \texttt{new\_body}]
  }
  {
    \annotatesubprogram{\tenv, \vf} = \vf'
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
This is related to \identi{GHGK}, \identr{HWTV}, \identr{SCHV}, \identr{VDPC},
\identr{TJKQ}, \identi{LFJZ}, \identi{BZVB}, \identi{RQQB}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Global Declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Declaring a global declaration \texttt{d} in an environment \texttt{env} ($\declaredecl{\tenv, \texttt{d}}$)
results in a new environment \texttt{env'}, which contains the declared element, and one of the following applies:
\begin{itemize}
  \item TypingRule.DeclareOneFunc (see Section~\ref{sec:TypingRule.DeclareOneFunc}).
  \item TypingRule.DeclareGlobalStorage (see Section~\ref{sec:TypingRule.DeclareGlobalStorage}).
  \item TypingRule.DeclareType (see Section~\ref{sec:TypingRule.DeclareType}).
\end{itemize}

\section{TypingRule.DeclareOneFunc \label{sec:TypingRule.DeclareOneFunc}}
\subsection{Prose}
Declaring a subprogram declaration \texttt{func\_sig} in a given environment \texttt{env} results
in \texttt{new\_env} and All of the following apply:
\begin{itemize}
  \item \texttt{name} is the identifier associated with the subprogram declaration;
  \item \texttt{env} does not contain another subprogram declaration for \texttt{name} that clashes with \texttt{func\_sig};
  \item \texttt{new\_env} is \texttt{env} where
  \item \texttt{new\_env} is \texttt{env} where
  \texttt{func\_sig} has been added to the set of subprograms declared with \texttt{name} (\subprogramrenamings)
  and \texttt{name} is associated with \texttt{func\_sig}.
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}

\newcommand\funcsig[0]{\texttt{func\_sig}}
\newcommand\subprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\hassubprogramtypeclash[0]{\texttt{subprogram\_type\_clash}}
\newcommand\subprogramclash[0]{\texttt{subprogram\_clash}}
\newcommand\argsclash[0]{\texttt{args\_clash}}

We define the helper rules \hassubprogramtypeclash, \argsclash, and subprogramclash\ to determined whether
two subprogram clash in terms of their subprogram types and their lists of argument types,
and then use them to annotate a subprogram declaration.

\begin{mathpar}
\inferrule{}{\hassubprogramtypeclash(\tenv, \texttt{ST\_Function}, \Ignore)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \Ignore, \texttt{ST\_Function})}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \texttt{ST\_Procedure}, \Ignore)}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \Ignore, \texttt{ST\_Procedure})}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \texttt{ST\_Getter}, \texttt{ST\_Getter})}
\and
\inferrule{}{\hassubprogramtypeclash(\tenv, \texttt{ST\_Setter}, \texttt{ST\_Setter})}
\and
\inferrule{
  \texttt{t\_args1} = [i=1..k: (\Ignore, \vt_i)]\\
  \texttt{s\_args1} = [i=1..k: (\Ignore, \vs_i)]\\
  j \in 1..k\\
  \typeclashes(\tenv, \vt_j, \vs_j)
}
{\argsclash(\tenv, \texttt{t\_args}, \texttt{s\_args})}
\and
\inferrule{
  \argsclash(\texttt{f}.\subprogramtype, \texttt{g}.\subprogramtype)\\
  \argsclash(\texttt{f}.\vargs, \texttt{g}.\vargs)\\
}
{ \subprogramclash(\texttt{f}, \texttt{g}) }
\and
\inferrule{
  \name = \funcsig.\name\\
  \texttt{same\_named} = G^\tenv.\subprogramrenamings(\name)\\
  \texttt{fo} \in \texttt{same\_named}: \neg\subprogramclash(\tenv, \funcsig, \texttt{fo})\\
  G' = G^\tenv.\subprogramrenamings[\name \mapsto \texttt{same\_named} \cup \{\funcsig\}]\\
  G'' = G'.\subprograms[\name \mapsto \funcsig]\\
  \texttt{new\_env} = (G'', L^\tenv)
}
{
  \declaredecl(\tenv, \texttt{func\_sig}) = G''
}
\end{mathpar}
\end{emptyformal}
\subsection{Comments}

This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.

\section{TypingRule.DeclareGlobalStorage \label{sec:TypingRule.DeclareGlobalStorage}}
\subsection{Prose}
Annotating a global storage declaration \texttt{d} in a given environment \texttt{env} results
in \texttt{new\_env} and one of the following applies:
\begin{itemize}
  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global constant named \name, with initial value expression \texttt{e}, and without a type annotation.
    \item \texttt{v} is the literal computed in \tenv\ by evaluating \texttt{e}.
    \item \texttt{t} is the type inferred for \texttt{v}
    \item \texttt{new\_env} is \tenv\ extended with a declaration of the constant \name, with initial value \texttt{v} and type \texttt{t}.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global constant named \name, with initial value expression \texttt{e}, and type annotation \texttt{ty}.
    \item \texttt{v} is the literal computed in \tenv\ by evaluating \texttt{e}.
    \item \texttt{t} is the type inferred for \texttt{v}.
    \item \texttt{t} type-satisfies \texttt{ty} in \tenv.
    \item \texttt{new\_env} is \tenv\ extended with a declaration of the constant \name, with initial value \texttt{v} and type \texttt{ty}.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global constant or global let with no initial value expression.
    \item An error ``\texttt{Constants or let-bindings must be initialized}'' is raised.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global variable or config named \name, with no initial value expression, and type annotation \texttt{ty}.
    \item One of the following apply:
    \begin{itemize}
      \item An error ``\texttt{identifier already declared}'' is raised and all of the following apply:
      \begin{itemize}
        \item \texttt{name} is not yet declared in the global environment.
        \item \texttt{new\_env} is \tenv\ extended with a declaration of the global storage element named \name, and type \texttt{ty}.
      \end{itemize}
    \end{itemize}
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global storage element with named \name, with initial value expression \texttt{e}, and no type.
    \item \texttt{t} is the type resulting from annotating the expression \texttt{e} in \tenv.
    \item \texttt{new\_env} is \tenv\ extended with a declaration of the global storage element named \name\ and type \texttt{ty}.
  \end{itemize}

  \item All of the following apply:
  \begin{itemize}
    \item \texttt{d} declares a global storage element with named \name, with initial value expression \texttt{e}, and type annotation \texttt{ty}.
    \item \texttt{t, e'} is the result of annotating the expression \texttt{e} in \tenv.
    \item One of the following apply:
    \begin{itemize}
      \item \texttt{t} does not type-satisfy \texttt{ty} in \tenv.
      \item A ``Conflicting types'' error is raised.
    \end{itemize}
    \item \texttt{new\_env} is \tenv\ extended with a declaration of the global storage element named \name\ and type \texttt{ty}.
  \end{itemize}
\end{itemize}

\subsection{Example}

\CodeSubsection{\DeclareGlobalStorageBegin}{\DeclareGlobalStorageEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\newcommand\gsd[0]{\texttt{gsd}}
\begin{mathpar}
  \inferrule[Case 1]{
    \gsd = \{\textsf{keyword} : \texttt{GDK\_Constant}, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\rangle, \textsf{name}:\name \}\\
    \vv = \texttt{reduce\_constants}(\tenv, \ve)\\
    \vt = \annotateliteral{\vv}\\
    \newtenv = \texttt{declare\_const}(\tenv, \name, \vt, \vv)
  }
  { \declaredecl{\tenv, \gsd} = \newtenv }
  \and
  \inferrule[Case 2]{
    \gsd = \{\textsf{keyword} : \texttt{GDK\_Constant}, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\tty\rangle, \textsf{name}:\name \}\\
    \vv = \texttt{reduce\_constants}(\tenv, \ve)\\
    \vt = \annotateliteral{\vv}\\
    \typesatisfies(\tenv, \vt, \tty)\\
    \newtenv = \texttt{declare\_const}(\tenv, \name, \tty, \vv)
  }
  { \declaredecl{\tenv, \gsd} = \newtenv }
  \and
  \inferrule[Case 4]{
    \gsd = \{\textsf{keyword} : \texttt{k}, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle \tty \rangle, \textsf{name}:\name \}\\
    \texttt{k} \in \{\texttt{GDK\_Config}, \texttt{GDK\_Var}\}\\
    G^\tenv.\storagetypes(\name) = \bot\\
    \newtenv = (G^\tenv.\storagetypes[\name \mapsto (\tty, \texttt{k})], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} = \newtenv }
  \and
  \inferrule[Case 5]{
    \gsd = \{\textsf{keyword} : \texttt{k}, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\rangle, \textsf{name}:\name \}\\
    G^\tenv.\storagetypes(\name) = \bot\\
    \annotateexpr{\tenv, \ve} = (\vt, \Ignore)\\
    \newtenv = (G^\tenv.\storagetypes[\name \mapsto (\vt, \texttt{k})], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} = \newtenv }
  \and
  \inferrule[Case 6]{
    \gsd = \{\textsf{keyword} : \texttt{k}, \textsf{initial\_value} : \langle \ve \rangle, \textsf{ty} : \langle\tty\rangle, \textsf{name}:\name \}\\
    G^\tenv.\storagetypes(\name) = \bot\\
    \annotateexpr{\tenv, \ve} = (\vt, \ve')\\
    \typesatisfies(\tenv, \vt, \tty)\\
    \newtenv = (G^\tenv.\storagetypes[\name \mapsto (\tty, \texttt{k})], L^\tenv)
  }
  { \declaredecl{\tenv, \gsd} = \newtenv }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identr{YSPM} and \identr{FWQM}.

\section{TypingRule.DeclareType \label{sec:TypingRule.DeclareType}}
\subsection{Prose}
Declaring a type named \texttt{name} with a type specification \texttt{ty},
optionally a supertype \texttt{sup} and extra fields \texttt{fields}, in a given environment \texttt{env} results
in \texttt{env'} and one of the following applies:
\begin{enumerate}
  \item All of the following apply:
  \begin{itemize}
    \item \name\ is already declared in \tenv.
    \item An error ``identifier already declared'' is raised.
  \end{itemize}
  \item All of the following apply:
  \begin{itemize}
    \item \name\ is not declared in \tenv.
    \item  \tenv',\tty' are the result of attempting to add \texttt{name} as a subtype of \texttt{sup} and
    \item  \tenv',\tty' are the result of attempting to add \texttt{name} as a subtype of \texttt{sup} and
    constructing the type \tty' as \tty\ with the added fields \texttt{fields} in \tenv.
    \item \tty' is a valid type.
    \item \tenv'' is \tenv' extended with \tty'.
    \item If \tty' has the structure of an enumeration than \newtenv\ is \tenv'' extended with the declarations of constants for each identifier,
    and otherwise \newtenv\ is \tenv''.
  \end{itemize}
\end{enumerate}

\subsection{Example}

\CodeSubsection{\DeclareTypeBegin}{\DeclareTypeEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\newcommand\attemptaddsubtype[0]{\texttt{attempt\_add\_subtype}}
\newcommand\attemptaddenum[0]{\texttt{attempt\_add\_enum}}
\newcommand\checkisvalidtype[0]{\texttt{check\_is\_valid\_type}}

\begin{mathpar}
  % \inferrule{ \astlabel(\tty) \not\in \{\TRecord, \TException, \TBits\} }
  % { \checkisvalidtype(\tenv, \tty) }
  % \and
  \inferrule{
    \checkvarnotinenv{\tenv, \name}\\
    \attemptaddsubtype(\tenv, \tty, \vs) = (\tenv', \tty')\\
    \checkisvalidtype(\tenv, \tty')\\
    \tenv'' = (G^{\tenv'}.\storagetypes[\name\mapsto \tty'], L^{\tenv'})\\
    \attemptaddenum(\tenv'', \tty') = \newtenv
  }
  { \declaredecl{\name, \tty, \vs} = \newtenv }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This is related to \identr{DHRC}, \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}, \identr{MDZD}, \identr{CHKR}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Typing of Specifications}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An ASL specification consists of a list of declarations.
Type checking the specification is considered successful if all declarations can be successfully annotated.

\newcommand\decls[0]{\texttt{decls}}

\section{TypingRule.Specification \label{sec:TypingRule.Specification}}
\subsection{Prose}
Annotating an ASL specification \texttt{decls} in an environment \texttt{env} results in a rewritten specification \texttt{decls'}
and a new environment \texttt{new\_env} and all of the following apply:
\begin{itemize}
  \item \texttt{ordered\_decls} is the result of topologically ordering \texttt{decls} according to their
  mutual dependencies.
  \item \newtenv\ is the result of declaring all global declarations in \texttt{ordered\_decls} in \tenv.
  \item \texttt{decls'} is the result of annotating every declaration in \texttt{decls} in the environment \newtenv.
\end{itemize}

\subsection{Example}

\CodeSubsection{\SpecificationBegin}{\SpecificationEnd}{../Typing.ml}
\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \texttt{order\_topologically}(\tenv, \decls) = \texttt{ordered\_decls}\\
    \texttt{ordered\_decls} = [i=1..k: \texttt{d}_i]\\
    \tenv_0 = \tenv\\
    i=1..k: \tenv_{i} = \declaredecl{\tenv_{i-1}, \texttt{d}_{i-1}}\\
    \newtenv = \tenv_{k}\\
    \decls' = [i=1..k: \texttt{annotate\_decl}(\newtenv, \texttt{d}_i) ]
  }
  { \annotatespec{\tenv, \decls} = (\decls', \newtenv) }
\end{mathpar}
\end{emptyformal}
\subsection{Comments}
This relates to \identi{LWQQ}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Static Evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TypingRule.StaticEval}
The partial function
\[
  \staticeval(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \;\aslto\;
  \overname{\literals}{\vv} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
evaluates an expression $\ve$, from a subset of the set of all expressions, in environment $\tenv$, returning a literal $\vv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[e\_literal]{}
  {
    \staticeval(\tenv, \ELiteral(\vv)) \typearrow \vv
  }
  \and
  \inferrule[e\_var]{
    \tododefine{lookup\_constant}(\tenv, \vx) = \vv
  }
  {
    \staticeval(\tenv, \EVar(\vx)) \typearrow \vv
  }
  \and
  \inferrule[e\_binop]{
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \staticeval(\tenv, \vetwo) \typearrow \vvtwo\\
    \binop(\op, \vvone, \vvtwo) \typearrow \vv
  }
  {
    \staticeval(\tenv, \EBinop(\op, \veone, \vetwo)) \typearrow \vv
  }
  \and
  \inferrule[e\_unop]{
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \unop(\op, \vvone) \typearrow \vv
  }
  {
    \staticeval(\tenv, \EUnop(\op, \veone)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_int]{
    \tododefine{slices\_to\_positions}(\tenv, \slices) \typearrow \positions\\
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \posmax \eqdef \max(\positions)\\
    \bv \eqdef \tododefine{bitvector\_of\_z}(\posmax + 1, \vi)\\
    \vv \eqdef \lbitvector(\tododefine{extract\_slice}(\bv, \positions))
  }
  {
    \staticeval(\tenv, \ESlice(\lint(\vi), \slices)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_bitvector]{
    \tododefine{slices\_to\_positions}(\tenv, \slices) \typearrow \positions\\
    \staticeval(\tenv, \veone) \typearrow \vvone\\
    \tododefine{bitvector\_length}(\bv) > \posmax\\
    \vv \eqdef \lbitvector(\tododefine{extract\_slice}(\bv, \positions))
  }
  {
    \staticeval(\tenv, \ESlice(\lbitvector(\bv), \slices)) \typearrow \vv
  }
  \and
  \inferrule[e\_slice\_type\_error]{
    \astlabel(\veone) \not\in \{\lint, \lbitvector\}
  }
  {
    \staticeval(\tenv, \ESlice(\veone, \slices)) \typearrow \TypeError(\texttt{TypeMismatch}(\veone, [\TInt, \TBits]))
  }
  \and
  \inferrule[e\_cond]{
    \staticeval(\tenv, \econd) \typearrow \vcond\\
    \vcond \eqname \lbool(\vb)\\
    \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\
    \staticeval(\tenv, \vep) \typearrow \vv
  }
  {
    \staticeval(\tenv, \ECond(\econd, \veone, \vetwo)) \typearrow \vv
  }
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Equivalence Testing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, we define \emph{conservative} equivalence tests for expressions and types.
By conservative, we mean that if a test returns $\True$ then the expressions or types being
compared are indeed equivalent, but if the test returns $\False$ then
there are two possibilities:
\begin{itemize}
  \item the expressions or types are not equivalent;
  \item the expressions or types are equivalent, but the reasoning power of our rules
  is not enough to prove it, and so we ``conservatively'' answer negatively.
\end{itemize}
In proof-theoretic terms, we can say that our equivalence tests are \emph{sound} but \emph{incomplete}.

Notice that for a conservative test, it is always correct to return $\False$.

\section{TypingRule.Equal}
\hypertarget{def-equal}{}
The meta function $\equal$ equates two values of the same mathematical type and returns
the respective Boolean value:
\begin{mathpar}
    \inferrule[equal-true]{a = b}
    {
        \equal(a, b) \rightarrow \True
    }
    \and
    \inferrule[equal-false]{a \neq b}
    {
        \equal(a, b) \rightarrow \False
    }
\end{mathpar}
The reason we define equality via rules is to allow using it as a short-circuiting premise.

\section{TypingRule.ExprEqual}
The function
\[
  \exprequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively checks whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False \terminateas \True\\\\
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
  {
    \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ExprEqualCase}

The function
\[
  \exprequalcase(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
specializes the expression equivalence test for the different types of expressions.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[different\_labels]{
    \astlabel(\veone) \neq \astlabel(\vetwo)
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_binop]{
    \veone \eqname \EBinop(\opone, \veoneone, \veonetwo)\\
    \vetwo \eqname \EBinop(\optwo, \vetwoone, \vetwotwo)\\\\
    \exprequal(\veoneone, \vetwoone) \typearrow \vbone\\
    \exprequal(\veonetwo, \vetwotwo) \typearrow \vbtwo\\\\
    \vb \eqdef (\opone = \optwo) \land \vbone \land \vbtwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

Recall that a conjunction over an empty set equals $\True$.
\begin{mathpar}
  \inferrule[e\_call]{
    \veone \eqname \ECall(\nameone, \vargsone, \Ignore)\\
    \vetwo \eqname \ECall(\nametwo, \vargstwo, \Ignore)\\\\
    \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
    \equallength(\vargsone, \vargstwo) \typearrow \True \terminateas \False\\\\
    i \in \listrange(\vargsone): \exprequal(\tenv, \vargsone[i], \vargstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vargsone)} \vb_i
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
    \inferrule[e\_concat]{
    \veone \eqname \EConcat(\vlone)\\
    \vetwo \eqname \EConcat(\vltwo)\\\\
    \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
    i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
    \inferrule[e\_cond]{
    \veone \eqname \ECond(\veoneone, \veonetwo, \veonethree)\\
    \vetwo \eqname \ECond(\vetwoone, \vetwotwo, \vetwothree)\\\\
    \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
    \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
    \exprequal(\tenv, \veonethree, \vetwothree) \typearrow \vbthree\\
    \vb \eqdef \vbone \land \vbtwo \land \vbthree
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_slice]{
  \veone \eqname \ESlice(\veoneone, \slicesone)\\
  \vetwo \eqname \ESlice(\vetwoone, \slicestwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
  \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getarray]{
  \veone \eqname \EGetArray(\veoneone, \veonetwo)\\
  \vetwo \eqname \EGetArray(\vetwoone, \vetwotwo)\\\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
  \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfield]{
  \veone \eqname \EGetField(\veoneone, \vfieldone)\\
  \vetwo \eqname \EGetField(\vetwoone, \vfieldtwo)\\\\
  \vbone \eqdef \vfieldone = \vfieldtwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_getfields]{
  \veone \eqname \EGetFields(\veoneone, \vfieldsone)\\
  \vetwo \eqname \EGetFields(\vetwoone, \vfieldstwo)\\\\
  \vbone \eqdef \vfieldsone = \vfieldstwo\\
  \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbtwo\\
  \vb \eqdef \vbone \land \vbtwo
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_literal]{
  \veone \eqname \ELiteral(\vvone)\\
  \vetwo \eqname \ELiteral(\vvtwo)\\\\
  \literalequal(\vvone, \vvtwo) \typearrow \vb
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern1]{
  \astlabel(\veone) = \EPattern
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\and
\inferrule[e\_pattern2]{
  \astlabel(\vetwo) = \EPattern
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record1]{
  \astlabel(\veone) = \ERecord
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\and
\inferrule[e\_record2]{
  \astlabel(\vetwo) = \ERecord
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_tuple]{
  \veone \eqname \ETuple(\vlone)\\
  \vetwo \eqname \ETuple(\vltwo)\\
  \equallength(\vlone, \vltwo) \typearrow \True \terminateas \False\\\\
  i \in \listrange(\vlone): \exprequal(\tenv, \vlone[i], \vltwo[i]) \typearrow \vb_i\\
  \vb \eqdef \bigwedge_{i \in \listrange(\vlone)} \vb_i
}
{
  \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_unop]{
    \veone \eqname \EUnop(\opone, \veoneone)\\
    \vetwo \eqname \EUnop(\optwo, \vetwoone)\\\\
    \exprequal(\veoneone, \vetwoone) \typearrow \vbone\\
    \vb \eqdef (\opone = \optwo) \land \vbone
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_unknown1]{
    \astlabel(\veone) = \EUnknown
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
  \and
  \inferrule[e\_unknown2]{
    \astlabel(\vetwo) = \EUnknown
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_ctc]{
    \veone \eqname \ECTC(\veoneone, \vtone)\\
    \vetwo \eqname \ECTC(\vetwoone, \vttwo)\\
    \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[e\_var]{
    \veone \eqname \EVar(\nameone)\\
    \vetwo \eqname \EVar(\nametwo)\\\\
    \vb \eqdef \nameone = \nametwo
  }
  {
    \exprequalcase(\tenv, \veone, \vetwo) \typearrow \vb
  }
\end{mathpar}

\end{emptyformal}
%   | E_Pattern _, _ | E_Record _, _ -> assert false

\section{TypingRule.ExprEqualNorm}

The function
\[
  \exprequalnorm(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\veone} \aslsep \overname{\expr}{\vetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the expression $\veone$ is equivalent to the expression $\vetwo$ in environment $\tenv$
by attempting to transform both expressions to their \emph{normal form} representation
and, if successful, comparing the resulting normal forms for equality.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{all\_supported}):
  \begin{itemize}
    \item $\veone$ can be transformed into the intermediate representation $\irone$;
    \item $\vetwo$ can be transformed into the intermediate representation $\irtwo$;
    \item $\vb$ is the result of equating $\irone$ and $\irtwo$.
  \end{itemize}

  \item All of the following apply (\textsc{unsopported1}):
  \begin{itemize}
    \item $\veone$ can not be transformed into an intermediate representation.
    \item $\vb$ is $\False$;
  \end{itemize}

  \item All of the following apply (\textsc{unsupported2}):
  \begin{itemize}
    \item $\vetwo$ can not be transformed into an intermediate representation.
    \item $\vb$ is $\False$;
  \end{itemize}
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[all\_supported]{
    \toir(\veone) \typearrow \irone\\
    \toir(\vetwo) \typearrow \irtwo\\
    \vb \eqdef \irone = \irtwo
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \vb
  }
  \and
  \inferrule[unsupported1]{
    \toir(\veone) \not\typearrow \irone
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False
  }
  \and
  \inferrule[unsupported2]{
    \toir(\vetwo) \not\typearrow \irtwo
  }
  {
    \exprequalnorm(\tenv, \veone, \vetwo) \typearrow \False
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIR}
The function
\[
  \toir(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \partialto \overname{\exprir}{\vp}
\]
transforms a subset of ASL expressions into
an intermediate representation $\exprir$, which is essentially polynomials in reduced form.

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{case\_success}):
  \begin{itemize}
    \item the expression $\ve$ can be transformed into the intermediate representation form as $\vp$;
    \item the result is $\vp$;
  \end{itemize}

  \item All of the following apply (\textsc{static\_eval\_success}):
  \begin{itemize}
    \item the expression $\ve$ cannot be transformed into the intermediate representation form as $\vp$;
    \item the expression $\ve$ can be statically evaluated to yield an integer value $\vv$;
    \item $\vp$ is the reduced polynomial representing the value $\vv$.
  \end{itemize}

  \item Neither case above holds, and $\vp$ is $\bot$
\end{itemize}

\begin{emptyformal}
\subsection{Formally}
The meaning of each element of $\exprir$ can be interpreted as a mathematical formula,
which we define via the interpretation function $\alpha$.

\begin{definition}[Monomial]
  \emph{Monomials} are partial functions from variables to positive integers:
  $\monomials : \Prod(\identifier \partialto \{0, 1, \ldots\})$.
  %
  A monomial $\Prod(\vm)\in\monomials$ can be interpreted as follows:
  \[
    \alpha(\Prod(\vm)) \triangleq \prod_{\vx \in \dom(\vm)} \vx^{\vm(\vx)}
  \]
\end{definition}
For example, the monomial $\Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\})$ can be interpreted as the term $x^3 \cdot y \cdot z^2$.

The function
\[
  \mulmonomials(\overname{\monomials}{\vmone} \aslsep \overname{\monomials}{\vmtwo}) \rightarrow \overname{\monomials}{\vm}
\]
multiplies two monomials and returns a monomial
\begin{mathpar}
  \inferrule{
    \vmone \eqname \Prod(\vfone)\\
    \vmtwo \eqname \Prod(\vftwo)\\
    {
      \vf \eqdef \lambda \vx\in\identifier.\
      \left\{
      \begin{array}{ll}
        \vfone(\vx) & \text{if } \vx \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vx) & \text{if } \vx \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vx)+\vftwo(\vx) & \text{else } \vx \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }\\
    \vm \eqdef \Prod(\vf)
  }
  {
    \mulmonomials(\vmone, \vmtwo) \typearrow \vm
  }
\end{mathpar}
For example,
\[
  \begin{array}{ll}
  \mulmonomials( & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}),\\
                 & \Prod(\{\vx\mapsto 1, \vw\mapsto 2\}) ) =\\
                 & \Prod(\{\vx\mapsto 4, \vy\mapsto 1, \vz\mapsto2, \vw\mapsto2\})
  \end{array}
\]

\begin{definition}[Polynomial]
  \emph{Polynomials} are partial functions from monomials to integers:
  $\polynomials: \Sum(\monomials \partialto \Z)$.
  Intuitively, each monomial is mapped to its factor.
  A polynomial $\Sum(\vp)$ can be interpreted as follows:
  %
\[
  \alpha(\Sum(\vp)) \triangleq \sum_{\vm \in \dom(\vp)} \vp(\vm)\cdot\alpha(\vm)
\]
\end{definition}
For example, the polynomial
\[
    \begin{array}{rlcl}
      \Sum(\{ & \Prod(\{\vx\mapsto 3, \vy\mapsto 1, \vz\mapsto2\}) &\mapsto& -1,\\
              & \Prod(\{\vx\mapsto 2, \vy\mapsto 1\}) &\mapsto& 3\\
          \}) & & &
    \end{array}
\]
can be interpreted as
$-1\cdot x^3 \cdot y \cdot z^2 + 3 \cdot \vx^2\cdot \vy$.

We define the intermediate representation to be polynomials. That is, $\exprir \triangleq \polynomials$.

The function
\[
  \addpolynomials : \polynomials \times \polynomials \rightarrow \polynomials
\]
adds two polynomials.
\begin{mathpar}
  \inferrule{
    \vpone \eqname \Sum(\vfone)\\
    \vptwo \eqname \Sum(\vftwo)\\
    {
      \vf \eqdef \lambda \vm\in\monomials.\
      \left\{
      \begin{array}{ll}
        \vfone(\vm) & \text{if } \vm \in \dom(\vfone) \setminus \dom(\vftwo)\\
        \vfone(\vm) & \text{if } \vm \in \dom(\vftwo) \setminus \dom(\vfone)\\
        \vfone(\vm)+\vftwo(\vm) & \text{else } \vm \in \dom(\vfone) \cap \dom(\vftwo)\\
      \end{array}
      \right.
    }\\
    \vp \eqdef \Sum(\vf)
  }
  {
    \addpolynomials(\vpone, \vptwo) \typearrow \vp
  }
\end{mathpar}

The function
\[
  \mulpolynomials : \polynomials \times \polynomials \rightarrow \polynomials
\]
multiplies two polynomials.
\begin{mathpar}
  \inferrule{
    \vpone \eqname \Sum(\vfone)\\
    \vptwo \eqname \Sum(\vftwo)\\
    {
      \vps \eqdef \{ \Sum(\{\mulmonomials(\vmone, \vmtwo) \mapsto \vcone\times\vctwo\})
        \;|\; \vfone(\vmone)=\vcone, \vftwo(\vmtwo)=\vctwo\}
    }\\
    \vps \eqname \{ i=1..k: \vp[i] \}\\
    \vp \eqdef \addpolynomials(\addpolynomials(\vp[1], \vp[2]), \ldots, \vp[k]\ldots)\\
  }
  {
    \mulpolynomials(\vpone, \vptwo) \typearrow \vp
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[case\_success]{
    \toircase(\tenv, \ve) \typearrow \vp
  }
  {
    \toir(\tenv, \ve) \typearrow \vp
  }
  \and
  \inferrule[static\_eval\_success]{
    \toircase(\tenv, \ve) \not\typearrow \Ignore\\
    \staticeval(\tenv, \ve) \typearrow \vv\\
    \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto \vv \} )
  }
  {
    \toir(\tenv, \ve) \typearrow \vp
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ToIRCase}

\begin{mathpar}
  \inferrule[literal\_int]{}
  {
    \toircase(\tenv, \ELiteral(\lint(\vi))) \typearrow \Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )
  }
  \and
  \inferrule[int\_constant]{
    \tododefine{lookup\_constant}(\tenv, \vs) = \ELiteral(\lint(\vi))
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \Sum( \{ \Prod(\emptyfunc)\mapsto \vi \} )
  }
  \and
  \inferrule[int\_exact\_constraint]{
    \tododefine{type\_of}(\vs) = \vt\\
    \makeanonymous(\vt) = \TInt(\wellconstrained([\ConstraintExact(\ve)]))\\
    \toir(\ve) \typearrow \vp
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \vp
  }
  \and
  \inferrule[int\_var]{
    \tododefine{type\_of}(\vs) = \vt\\
    \makeanonymous(\vt) = \TInt(\vc)\\
    \neg(\exists \ve \in \expr.\ \vc = \wellconstrained([\ConstraintExact(\ve)]))
  }
  {
    \toircase(\tenv, \EVar(\vs)) \typearrow \Sum( \{ \Prod(\{\vs\mapsto 1\})\mapsto 1 \} )
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[ebinop\_plus]{
    \toir(\tenv, \veone) \typearrow \irone\\
    \toir(\tenv, \vetwo) \typearrow \irtwo\\
    \vp \eqdef \addpolynomials(\irone, \irtwo)
  }
  {
    \toircase(\tenv, \EBinop(\PLUS, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_minus]{
    \toir(\tenv, \EBinop(\PLUS, \veone, \EBinop(\MINUS, \vetwo))) \typearrow \vp
  }
  {
    \toircase(\tenv, \EBinop(\MINUS, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_mul]{
    \toir(\tenv, \veone) \typearrow \irone\\
    \toir(\tenv, \vetwo) \typearrow \irtwo\\
    \vp \eqdef \mulpolynomials(\irone, \irtwo)
  }
  {
    \toircase(\tenv, \EBinop(\MUL, \veone, \vetwo)) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_shl]{
    k \eqdef 2^{\vitwo}\\
    \toir(\tenv, \EBinop(\MUL, \veone, \ELiteral(\lint(k)))) \typearrow \vp
  }
  {
    \toircase(\tenv, \EBinop(\SHL, \veone, \ELiteral(\lint(\vitwo)))) \typearrow \vp
  }
  \and
  \inferrule[ebinop\_literals]{
    \binop(\op, \vlone, \vltwo) \typearrow k\\
    \vp \eqdef \Sum( \{ \Prod(\emptyfunc)\mapsto k \} )
  }
  {
    \toircase(\tenv, \EBinop(\op, \ELiteral(\lint(\vione)), \ELiteral(\lint(\vitwo)))) \typearrow \vp
  }
  \and
  \inferrule[eunop\_neg]{
    \toir(\tenv, \EBinop(\MUL, \ELiteral(\lint(-1)),\veone )) \typearrow \vp
  }
  {
    \toircase(\tenv, \EUnop(\NEG, \veone)) \typearrow \vp
  }
\end{mathpar}

% let rec to_ir env (e : expr) : ir_expr =
%     | E_Binop (SHL, e1, { desc = E_Literal (L_Int i2); _ }) ->
%         let ir1 = to_ir env e1 and f2 = Z.pow Z.one (Z.to_int i2) in
%         map_num
%           (fun (Sum monos) -> Sum (MMap.map (fun c -> Z.mul c f2) monos))
%           ir1
%     | E_Binop (op, { desc = E_Literal l1; _ }, { desc = E_Literal l2; _ }) ->
%         binop_values e op l1 l2 |> poly_of_val |> always
%     | E_Unop (NEG, e0) -> e0 |> to_ir env |> map_num poly_neg
%     | E_Cond (cond, e1, e2) ->
%         let Disjunction ctnts, Disjunction nctnts = to_cond env cond
%         and (Disjunction ir1) = to_ir env e1
%         and (Disjunction ir2) = to_ir env e2 in
%         let restrict ctnts (ctnts', p) = (ctnts_and ctnts ctnts', p) in
%         let ir1' = ASTUtils.list_cross restrict ctnts ir1
%         and ir2' = ASTUtils.list_cross restrict nctnts ir2 in
%         Disjunction (ir1' @ ir2')
%     | _ -> (
%         let v =
%           try static_eval env e
%           with Error.ASLException { desc = UnsupportedExpr _; _ } ->
%             raise NotYetImplemented
%         in
%         match v with
%         | L_Int i -> poly_of_z i |> always
%         | _ -> raise NotYetImplemented)

\section{TypingRule.TypeEqual}
The function
\[
  \typeequal(\overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the type $\vtone$ is equivalent to the type $\vttwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule[different\_labels]{
    \astlabel(\vtone) \neq \astlabel(\vttwo)
  }
  {
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \False
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[TBool]{}
  {
    \typeequal(\tenv, \TBool, \TBool) \typearrow \True
  }
  \and
  \inferrule[TReal]{}
  {
    \typeequal(\tenv, \TReal, \TReal) \typearrow \True
  }
  \and
  \inferrule[TString]{}
  {
    \typeequal(\tenv, \TString, \TString) \typearrow \True
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tint\_unconstrained]{}
  {
    \typeequal(\tenv, \TInt(\unconstrained), \TInt(\unconstrained)) \typearrow \True
  }
  \and
  \inferrule[tint\_underconstrained]{
    \vb \eqdef \vione = \vitwo
  }
  {
    \typeequal(\tenv, \TInt(\underconstrained(\vione, \Ignore)), \TInt(\unconstrained(\vitwo, \Ignore))) \typearrow \vb
  }
  \and
  \inferrule[tint\_wellonstrained]{
    \constraintsequal(\tenv, \vcone, \vctwo) \typearrow \vb
  }
  {
    \typeequal(\tenv, \TInt(\wellconstrained(\vcone)), \TInt(\wellconstrained(\vctwo))) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tbits]{
    \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vbone\\
    \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \typeequal(\tenv, \TBits(\vwone, \bfone), \TBits(\vwtwo, \bftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tarray]{
    \exprequal(\tenv, \vlone, \vltwo) \typearrow \vbone\\
    \typeequal(\tenv, \vtone, \vttwo) \typearrow \vbtwo\\
    \vb \eqdef \vbone \land \vbtwo
  }
  {
    \typeequal(\tenv, \TArray(\vlone, \vtone), \TArray(\vltwo, \vttwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tnamed]{
    \vb \eqdef \vsone = \vstwo
  }
  {
    \typeequal(\tenv, \TNamed(\vsone), \TArray(\vstwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[tenum]{
    \vb \eqdef \vlone = \vltwo
  }
  {
    \typeequal(\tenv, \TEnum(\vlone), \TEnum(\vltwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[trecord]{
    \equal(\dom(\vfone), \dom(\vftwo)) \equalarrow \True \terminateas \False\\\\
    \vf \in \dom(\vfone): \typeequal(\tenv, \vfone(\vf), \vftwo(\vf)) \typearrow \vb_\vf\\
    \vb \eqdef \bigwedge_{\vf \in \dom(\vfone)} \vb_\vf
  }
  {
    \typeequal(\tenv, \TRecord(\vfone), \TRecord(\vftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[texception]{
    \equal(\dom(\vfone), \dom(\vftwo)) \equalarrow \True \terminateas \False\\\\
    \vf \in \dom(\vfone): \typeequal(\tenv, \vfone(\vf), \vftwo(\vf)) \typearrow \vb_\vf\\
    \vb \eqdef \bigwedge_{\vf \in \dom(\vfone)} \vb_\vf
  }
  {
    \typeequal(\tenv, \TException(\vfone), \TException(\vftwo)) \typearrow \vb
  }
\end{mathpar}

\begin{mathpar}
  \inferrule[ttuple]{
    \equallength(\vtsone, \vtstwo) \typearrow \True \terminateas \False\\
    i \in \listrange(\vtsone): \typeequal(\tenv, \vtsone[i], \vtstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i \in \listrange(\vtsone)} \vb_i
  }
  {
    \typeequal(\tenv, \TTuple(\vtsone), \TTuple(\vtstwo)) \typearrow \vb
  }
\end{mathpar}
% | T_Int (UnderConstrained (i1, _)), T_Int (UnderConstrained (i2, _)) ->
%     i1 == i2
\end{emptyformal}

\section{TypingRule.BitwidthEqual}

The function
\[
  \bitwidthequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\vwone} \aslsep \overname{\expr}{\vwtwo})
  \rightarrow\overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the bitwidth expression $\vwone$ is equivalent to the bitwidth expression $\vwtwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \exprequal(\tenv, \vwone, \vwtwo) \typearrow \vb
  }
  {
    \bitwidthequal(\tenv, \vwone, \vwtwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldsEqual}

The function
\[
  \bitfieldsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield^*}{\bfone} \aslsep \overname{\bitfield^*}{\bftwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the list of bitfields $\bfone$ is equivalent to the list of bitfields $\bftwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \equallength(\bfone, \bftwo) \typearrow \True \terminateas \False\\\\
      i\in\listrange(\bfone): \bitfieldequal(\tenv, \bfone[i], \bftwo[i]) \typearrow \vb_i\\\\
      \vb \eqdef \bigwedge_{i\in\listrange(\bfone)} \vb_i
    }
    {
      \bitfieldsequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.BitFieldEqual}

The function
\[
  \bitfieldequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\bitfield}{\bfone} \aslsep \overname{\bitfield}{\bftwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the bitfield $\bfone$ is equivalent to the bitfield $\bftwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule[different\_labels]{
      \astlabel(\bfone) \neq \astlabel(\bftwo)
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \False
    }
    \and
    \inferrule[bitfield\_simple]{
      \bfone \eqname \BitFieldSimple(\nameone, \slicesone)\\
      \bftwo \eqname \BitFieldSimple(\nametwo, \slicestwo)\\\\
      \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
      \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
    \and
    \inferrule[bitfield\_nested]{
      \bfone \eqname \BitFieldNested(\nameone, \slicesone, \bfoneone)\\
      \bftwo \eqname \BitFieldNested(\nametwo, \slicestwo, \bftwoone)\\
      \equal(\nameone, \nametwo) \equalarrow \True \terminateas \False\\\\
      \slicesequal(\tenv, \slicesone, \slicestwo) \True \terminateas \False\\\\
      \bitfieldsequal(\tenv, \bfoneone, \bftwoone) \typearrow \vb
    }
    {
      \bitfieldequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}
% What about BitField_Type?

\section{TypingRule.ConstraintsEqual}

The function
\[
  \constraintsequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraints}{\csone} \aslsep \overname{\intconstraints}{\cstwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the constraint list $\csone$ is equivalent to the constraint list $\cstwo$ in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \equallength(\csone, \cstwo) \typearrow \True \terminateas \False\\
    i\in\listrange(\csone): \constraintequal(\tenv, \csone[i], \cstwo[i]) \typearrow \vb_i\\
    \vb \eqdef \bigwedge_{i\in\listrange(\csone)} \vb_i
  }
  {
    \constraintsequal(\tenv, \csone, \cstwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

\section{TypingRule.ConstraintEqual}

The function
\[
  \constraintequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vstwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the constraint $\vcone$ is equivalent to the constraint $\vctwo$ in environment $\tenv$.

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule[different\_labels]{
      \astlabel(\vcone) \neq \astlabel(\vctwo)
    }
    {
      \constraintequal(\tenv, \vcone, \vctwo) \typearrow \False
    }
    \and
    \inferrule[constraint\_exact]{
      \vcone \eqname \ConstraintExact(\veone)\\
      \vctwo \eqname \ConstraintExact(\vetwo)\\\\
      \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
    }
    {
      \constraintequal(\tenv, \vcone, \vctwo) \typearrow \vb
    }
    \and
    \inferrule[constraint\_range]{
      \bfone \eqname \ConstraintRange(\veoneone, \veonetwo)\\
      \bftwo \eqname \ConstraintRange(\vetwoone, \vetwotwo)\\
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \veonetwo, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \constraintequal(\tenv, \bfone, \bftwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.SlicesEqual}

The function
\[
  \slicesequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slicesone} \aslsep \overname{\slice^*}{\slicestwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the list of slices $\slicesone$ is equivalent to the list of slices $\slicestwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \equallength(\slicesone, \slicestwo) \typearrow \True \terminateas \False\\
      i\in\listrange(\slicesone): \sliceequal(\tenv, \slicesone[i], \slicestwo[i]) \typearrow \vb_i\\
      \vb \eqdef \bigwedge_{i\in\listrange(\slicesone)} \vb_i
    }
    {
      \slicesequal(\tenv, \slicesone, \slicestwo) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.SliceEqual}

The function
\[
  \sliceequal(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\sliceone} \aslsep \overname{\slice}{\slicetwo})
  \rightarrow \overname{\{\True, \False\}}{\vb}
\]
conservatively tests whether the slice $\sliceone$ is equivalent to the slice $\slicetwo$
in environment $\tenv$.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
    \inferrule[different\_label]{
      \astlabel(\sliceone) \neq \astlabel(\slicetwo)
    }
    {
      \slicesequal(\tenv, \sliceone, \slicetwo) \typearrow \False
    }
    \and
    \inferrule[slice\_single]{
      \exprequal(\tenv, \veone, \vetwo) \typearrow \vb
    }
    {
      \slicesequal(\tenv, \SliceSingle(\veone), \SliceSingle(\vetwo)) \typearrow \vb
    }
    \and
    \inferrule[slice\_range]{
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \slicesequal(\tenv, \SliceRange(\veoneone, \veonetwo), \SliceRange(\vetwoone, \vetwotwo)) \typearrow \vb
    }
    \and
    \inferrule[slice\_length]{
      \exprequal(\tenv, \veoneone, \vetwoone) \typearrow \vbone\\
      \exprequal(\tenv, \vetwoone, \vetwotwo) \typearrow \vbtwo\\
      \vb \eqdef \vbone \land \vbtwo
    }
    {
      \slicesequal(\tenv, \SliceLength(\veoneone, \veonetwo), \SliceLength(\vetwoone, \vetwotwo)) \typearrow \vb
    }
  \end{mathpar}
\end{emptyformal}

\section{TypingRule.LiteralEqual}

The function
\[
  \literalequal(\overname{\literal}{\vvone} \aslsep \overname{\literal}{\vvtwo}) \rightarrow \overname{\{\True, \False\}}{\vb}
\]
tests whether literal $\vvone$ is $\vvtwo$ by equating them.

\begin{emptyformal}
\subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vb \eqdef \vvone= \vvtwo
  }
  {
    \literalequal(\vvone, \vvtwo) \typearrow \vb
  }
\end{mathpar}
\end{emptyformal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{ASL}

\end{document}
