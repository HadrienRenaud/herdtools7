\chapter{Error Codes}

\section{Static Error Codes}
\begin{description}
\hypertarget{def-binopprecedence}{}
\item[$\BinopPrecedence$]
This error indicates that a compound binary expression consists of two associative binary
operators of the same precedence, without the use of parenthesis (see \ASTRuleRef{CheckNotSamePrec}).

\hypertarget{def-expectedbitvectortype}{}
\item[$\ExpectedBitvectorType$]
This error indicates that a bitvector type was expected where a non-bitvector type was given.
See \typingrulecasename{ApplyBinopTypes}{plus\_minus\_bits\_bits} (\TypingRuleRef{ApplyBinopTypes}) for an example.

\hypertarget{def-expectedenumerationtype}{}
\item[$\ExpectedEnumerationType$]
This error indicates that an enumeration type was expected where a \\
non-enumeration type was given.
See \TypingRuleRef{TArray} for an example.

\hypertarget{def-expectedstructuredtype}{}
\item[$\ExpectedStructuredType$]
This error indicates that a \structuredtype\ was expected where a non-\structuredtype\ was given.
See \TypingRuleRef{ERecord} for an example.

\hypertarget{def-expectedtupletype}{}
\item[$\ExpectedTupleType$]
This error indicates that a tuple type was expected where a non-tuple type was given.
See \TypingRuleRef{LEDestructuring} for an example.

\hypertarget{def-setterwithoutgetter}{}
\item[$\SetterWithoutGetter$:]
ASL requires each setter for a given identifier to have a corresponding getter for the same
identifier.
The specification either does not contain a getter for the same identifier
or a getter for the same identifier exists, but it does not have the expected
signature (see \TypingRuleRef{CheckSetterHasGetter}).

\hypertarget{def-undefinedidentifier}{}
\item[$\UndefinedIdentifier$]
An identifier that is missing a definition of the appropriate kind.
See \TypingRuleRef{SubprogramForName} for an example.

\hypertarget{def-identifieralreadydeclared}{}
\item[$\IdentifierAlreadyDeclared$]
This error indicates an attempt to declare an identifier where it has already been declared.
The context makes it clear whether this error relates to the local static environment or to the
entire static environment.
See \TypingRuleRef{CheckVarNotInEnv} and \TypingRuleRef{CheckVarNotInGEnv}.

\hypertarget{def-lengthsmismatch}{}
\item[$\LengthsMismatch$]
This error indicates that two lists that are expected to have the same length have different lengths.
See \TypingRuleRef{LEDestructuring} for an example.

\hypertarget{def-subprogramdeclaredmultipletimes}{}
\item[$\SubrogramDeclaredMultipleTimes$]
At least two subprograms in the specification clash.
See \TypingRuleRef{AddNewFunc} for an example.

\hypertarget{def-nocallcandidates}{}
\item[$\NoCallCandidates$]
A function call, given by its name and list of formal argument types, does not match any defined subprogram.
See \TypingRuleRef{SubprogramForName} for an example.

\hypertarget{def-toomanycandidates}{}
\item[$\TooManyCandidates$]
A function call, given by its name and list of formal argument types, matches more than one subprogram,
which does not allow the type-checker to decide which subprogram the call refers to.
See \TypingRuleRef{SubprogramForName} for an example.

\hypertarget{def-badparameterdecl}{}
\item[$\BadParameterDecl$]
A subprogram has an invalid declaration of its parameters.\\
See \TypingRuleRef{CheckParamDecls} for an example.

\hypertarget{def-nolca}{}
\item[$\NoLCA$]
A conditional expressions results in two types that have no common ancestor type that can represent both.
See \TypingRuleRef{LowestCommonAncestor} for an example.

\hypertarget{def-mrv}{}
\item[$\MismatchedReturnValue$]
A call to a function must result in a returned value,
whereas a call to a procedure must not.
This error occurs when a call to a function or a getter is inferred to refer to a procedure or a setter,
or a call to a procedure or a setter is inferred to refer to a function or a getter.
See \TypingRuleRef{AnnotateCallActualsTyped} for an example.

\hypertarget{def-brs}{}
\item[$\BadReturnStatement$]
Values can only be returned from within a subprogram which declares a return type (a function or getter).
This error occurs when attempting to return a value from a procedure or setter.
See \TypingRuleRef{SReturn} for an example.

\hypertarget{def-cba}{}
\item[$\CallBadArity$]
A call to a subprogram must have the same number of arguments as the list of formal arguments
declared for the subprogram.
This error indicates that the number of arguments is different to the number of declared formal arguments.
See \TypingRuleRef{AnnotateCallActualsTyped} for an example.

\hypertarget{def-cbpa}{}
\item[$\CallBadParameterArity$]
A call to a subprogram must have the same number of parameters as the list of formal parameters
declared for the subprogram.
This error indicates that the number of parameters is different to the number of declared formal parameters.
See \TypingRuleRef{AnnotateCallActualsTyped} for an example.

\hypertarget{def-brd}{}
\item[$\BadRecursiveDecls$]
Only subprogram declarations may be mutually recursive.
This error indicates that at least one declaration in a given list of mutually recursive declarations
is not a subprogram.
See \TypingRuleRef{TypeCheckMutuallyRec} for an example.

\hypertarget{def-lbi}{}
\item[$\RequireIntegerForLoopBounds$]
The expressions defining the bounds of a \texttt{for} loop are required to have the \structure\ of
an integer type.
This error indicates that at least one of the start expression and end expression violate this
requirement.
See \TypingRuleRef{TypeCheckMutuallyRec} for an example.

\hypertarget{def-mfi}{}
\item[$\MissingFieldInitializer$]
This error indicates that an initialization of a \structuredtype\ is missing an expression to initialize
one of its fields.
See \TypingRuleRef{ERecord} for an example.

\hypertarget{def-rsb}{}
\item[$\RequireSameBitwidths$]
This error indicates that two bitvector types are required to have the same bitwidths but the type-checker
was not able to prove it.
See \secref{BitvectorOperations} for an example.

\hypertarget{def-taf}{}
\item[$\TypeAsssertionFails$]
This error indicates that a given at type assertion expression will always fail.
See \TypingRuleRef{CheckATC} for an example.

\hypertarget{def-ofc}{}
\item[$\BinaryOperationFailsAllConstraints$]
This error indicates that a binary expression appearing in a constraint will always fail dynamically.
This means that the set of values that the type containing
the constraint can take is empty.
See \TypingRuleRef{BinopFilterRhs} for an example.

\hypertarget{def-otb}{}
\item[$\InvalidOperandTypesForBinop$]
This error indicates that the operator of a binary expression cannot be applied to its operand expressions
due to their types.
See \TypingRuleRef{ApplyBinopTypes} for an example.

\hypertarget{def-iaf}{}
\item[$\AnnonymousFormNotAllowedHere$]
This error indicates that an anonymous type is being used as a type annotation in a context
where anonymous types are not allowed.
See \TypingRuleRef{TNonDecl} for an example.

\hypertarget{def-aim}{}
\item[$\AssignmentToImmutable$]
This error indicates that an assignment has a left-hand-side storage element that is immutable.
See \TypingRuleRef{LEVar} for an example.

\hypertarget{def-mf}{}
\item[$\MissingField$]
This error indicates that an access is made (for either reading or writing) to a field that is
not declared by the respective \structuredtype\ or a bitfield that is not declared by the respective
bitvector type.
See \TypingRuleRef{LESetStructuredField} for an example.

\hypertarget{def-dii}{}
\item[$\DivIntIndivisible$]
This error indicates that static evaluation encountered an integer division expression where
the denominator does not divide the numerator.
See \textsc{TypingRule.BinopLiterals.DIV\_INT} (\TypingRuleRef{BinopLiterals}) for an example.

\hypertarget{def-bor}{}
\item[$\BitfieldsOutOfRange$]
This error indicates that at least one bitfield is declared with indices that go out of the range
$[0, \vwidth]$ where $\vwidth$ is the width of the enclosing bitvector type.
See \textsc{TypingRule.CheckPositionsInWidth} (\TypingRuleRef{CheckPositionsInWidth}).

\hypertarget{def-bso}{}
\item[$\BitfieldSlicesOverlap$]
This error indicates that two bitfield slices defined for a bitvector type have overlapping ranges.
This is checked by \TypingRuleRef{DisjointSlicesToPositions}.

\hypertarget{def-bsr}{}
\item[$\BitfieldSliceReversed$]
This error indicates that a bitfield slice is defined such that its upper position is less than its lower position.
This is checked by \TypingRuleRef{BitfieldSliceToPositions}.

\hypertarget{def-icc}{}
\item[$\IntConstantExpected$]
This error indicates that a given expression was expected to statically evaluate
to an integer-typed literal but either evaluated to a literal of a different type
or could not be statically evaluated to a literal.
This is checked by \TypingRuleRef{BitfieldSliceToPositions}.

\hypertarget{def-es}{}
\item[$\EmptySlice$]
This error indicates that an expression is either a slice with an empty list of slice subexpressions
or an incorrect way of invoking a getter or a setter with the wrong list of arguments, a missing
list of arguments, or a list of arguments where the getter or setter are declared with no arguments.
This is checked by \TypingRuleRef{ESlice}.

\hypertarget{def-bvns}{}
\item[$\BaseValueNonStatic$]
This error indicates that a storage element without a supplied initializing expression cannot be
assigned a \basevalueterm\ expression, since one cannot be statically inferred from the type of the
storage element.
This is produced by \TypingRuleRef{BaseValue}.

\hypertarget{def-bvet}{}
\item[$\BaseValueEmptyType$]
This error indicates that a storage element without a supplied initializing expression cannot be
assigned a \basevalueterm\ expression, since the static domain of the type of the storage element
is empty.
This is produced by \TypingRuleRef{BaseValue}.

\hypertarget{def-nrf}{}
\item[$\NonReturningFunction$]
This error indicates that a function contains a control-flow path that may not terminate by
either returning a value, throwing an exception, or executing \\
\texttt{Unreachable()} (see \TypingRuleRef{CheckStmtReturnsOrThrows}).

\hypertarget{def-bef}{}
\item[$\BuiltinExpectedToBeFunction$]
This error indicates an attempt to list a top-level declaration that is not a function
in the standard library
(see \nameref{sec:ASTRule.SetBuiltin}).

\hypertarget{def-upc}{}
\item[$\UnexpectedPendingConstrained$]
This error indicates that a \pendingconstrainedintegertype{} has been encountered where one is not permitted
(see \TypingRuleRef{TInt}).

\hypertarget{def-bitfieldsnotaligned}{}
\item[$\BitfieldsNotAligned$]
This error indicates that a pair of bitfields defined for a bitvector type exist in the same
scope, share the same name, but the slices they define for the containing bitvector type are
different
(see \TypingRuleRef{CheckCommonBitfieldsAlign}).

\item[$\BadPrintType$]%
\hypertarget{def-badprinttype}{}
  This error indicates that an argument passed to the functions \Tprint{} or
  \Tprintln{} is not singular (see \TypingRuleRef{SingularType}).
\hypertarget{def-cse}{}
\item[$\ConflictingSideEffects$]
This error indicates an attempt to combine two sets of \sideeffectdescriptorsterm\ where
a \sideeffectconflictterm\ exists
(see \TypingRuleRef{NonConflictingUnion}).

\end{description}

\section{Dynamic Error Codes}
\begin{description}
\hypertarget{def-unr}{}
\item[$\UnreachableError$]
This error results from evaluating an \texttt{Unreachable()} statement (see \SemanticsRuleRef{SUnreachable}).

\hypertarget{def-daf}{}
\item[$\DynamicAssertionFailure$]
This error results from evaluating an \texttt{assert} statement whose
conditions evaluates to $\False$ (see \SemanticsRuleRef{SAssert}).

\hypertarget{def-datc}{}
\item[$\DynamicTypeAssertionFailure$]
This error results from a failing type assertion (\texttt{$e$ as $t$})
(see \SemanticsRuleRef{ATC}).

\hypertarget{def-aet}{}
\item[$\ArbitraryEmptyType$]
This error occurs when an expression \texttt{$t$ : ARBITRARY} is evaluated
and $t$ has an empty domain (see \SemanticsRuleRef{EArbitrary}).

\end{description}
