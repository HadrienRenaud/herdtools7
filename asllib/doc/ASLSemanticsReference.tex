\documentclass{book}
\input{ASLmacros}

\newcommand\torexpr[0]{\textsf{rexpr}}
\newcommand\semantic[1]{\llbracket #1 \rrbracket}
\newcommand\tododefine[1]{\texttt{#1}}

\newcommand\xgraph[0]{\textsf{g}}
\newcommand\emptygraph[0]{\xgraph_{\emptyset}}
\newcommand\Nodes[0]{\mathcal{N}}
\newcommand\Read[0]{\text{Read}}
\newcommand\Write[0]{\text{Write}}
\newcommand\Labels[0]{\mathcal{L}}
\newcommand\XGraphs[0]{\mathcal{G}}
\newcommand\WriteEffect[0]{\textsf{WriteEffect}}
\newcommand\ReadEffect[0]{\textsf{ReadEffect}}

\newcommand\tenv[0]{\textsf{tenv}}
\newcommand\denv[0]{\textsf{denv}}
\newcommand\vals[0]{\mathcal{V}}
\newcommand\ordered[3]{{#1}\xrightarrow{#2}{#3}}
\newcommand\nvliteral[1]{\texttt{NV\_Literal}(#1)}
\newcommand\nvvector[1]{\texttt{NV\_Vector}(#1)}
\newcommand\nvrecord[1]{\texttt{NV\_Record}(#1)}

\newcommand\configmode[1]{\texttt{mode}({#1})}
\newcommand\graphof[1]{\texttt{graph}({#1})}
\newcommand\withgraph[2]{{#1}(\texttt{graph}\mapsto{#2})}
\newcommand\environof[1]{\texttt{environ}({#1})}
\newcommand\withenviron[2]{{#1}(\texttt{environ}\mapsto{#2})}

\newcommand\evalarrow[0]{\rightsquigarrow}
\newcommand\sslash[0]{\mathbin{/\mkern-6mu/}}
\newcommand\rightdownarrow[0]{\rotatebox[origin=c]{270}{$\Rsh$}}
\newcommand\terminateas[0]{\;\sslash\;}
\newcommand\ExprThrowsConfig[0]{\texttt{\#T}}
\newcommand\ErrorConfig[0]{\texttt{\#E}}
\newcommand\OrAbnormal[0]{\terminateas \ExprThrowsConfig, \ErrorConfig}

\newcommand\evalexpr[1]{\texttt{eval\_expr}(#1)}
\newcommand\evalexprsef[1]{\texttt{eval\_expr\_sef}(#1)}
\newcommand\evallexpr[1]{\texttt{eval\_lexpr}(#1)}
\newcommand\evalexprlist[1]{\texttt{eval\_expr\_list}(#1)}
\newcommand\evalexprlistm[1]{\texttt{eval\_expr\_list\_m}(#1)}
\newcommand\evalpattern[1]{\texttt{eval\_pattern}(#1)}
\newcommand\evallocaldecl[1]{\texttt{eval\_local\_decl}(#1)}
\newcommand\evalslices[1]{\texttt{eval\_slices}(#1)}
\newcommand\evalslice[1]{\texttt{eval\_slice}(#1)}
\newcommand\evalstmt[1]{\texttt{eval\_stmt}(#1)}
\newcommand\evalblock[1]{\texttt{eval\_block}(#1)}
\newcommand\evalloop[1]{\texttt{eval\_loop}(#1)}
\newcommand\evalfor[1]{\texttt{eval\_for}(#1)}
\newcommand\evalcatchers[1]{\texttt{eval\_catchers}(#1)}
\newcommand\evalfunc[1]{\texttt{eval\_func}(#1)}
\newcommand\evalconstraint[1]{\texttt{eval\_constraint}(#1)}
\newcommand\evalcall[1]{\texttt{eval\_call}(#1)}
\newcommand\evalmultiassignment[1]{\texttt{multi\_assign}(#1)}
\newcommand\rethrowimplicit[0]{\texttt{rethrow\_implicit}}

\newcommand\findfunc[0]{\texttt{find\_func}}
%\newcommand\baseval[0]{\textsf{base\_val}}
\newcommand\unknownval[0]{\texttt{unknown\_val}}
\newcommand\typesatisfies[0]{\texttt{type\_satisfies}}

\newcommand\exprvals[0]{\textsf{ExprVals}}
\newcommand\Normal[0]{\textsf{Normal}}
\newcommand\Throwing[0]{\textsf{Throwing}}
\newcommand\Continuing[0]{\textsf{Continuing}}
\newcommand\Returning[0]{\textsf{Returning}}
\newcommand\Error[0]{\textsf{Error}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Names for variables appearing in rules

\newcommand\newenv[0]{\texttt{new\_env}}
\newcommand\env[0]{\texttt{env}}
\newcommand\envone[0]{\texttt{env1}}
\newcommand\envtwo[0]{\texttt{env2}}
\newcommand\envthree[0]{\texttt{env3}}
\newcommand\envfour[0]{\texttt{env4}}
\newcommand\envp[0]{\texttt{env'}}
\newcommand\vc[0]{\texttt{c}}
\newcommand\ve[0]{\texttt{e}}
\newcommand\vi[0]{\texttt{i}}
\newcommand\vg[0]{\texttt{g}}
\newcommand\vgp[0]{\texttt{g'}}
\newcommand\vvp[0]{\texttt{v'}}
\newcommand\vep[0]{\texttt{e'}}
\newcommand\vm[0]{\texttt{m}}
\newcommand\vp[0]{\texttt{p}}
\newcommand\vv[0]{\texttt{v}}
\newcommand\vx[0]{\texttt{x}}
\newcommand\vs[0]{\texttt{s}}
\newcommand\vt[0]{\texttt{t}}
\newcommand\vvsg[0]{\texttt{vsg}}
\newcommand\vvs[0]{\texttt{vs}}
\newcommand\vms[0]{\texttt{ms}}
\newcommand\vle[0]{\texttt{le}}
\newcommand\vles[0]{\texttt{les}}
\newcommand\vre[0]{\texttt{re}}
\newcommand\vres[0]{\texttt{res}}
\newcommand\vvone[0]{\texttt{v1}}
\newcommand\vvtwo[0]{\texttt{v2}}
\newcommand\vsone[0]{\texttt{s1}}
\newcommand\vstwo[0]{\texttt{s2}}
\newcommand\vmone[0]{\texttt{m1}}
\newcommand\vmtwo[0]{\texttt{m2}}
\newcommand\veone[0]{\texttt{e1}}
\newcommand\vetwo[0]{\texttt{e2}}
\newcommand\vgone[0]{\texttt{g1}}
\newcommand\vgtwo[0]{\texttt{g2}}
\newcommand\vgthree[0]{\texttt{g3}}
\newcommand\vgfour[0]{\texttt{g4}}
\newcommand\ebv[0]{\texttt{e\_bv}}
\newcommand\mbv[0]{\texttt{m\_bv}}
\newcommand\mcond[0]{\texttt{m\_cond}}
\newcommand\vbv[0]{\texttt{v\_bv}}
\newcommand\mpositions[0]{\texttt{m\_positions}}
\newcommand\slices[0]{\texttt{slices}}
\newcommand\positions[0]{\texttt{positions}}
\newcommand\name[0]{\texttt{name}}
\newcommand\args[0]{\texttt{args}}
\newcommand\actualargs[0]{\texttt{actual\_args}}
\newcommand\namedargs[0]{\texttt{named\_args}}
\newcommand\params[0]{\texttt{params}}
\newcommand\earray[0]{\texttt{e\_array}}
\newcommand\eindex[0]{\texttt{e\_index}}
\newcommand\marray[0]{\texttt{m\_array}}
\newcommand\mindex[0]{\texttt{m\_index}}
\newcommand\varray[0]{\texttt{v\_array}}
\newcommand\vindex[0]{\texttt{v\_index}}
\newcommand\efields[0]{\texttt{e\_fields}}
\newcommand\names[0]{\texttt{names}}
\newcommand\fields[0]{\texttt{fields}}
\newcommand\vvfields[0]{\texttt{v\_fields}}
\newcommand\erecord[0]{\texttt{e\_record}}
\newcommand\vrecord[0]{\texttt{v\_record}}
\newcommand\fieldname[0]{\texttt{field\_name}}
\newcommand\elist[0]{\texttt{e\_list}}
\newcommand\vlist[0]{\texttt{v\_list}}
\newcommand\stm[0]{\texttt{stm}}
\newcommand\blockenv[0]{\texttt{block\_env}}
\newcommand\rearray[0]{\texttt{re\_array}}
\newcommand\rvarray[0]{\texttt{rv\_array}}
\newcommand\rmarray[0]{\texttt{rm\_array}}
\newcommand\rerecord[0]{\texttt{re\_record}}
\newcommand\rmrecord[0]{\texttt{rm\_record}}
\newcommand\rvrecord[0]{\texttt{rv\_record}}
\newcommand\vlelist[0]{\texttt{le\_list}}
\newcommand\vmlist[0]{\texttt{vm\_list}}
\newcommand\start[0]{\texttt{start}}
\newcommand\mstart[0]{\texttt{m\_start}}
\newcommand\vstart[0]{\texttt{v\_start}}
\newcommand\vend[0]{\texttt{v\_end}}
\newcommand\estart[0]{\texttt{e\_start}}
\newcommand\elength[0]{\texttt{e\_length}}
\newcommand\length[0]{\texttt{length}}
\newcommand\mlength[0]{\texttt{m\_length}}
\newcommand\vlength[0]{\texttt{v\_length}}
\newcommand\etop[0]{\texttt{e\_top}}
\newcommand\vvtop[0]{\texttt{v\_top}}
\newcommand\mtop[0]{\texttt{m\_top}}
\newcommand\efactor[0]{\texttt{e\_factor}}
\newcommand\mfactor[0]{\texttt{m\_factor}}
\newcommand\vfactor[0]{\texttt{v\_factor}}
\newcommand\range[0]{\texttt{range}}
\newcommand\ranges[0]{\texttt{ranges}}
\newcommand\ldi[0]{\texttt{ldi}}
\newcommand\ldis[0]{\texttt{ldis}}
\newcommand\liv[0]{\texttt{liv}}
\newcommand\minitopt[0]{\texttt{m\_init\_opt}}
\newcommand\les[0]{\texttt{les}}
\newcommand\exprs[0]{\texttt{exprs}}
\newcommand\wid[0]{\texttt{wid}}
\newcommand\es[0]{\texttt{es}}
\newcommand\ms[0]{\texttt{ms}}
\newcommand\body[0]{\texttt{body}}
\newcommand\dir[0]{\texttt{dir}}
\newcommand\catchers[0]{\texttt{catchers}}
\newcommand\otherwiseopt[0]{\texttt{otherwise\_opt}}
\newcommand\iswhile[0]{\texttt{is\_while}}
\newcommand\econd[0]{\texttt{e\_cond}}
\newcommand\condm[0]{\texttt{cond\_m}}
\newcommand\condv[0]{\texttt{cond\_v}}
\newcommand\condg[0]{\texttt{cond\_g}}
\newcommand\vindexname[0]{\texttt{index\_name}}
\newcommand\envthrow[0]{\texttt{env\_throw}}
\newcommand\envthrowone[0]{\texttt{env\_throw1}}
\newcommand\denvthrow[0]{\texttt{denv\_throw}}
\newcommand\sm[0]{\texttt{s\_m}}
\newcommand\sg[0]{\texttt{s\_g}}
\newcommand\ety[0]{\texttt{e\_ty}}
\newcommand\vvty[0]{\texttt{v\_ty}}
\newcommand\nameopt[0]{\texttt{name\_opt}}
\newcommand\vb[0]{\texttt{b}}
\newcommand\vbone[0]{\texttt{b1}}
\newcommand\vbtwo[0]{\texttt{b2}}
\newcommand\vps[0]{\texttt{ps}}
\newcommand\vbs[0]{\texttt{bs}}

\input{ASLSemanticsLines}

\setcounter{tocdepth}{1}

\newcommand{\testdir}{../tests/ASLSemanticsReference.t}

\author{Arm Architecture Technology Group}
\title{ASL Semantics Reference \\
       DDI 0621}
\begin{document}
\maketitle

\tableofcontents{}

\include{notice.tex}

\include{disclaimer.tex}

\chapter{Preamble}

The semantics of ASL defines all valid behaviors of a given ASL specification.
More precisely, an ASL specification is first parsed into an \emph{abstract syntax tree},
or AST, for short. Second, a type checker analyzes the \emph{parsed AST} for correctness and, if successful,
returns a \emph{static environment} and a \emph{typed AST}. Finally, tools such as interpreters and verifiers
can operate over the typed AST, based on the definition of the semantics, to test and analyze a given specification.

The abstract syntax, parsed AST, and typed AST are defined in the abstract syntax reference~\cite{ASLAbstractSyntaxReference}.
The ASL type system, which defines the set of parsed ASTs that are considered valid and how to
produce the corresponding typed ASTs and static environments is defined in the typing reference~\cite{ASLTypingReference}.

\paragraph{Basic Semantic Concepts.}
The semantics is constructively defined via \emph{configurations}, \emph{transitions}, and \emph{semantic rules}.
Intuitively, configurations represent intermediate states during the execution of a program and they encapsulate
the information needed to transition into other configurations.
Configurations include a \emph{dynamic environment}, which binds variables to values;
the typed AST node that needs to be ``evaluated''; a \emph{mode}, which distinguishes between different kinds of states, for example
states where an exception was raised and states where no exception was raised; a \herd\ \emph{execution graph} in the case of a
\emph{concurrent semantics}; and possible other bits of information, for example intermediate expression values.
Semantic rules define the set of possible transitions.

\paragraph{Execution.}
A valid execution of an ASL specification transitions from an \emph{initial configuration} to an output configuration.
Such a transition is defined by transitions over the AST nodes making up the specification.

\paragraph{Primitive Subprograms.}
The semantics of ASL is parameterized by a set of primitive subprograms ---
subprograms whose implementation is not defined by an ASL body and whose effect on the dynamic environment
is defined externally. Critically, access to memory is given by primitive subprograms.

We define two types of semantics --- a \emph{sequential semantics} and a \emph{concurrent semantics}.
Each semantics operates over a different kind of environment.

\paragraph{Sequential Semantics.}
The sequential semantics corresponds to executing an ASL specification in the context of a single (conceptual) process
of execution --- notice that ASL does not contain any concurrency constructs. Access to memory is hidden away
in primitive subprograms that interface with a map-like memory implementation that does not reorder memory accesses
and serves one access at a time.

\paragraph{Concurrent Semantics.}
The concurrent semantics extends the sequential semantics with \herd\ execution graphs.
Intuitively, these graphs define read and write effects to variables and constraints over those effects.
Together with the constraints that define the ARM memory model~\cite{AlglaveDGHM21}, these graphs axiomatically define
the valid sequences of read and write operations induced by a given specification.

\section{Mathematical Notations and Conventions}

\input{ASLNotations.tex}

\paragraph{OCaml-style Notations.}
We use the notation $L(v_{1..k})$, where $L$ is a label and $v_{1..k}$ is a (possibly-singleton) tuple of abstract values,
to denote the tuple $(L,v_{1..k})$.
We also write $L(T_{1..k})$, where $T_{1..k}$ denote mathematical type of values, to stand for
$\{L\} \times T_1 \times \ldots \times T_k$.
%
We later use these notations to define \emph{semantic configurations} and \emph{native values}, \underline{not to be confused with labelled AST nodes}.
%
The notation $\langle \cdot \rangle$ stands for empty-or-singleton sets, where $\None\triangleq\langle\rangle$ denotes
an empty set and $\langle v \rangle$ denotes a set containing the single element $v$.
%
The notation $\langle T \rangle$, where $T$ denotes a mathematical type of values, stands for
$\{ \langle\rangle \} \cup \{\langle v \rangle \;|\; v \in T\}$.

\paragraph{Misclleaneous.}
We define the following shorthand notations for the true and false expressions:
\newcommand\etrue[0]{\texttt{ETrue}}
\newcommand\efalse[0]{\texttt{EFalse}}
\[
\begin{array}{rcl}
  \etrue &\triangleq& \texttt{E\_Literal}(\texttt{L\_Bool}(\texttt{True}))\\
  \efalse &\triangleq& \texttt{E\_Literal}(\texttt{L\_Bool}(\texttt{False}))\\
\end{array}
\]

We write $Z(z)$ as a shorthand for an integer $\nvliteral{\lint(z)}$,
$B(b)$ as a shorthand for a Boolean native value $\nvliteral{\lbool(b)}$,
and $R(r)$ for a real native value $\nvliteral{\lreal(r)}$.

\section{Configurations}

Configurations express intermediate states related by \emph{semantic transitions}.
Configurations wrap together elements such as environments and AST nodes
and associate them with a \emph{mode}, which helps determine how to semantic transitions.
%
More precisely, semantic transitions relate two sets of configurations ---
\emph{input configurations} and \emph{output configurations}.
Input configurations consist of an environment and an AST node.
Output configurations consist of an output environment, values,
and \herd\ execution graphs.

We now explain the components appearing in configurations.

\subsection{Native Values}
The semantics of an ASL specification associates \emph{native values} to variables.
The set of native values is the minimal set defined by the following recursive rules (\texttt{NV} stands for Native Value):
\begin{mathpar}
  \inferrule[Basis Set: Integers, Reals, Booleans, Strings, and Bitvectors]{\vv \in \literal}
  { \nvliteral{v} \in \vals }
  \and
  \inferrule[Tuple Values and Array Values]{i=1..k: v_i \in \vals}
  { \nvvector{v_{1..k}} \in \vals }
  \and
  \inferrule[Record Values]{i=1..k: \id_i \in \identifier \\ i=1..k: v_i \in \vals}
  { \nvrecord{[i=1..k: \id_i\mapsto v_i]} \in \vals }
\end{mathpar}

\subsection{Dynamic Environments}

A \emph{sequential dynamic environment}, or \emph{dynamic environment}, for short, is a structure which,
amongst other things, associates native values to variables.
Formally, a sequential environment $\denv \in \dynamicenvs$ is a pair consisting of a partial function from global
variable names to their native value, and a partial function from local variable names to their
native values:
\[
\begin{array}{rcl}
  \dynamicenvs          &\triangleq&  \mathbb{G} \times \mathbb{L} \\
  \mathbb{G}            &\triangleq&  (\identifier \partialto \vals) \\
  \mathbb{L}            &\triangleq&  (\identifier \partialto \vals) \\
\end{array}
\]

The native value associated with a variable $\vx$ in an environment $\denv = (G^\denv, L^\denv)$,
denoted as $\denv[\vx]$, is defined as follows:
\begin{mathpar}
  \denv[\vx] \triangleq
    \left\{
      \begin{array}{ll}
        G^\denv(\vx) & \text{if}\ \vx \in \dom(G^\denv) \\
        L^\denv(\vx) & \text{otherwise} \\
      \end{array}
    \right.
\end{mathpar}
We note that this function will always be well-defined in our semantics, since the typed AST
disallows referencing variables that have not been declared, and we will only reference a local
variable in the context of the function containing it.

Updating the native value of a variable $\vx$ to $\vv$ in an an environment $\denv$, denoted as
$\denv[\vx \mapsto \vv]$, is defined as follows:
%
\begin{mathpar}
  \denv[\vx \mapsto \vv] \triangleq
    \left\{
      \begin{array}{ll}
        (G^\denv[\vx \mapsto v], L^\denv) & \text{if}\ \vx \in \dom(G^\denv) \\
        (G^\denv, L^\denv[\vx \mapsto \vv]) & \text{otherwise} \\
      \end{array}
    \right.
\end{mathpar}

% Furthermore, $v?$ refers to $v$ or $\bot$, and the usage of $v$ without a
% question mark implies that $v \neq \bot$.

\subsection{Static Environments}

A \emph{static environment} $\tenv \in \staticenvs$ (also referred to as a \emph{type environment})
is produced by the type-checker from the parsed AST.
%
The ASL semantics requires a static environment in order to select the right catch clause for a thrown exception
and find the AST for a called subprogram from its name:
\[
  \begin{array}{rcl}
    \findfunc       &:& \staticenvs \times \identifier \partialto \subprogrambody\\
 %   \baseval       &:& \ty \partialto \vals\\
    \typesatisfies  &:& \staticenvs \times (\ty \times \ty) \rightarrow \{\True, \False\}
  \end{array}
\]
The partial function $\findfunc$ returns the typed AST of the subprogram for a given identifier, or $\bot$,
if none exists. Recall that ASL allows subprogram overloading.
We assume that the typed AST renames each function uniquely so that it can be accessed based
on its name alone.
%
The function $\typesatisfies(\texttt{t}, \texttt{s})$ returns true if the type \texttt{t} type-satisfies the type \texttt{s}.

Environments simply pair static environments with dynamic environments:
$\envs = \staticenvs \times \dynamicenvs$. We write $\env \in \envs$ to range over environments.
%
We note that our semantics always maintains the same static environment.

\subsection{Execution Graphs}

The concurrent semantics of an ASL specification utilizes \herd\ \emph{execution graphs}~\cite{AlglaveDGHM21},
which track the read/write effects over variables, yielded by the sequential semantics, and the \emph{ordering constraints}
between those effects.

Formally, an execution graph $\xgraph = (N^\xgraph, E^\xgraph, O^\xgraph) \in \XGraphs$
is defined via a set of \emph{nodes} ($N^\xgraph$), \emph{edges} ($E^\xgraph$), and \emph{output nodes} ($O^\xgraph$):
\[
\begin{array}{rcl}
  \XGraphs   	    &\triangleq& \pow{\Nodes} \times \pow{\Nodes \times \Nodes \times \Labels} \times \Nodes  \\
  \Nodes            &\triangleq& \N \times \{ \Read, \Write \} \times \identifier \\
  \Labels           &\triangleq& \{ \asldata, \aslctrl, \aslpo \}
\end{array}
\]

Nodes represent unique read/write effects. Formally, a node $(u,l,\id)$ associates a unique instance counter $u$
to an \emph{ordering label} $l$, which specifies whether it represents a read or write effect to a variable named $\id$.

An edges represents an ordering constraint between two effects, which can be one of the following:
\begin{description}
\item[$\asldata$] Represents a \emph{data dependency}.
That is, when a write effect reads/write over the data written by another write effect.
\item[$\aslctrl$] Represents a \emph{control dependency}.
That is, when a read effect to a variable determines the flow of control (e.g., which condition of a branch is taken),
which then leads to another read/write effect.
\item[$\aslpo$] Represents a \emph{program order}.
That is, when two effects are defined to be ordered according to the sequential semantics of the program.
\end{description}

An execution graph is \emph{well-formed} if all nodes have unique instance counters, edges connect graph nodes,
and the output nodes are contained in the set of nodes:
\[
  \begin{array}{rcl}
  \forall n, n' \in N^\xgraph &.& n=(u,l,\id) \wedge n=(u',l',\id') \;\Rightarrow\; u \neq u' \\
  \forall e \in E^\xgraph &.& e=(n, n', l) \;\Rightarrow\; n, n' \in N^\xgraph \\
  & & O^\xgraph \subseteq N^\xgraph \enspace.
  \end{array}
\]

We denote the empty execution graph $\emptygraph \triangleq (\emptyset, \emptyset, \emptyset)$.
%
We define the following functions, which return an execution graph that represents a single read/write effect to a variable \texttt{x}:
\[
  \begin{array}{rclll}
    \WriteEffect(\texttt{x}) &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Write, \texttt{x}), & u\in\N \text{ is fresh}\\
    \ReadEffect(\texttt{x})  &\triangleq& (\{n\}, \emptyset, \{n\}) & \text{where } n=(u, \Read, \texttt{x}),   & u\in\N \text{ is fresh}\\
  \end{array}
\]

We also define two ways to combine execution graphs --- \emph{unordered combination} and \emph{ordered combination}.

Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ their unordered combination,
denoted $S_1 \parallel S_2$ is defined as follows:
\[
  S_1 \parallel S_2\triangleq (N_1 \cup N_2, E_1 \cup E_2, O_1 \cup O_2) \enspace.
\]
Intuitively, this combination conveys the fact that there are no ordering constraints between the effects
in the arguments graphs.

Given two execution graphs $S_1 = (N_1, E_1, O_1)$ and $S_1 = (N_2, E_2, O_2)$ and an ordering label $l$,
the ordered combination $\ordered{S_1}{l}{S_2}$ is defined as follows:
\[
  \ordered{S_1}{l}{S_2} \triangleq (N_1 \cup N_2, E_1 \cup E_2 \cup (O_1 \times N_2 \times \{l\}, O_2)) \enspace.
\]
Intuitively, this combination constrains the output effects of $S_1$ to appear before any effect of $S_2$ with respect
to the given ordering label.

\subsection{Input Configurations and Output Configurations}

Each input configuration corresponds to a group of AST node types that is associated with a corresponding
label, for example the label \texttt{expr} corresponds to the semantic relation for the expression AST node type.
We write $\texttt{label}(n)$ to denote that an AST node $n$ belongs to label \texttt{label}.
%
We use configuration modes of the form $\texttt{eval\_label}$ for input configurations to express the intuition
that the input configuration $\texttt{eval\_label}(\env, n)$, where $\env$ is an environment
and $n$ belongs to \texttt{label},
should be ``semantically evaluated'' (to yield an output configuration $L'(v'_{1..n})$).

ASL semantics mainly utilizes the following types of output configurations:
\begin{description}
  \item[Normal Values.] Configurations representing intermediate results
  (values and/or mutated environments) generated while evaluating statements:
  \begin{itemize}
  \item $\Normal(\vals \times \XGraphs)$,
  \item $\Normal((\vals \times \XGraphs), \envs)$,
  \item $\Normal(((\vals \times \vals)^* \times \XGraphs), \envs)$,
  \item $\Normal(\XGraphs, \envs)$, and
  \item $\Normal((\vals^* \times \XGraphs), \envs)$.
  \end{itemize}

  \item[Exceptions.] Configurations in $\Throwing((\langle\vals \times \ty\rangle \times \XGraphs, \envs)$
  represent thrown exceptions,
  either without an exception value (as in \texttt{throw;}) or ones with an exception value and an associated type.

  \item[Returned Values.] Configurations in $\Returning((\vals^* \times \XGraphs), \envs)$
  represent values being returned by the currently executing subprogram
  (which might be tuples of values).

  \item[Subprogram In-flight.] Configurations in $\Continuing(\XGraphs, \envs)$
  represent the fact that a subprogram has more statements to execute.

  \item[Dynamic Errors.] Configurations in $\Error(\texttt{<string>})$
  represent runtime errors (for example, division by zero).
  The actual strings in an error configuration are not considered part of the specification.
  That is, an implementation of the semantics may use other strings.
\end{description}

We refer to configurations with the $\Throwing$ mode and $\Error$ mode as \emph{abnormal configurations}.

\subsection{Extracting and Substituting Elements of Configurations}

We define the \emph{mode} of a configuration $C=M(\ldots)$, denoted $\configmode{C}$, as the mode label $M$.

Given a configuration $C$, we define the the graph component of the configuration, $\graphof{C}$,
and the environment of the configuration, $\environof{C}$, as follows:
\[
\begin{array}{lcc}
  C & \graphof{C} & \environof{C}\\
  \hline
  \Normal(\vv,\vg) & \vg & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \vg & \env\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \vg & \env\\
  \Normal(\vg, \env) & \vg & \env\\
  \Normal(i=1..k: \vv_i, \vg) & \vg & \env\\
  \Throwing((\vx,\vg), \env) & \vg & \env\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \vg & \env\\
  \Continuing(\vg, \env) & \vg & \env\\
\end{array}
\]

Given a configuration $C$, we define $\withgraph{C}{\vgp}$ to be a configuration
like $C$ where the graph component is substituted with $\vgp$:
\[
\begin{array}{ll}
  C & \withgraph{C}{\vgp}\\
  \hline
  \Normal(\vv,\vg) & \Normal(\vv,\vgp)\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vgp), \env)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vgp), \env)\\
  \Normal(\vg, \env) & \Normal(\vgp, \env)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vgp)\\
  \Throwing((\vx,\vg), \env) & \Throwing((\vx,\vgp), \env)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vgp), \env)\\
  \Continuing(\vg, \env) & \Continuing(\vgp, \env)\\
\end{array}
\]
Similarly, we define the $\withenviron{C}{\envp}$ to be a configuration
like $C$ where the environment component, if one exists, is substituted with $\envp$:
\[
\begin{array}{ll}
  \textbf{Configuration} & \withenviron{C}{\envp}\\
  \hline
  \Normal(\vv,\vg) & \text{undefined}\\
  \Normal((\vv,\vg), \env) & \Normal((\vv,\vg), \envp)\\
  \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \env) & \Normal((i=1..k: (\texttt{va}_i,\texttt{vb}),\vg), \envp)\\
  \Normal(\vg, \env) & \Normal(\vg, \envp)\\
  \Normal(i=1..k: \vv_i, \vg) & \Normal(i=1..k: \vv_i, \vg)\\
  \Throwing((\vx,\vg), \env) & \Throwing((\vx,\vg), \envp)\\
  \Returning((i=1..k: \vv_i,\vg), \env) & \Returning((i=1..k: \vv_i,\vg), \envp)\\
  \Continuing(\vg, \env) & \Continuing(\vg, \envp)\\
\end{array}
\]

\section{Semantic Evaluation}

The semantics of the various types of AST nodes is given by a set of \emph{semantic relations} between
input configurations and output configurations.
The reason that relations, rather than functions, are used is due to the
non-determinism inherent in the \texttt{UNKOWN} expression,
the choice of execution graph node identifiers,
and potential non-determinism in the primitive subprograms.

\newcommand\TError[0]{\textsf{TError}}
\newcommand\TNormal[0]{\textsf{TNormal}}
\newcommand\TThrowing[0]{\textsf{TThrowing}}
\newcommand\TContinuing[0]{\textsf{TContinuing}}
\newcommand\TReturning[0]{\textsf{TReturning}}
\newcommand\TConfig[0]{\textsf{TConfig}}
We define the following shorthands for the types of different configurations:
\[
  \begin{array}{rcl}
    \TNormal        &\triangleq& \Normal(\XGraphs, \envs)\\
    \TNormal(\vals)   &\triangleq& \Normal((\vals \times \XGraphs), \envs)\\
    \TNormal((\vals \times \vals)^*)   &\triangleq& \Normal(((\vals \times \vals)^* \times \XGraphs), \envs)\\
    \TNormal(\vals^*) &\triangleq& \Normal((\vals^* \times \XGraphs), \envs)\\
    \TThrowing        &\triangleq& \Throwing(\langle\vals \times \ty\rangle \times \XGraphs, \envs)\\
    \TContinuing      &\triangleq& \Continuing(\XGraphs, \envs)\\
    \TReturning       &\triangleq& \Returning((\vals^* \times \XGraphs), \envs)\\
    \TError           &\triangleq& \Error(\texttt{<string>})\\
    \hline
    \TConfig          &\triangleq& \TNormal \cup \TNormal(\vals) \cup \TNormal((\vals \times \vals)^*) \cup \\
    & & \TNormal(\vals^*) \cup \TThrowing \cup \TContinuing \cup \\
    & & \TReturning \cup \TError
  \end{array}
\]

ASL defines the following relations between input configurations and output configurations
for the corresponding labels (input configurations reference AST elements~\cite{ASLAbstractSyntaxReference}
\expr, \lexpr, \stmt, \slice, \localdeclitem, \identifier, \fordirection, and \catcher):

\begin{tabular}{ll}
  \textbf{\texttt{label}} & \textbf{Input Configurations $\bigtimes$} \\
                          & \textbf{Output Configurations} \\
  \hline
  \hline
  \texttt{expr}         & $\evalexpr{\envs \times \expr} \bigtimes$\\
                        & $\TNormal(\vals) \cup \TThrowing \cup \TError$\\
  \hline
  \texttt{lexpr}        & $\evallexpr{\envs \times \lexpr \times (\vals \times \XGraphs)} \bigtimes$\\
                        & $\TNormal \cup \TThrowing \cup \TError$\\
  \hline
  \texttt{slices}       & $\evalslices{\envs \times \slice^*} \bigtimes$\\
                        & $\TNormal((\vals \times \vals)^*) \cup \Throwing \cup \TError$ \\
  \hline
  \texttt{pattern}      & $\evalpattern{\envs \times \vals \times \pattern} \bigtimes$\\
                        & $\TNormal(\vals)$ \\
  \hline
  \texttt{local\_decl}  & $\evallocaldecl{\envs \times \localdeclitem \times \langle\vals\times\XGraphs\rangle} \bigtimes$\\
  & $\TNormal$ \\
  \hline
  \texttt{stmt}         & $\evalstmt{\envs \times \stmt} \bigtimes$\\
                        & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
  \hline
  \texttt{block}        & $\evalblock{\envs \times \stmt} \bigtimes$\\
                        & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
  \hline
  \texttt{loop}         & $\evalloop{\envs \times \{\True,\False\} \times \expr \times \stmt} \bigtimes$\\
                        & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
  \hline
  \texttt{for}          & $\evalfor{\envs \times \identifier \times \vals \times \fordirection \times \vals} \bigtimes$\\
                        & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
  \hline
  \texttt{catchers}     & $\evalcatchers{\envs \times \catcher^* \times \langle\stmt\rangle \times \TConfig} \bigtimes$\\
                        & $\TReturning \cup \TContinuing \cup \TThrowing \cup \TError$ \\
  \hline
  \texttt{func}         & $\evalfunc{\envs \times \identifier \times (\vals \times \XGraphs)^* \times (\identifier\times\vals)^*} \bigtimes$ \\
                        & $\TNormal(\vals^*) \cup \TThrowing \cup \TError$ \\
  \end{tabular}

  We use the notation $C \evalarrow C'$ for an element of a semantic relation.
%  We denote elements of a semantic relation by $\texttt{eval\_<label>}(\env, n) \evalarrow L'(v'_{1..n})$.
%We define the semantic relation $\semantic{\texttt{label}}$, for each label, as
% the set of all its semantic transitions:
% \[
%   \semantic{\texttt{label}} \triangleq \{ \texttt{eval\_<label>}(\env, n) \evalarrow L'(v'_{1..n})  \;|\;
% \env \in \envs,\; \texttt{label}(n) \} \enspace.
% \]

\subsection{Natural Semantics.}
We define semantic relations using semantic rules, which are defined inductively over the structure of AST nodes.
That is, a rule defining a semantic transition for a non-leaf AST node is defined in terms semantic transitions for its children nodes.
%
% When a semantic transition $\texttt{eval\_label}(\env, n) \evalarrow C$ is determined to take place according
% to the rules of the semantics we will say that $\texttt{eval\_label}$ \emph{evaluates} the environment \env\
% and node $n$ and returns the configuration $C$.
This style of semantics is known as \emph{natural semantics}~\cite{SemanticsWithApplicationsBook} (or \emph{big-step semantics}).
%
One implication of utilizing this style of semantics is that non-terminating loops and non-terminating
recursive subprograms calls are not assigned any meaning as there are no semantic transitions that they can take.

\subsubsection{Evaluation Example}

The example shows how the rules for expression literals and binary operator expressions can be combined
to infer a transition from an input configuration with a compound expression to an output configuration
with the value resulting from the intuitive calculation of the expression.

\newcommand\emptyenv[0]{\underline{e}}

For succinctness, we write $E(\texttt{<expression>})$
for the AST node parsed from an expression $\texttt{<expression>}$.
We also replace $v=\texttt{apply\_binop}(\op, v_1, v_2)$ with the shorter $v=v_1 \op\ v_2$.
%
We write $\emptyenv$ to stand for a trivial environment (that is, one where all mappings are empty functions).

Notice that, we have dropped the execution graph component and simplified pairs of the form $(v,g)$,
where $v$ is a native value and $g$ is an execution graph, to just $v$.
This is because we are interested in demonstrating the sequential semantics (also, the execution graphs
in this case are all empty).

\begin{tiny}
\begin{mathpar}
  \inferrule*{
  \inferrule*{
    \inferrule*{}{ \evalexpr{\emptyenv, E(1)} \evalarrow \Normal(Z(1), \emptyenv) } \\\\
    \inferrule*{}{ \evalexpr{\emptyenv, E(2)} \evalarrow \Normal(Z(2), \emptyenv) } \\\\
    Z(3) = Z(1)\texttt{+}Z(2)
  }
  {
    \evalexpr{ \emptyenv, E(1+2) } \evalarrow
    \Normal(Z(3), \emptyenv)
  }
  \\
  \inferrule*{
    \inferrule*{}{ \evalexpr{\emptyenv, E(4)} \evalarrow \Normal(Z(4), \emptyenv) } \\\\
    \inferrule*{}{ \evalexpr{\emptyenv, E(5)} \evalarrow \Normal(Z(5), \emptyenv) } \\\\
    Z(9) = Z(4)\texttt{+}Z(5)
  }
  {
    \evalexpr{ \emptyenv, E(4+5) } \evalarrow
    \Normal(Z(9), \emptyenv)
  }
  \\
  Z(27) = Z(3)\texttt{*}Z(9)
  }
  {
    \evalexpr{ \emptyenv, E((1+2)*(4+5)) } \evalarrow
    \Normal(Z(27), \emptyenv)
  }
  \end{mathpar}
\end{tiny}

\subsubsection{No Undefined Behaviors.}
Our semantics is defined for well-typed ASL specifications.
Our semantics gets stuck only in cases of non-terminating executions
(for example, non-terminating loops, or infinite recursion).
Otherwise, for every input configuration there is at least one rule that can be used to take a semantic transition.

\subsection{Short-Circuit Rule Templates}

Short-circuit rule templates allow us to succinctly define sets of rules.
Specifically, they allow us to capture situations where if a transition
into an output configuration occurs in a premise then the rest of the rule
can be ignored as the input configuration in the verdict also transitions
into that output configuration. These output configurations are usually
due to raised exceptions or dynamic errors.

A template rule:
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}

Stands for the following pair of rules (the second of which is possibly a template rule itself):
\begin{mathpar}
  \inferrule[(Short-circuited)]{
    i=1..k: P_i\\\\
    C \evalarrow E
  }
  {
    D \evalarrow E
  }
\and
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}

We allow several short-cirtcuiting configurations in a template.
Specifically, a template rule:
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E_{1...m}\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\end{mathpar}
Stands for the set of template rules
\begin{mathpar}
  \inferrule{
    i=1..k: P_i\\\\
    C \evalarrow C' \terminateas E_1\\\\
    j=1..n: Q_i\\
  }
  {
    D \evalarrow D'
  }
\and
\inferrule{\ldots}{}
\and
\inferrule{
  i=1..k: P_i\\\\
  C \evalarrow C' \terminateas E_m\\\\
  j=1..n: Q_i\\
}
{
  D \evalarrow D'
}
\end{mathpar}

We introduce the following shorthands for abnormal configurations:
$\ExprThrowsConfig \triangleq \Throwing((\vv, \vg), \newenv)$
and $\ErrorConfig \triangleq \Error(\vs)$.

\subsection{ASL Semantic Rules}

The set of ASL semantic rules is grouped by labels as follows:

\begin{tabular}{lll}
\textbf{\texttt{label}} & \textbf{Description} & \textbf{Chapter/Section} \\
\hline
\texttt{expr} & Expressions & Chapter~\ref{chap:eval_expr}\\
\texttt{lexpr} & Left-hand sides of assignments & Chapter~\ref{chap:eval_lexpr}\\
\texttt{slices} & Slices & Chapter~\ref{chap:eval_slices}\\
\texttt{pattern} & Patterns & Chapter~\ref{chap:eval_pattern}\\
\texttt{local\_decl} & Local declarations & Chapter~\ref{chap:eval_local_decl}\\
\texttt{stmt} & Statements & Chapter~\ref{chap:eval_stmt}\\
\texttt{block} & Statement blocks & Chapter~\ref{chap:eval_block}\\
\texttt{loop} & \texttt{while} and \texttt{repeat} loops & Section~\ref{sec:SemanticsRule.Loop}\\
\texttt{for} & \texttt{for} loops & Section~\ref{sec:SemanticsRule.For}\\
\texttt{catchers} & Exception catchers & Chapter~\ref{chap:eval_catchers}\\
\texttt{func} & Subprograms & Chapter~\ref{chap:eval_func}
\end{tabular}\\

\chapter{Reading guide}

The set of rules for each label is further split according to the the ``shape'' of the AST node.
For example, expressions are split into literal expressions, binary operation expressions, etc.
Each such subset of rules is named accordingly and appears in a section with the same name.
For example, the rule for literal expressions is named SemanticsRule.Lit and defined in
Section~\ref{sec:SemanticsRule.Lit}.

Each rule is presented using the following template:
\begin{itemize}
\item a Prose paragraph gives the rule in English, and corresponds, as much as possible, to the code of the reference implementation ASLRef given at
 \url{~/herdtools7/asllib};
\item one or several Example, which as much as possible are also given as regression tests in \url{~/herdtools7/asllib/tests/ASLSemanticsReference.t}
\item a Code paragraph which gives a verbatim of the corresponding implementation in the interpreter of ASLRef \url{~/herdtools7/asllib/Interpreter.ml};
\item a Formal paragraph, which provides semantic rules that essentially give the same information as the Prose paragraph, for both
the sequential semantics and the concurrent semantics, in the form of \herd\ \emph{execution graphs}.
The latter enable building, for each AArch64 instruction,
the Intrinsic dependencies used by the AArch64 memory model from the ASL code of the instruction.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Expressions \label{chap:eval_expr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will use $M$ to range over the modes $\Normal$ and $\Throwing$.
We will say that a semantic transition \emph{terminates normally} when the mode of the output configuration is $\Normal$,
\emph{terminates exceptionally} when the mode of the output configuration is $\Throwing$,
\emph{terminates erroneously} when the mode of the output configuration is $\Error$,
and \emph{terminates abnormally} when it either terminates exceptionally or erroneously.

A semantic transition for an expression $\ve$ in an environment $\env$ is
a native value $\vv$ coupled with an execution graph $\vg$,
and a potentially updated environment $\newenv$,
denoted as $\evalexpr{\env, \ve} \evalarrow M((\vv, \vg), \newenv)$,
and $\vv$ is either a native value (when $M=\Normal$), an empty set (when $M=\Throwing$), or a singleton set (when $M=\Throwing$)
with an exception native value with its type, and one of the following applies:
\begin{itemize}
\item SemanticsRule.Lit (see Section~\ref{sec:SemanticsRule.Lit});
\item SemanticsRule.ELocalVar (see Section~\ref{sec:SemanticsRule.ELocalVar})
\item SemanticsRule.EGlobalVar (see Section~\ref{sec:SemanticsRule.EGlobalVar})
\item SemanticsRule.BinopAnd (see Section~\ref{sec:SemanticsRule.BinopAnd})
\item SemanticsRule.BinopOr (see Section~\ref{sec:SemanticsRule.BinopOr})
\item SemanticsRule.BinopImpl (see Section~\ref{sec:SemanticsRule.BinopImpl})
\item SemanticsRule.Binop (see Section~\ref{sec:SemanticsRule.Binop})
\item SemanticsRule.Unop (see Section~\ref{sec:SemanticsRule.Unop})
\item SemanticsRule.ECond (see Section~\ref{sec:SemanticsRule.ECond})
\item SemanticsRule.ESlice (see Section~\ref{sec:SemanticsRule.ESlice})
\item SemanticsRule.ECall (see Section~\ref{sec:SemanticsRule.ECall})
\item SemanticsRule.EGetArray (see Section~\ref{sec:SemanticsRule.EGetArray})
\item SemanticsRule.ERecord (see Section~\ref{sec:SemanticsRule.ERecord})
\item SemanticsRule.EGetField (see Section~\ref{sec:SemanticsRule.EGetField})
\item SemanticsRule.EConcat (see Section~\ref{sec:SemanticsRule.EConcat})
\item SemanticsRule.ETuple (see Section~\ref{sec:SemanticsRule.ETuple})
\item SemanticsRule.EUnknown (see Section~\ref{sec:SemanticsRule.EUnknown})
\item SemanticsRule.EPattern (see Section~\ref{sec:SemanticsRule.EPattern})
\item SemanticsRule.CTC (see Section~\ref{sec:SemanticsRule.CTC})
\end{itemize}

\section{Evaluating Lists of Expressions}

We define the following helper rule for evaluating a list of expresions $\vle$ in an environment $\env$,
with no dependencies between the graphs generated by the evaluation of the individual sub-expressions.
(Recall that $+$ stands for list concatenation.)
\begin{mathpar}
  \inferrule[(Empty List)]{}
  {
    \evalexprlist{\env, \emptylist} \evalarrow \Normal((\emptylist, \empty), \env)
  }
\and
  \inferrule[(Non-empty List)]{
    \texttt{le} = [\ve] + \vle'\\
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envp) \OrAbnormal\\
    \evalexprlist{\envp, \vle'} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\
    \vg = \vgone \parallel \vgtwo \\
    \vv = [\vvone] + \vvs
  }
  {
    \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}

We also define the following helper rule for evaluating a list of expresions $\vle$ in an environment $\env$,
and returning a list of values associated with graphs:
\begin{mathpar}
  \inferrule[(Empty List)]{}
  {
    \evalexprlistm{\env, \emptylist} \evalarrow \Normal((\emptylist, \empty), \env)
  }
\and
  \inferrule[(Non-empty List)]{
    \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envp) \OrAbnormal\\
    \evalexprlistm{\envp, \vle} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  }
  {
    \evalexprlistm{\env, [\ve] + \vle} \evalarrow \Normal([\vm] + \vms), \newenv)
  }
\end{mathpar}

\section{Evaluating Side-effect-free Expressions}
We define the helper relation $\texttt{eval\_expr\_sef} : (\envs \times \expr) \times (\TNormal(\vals) \cup \TError)$,
which specializes the expression evaluation relation for side-effect-free expressions:
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \terminateas \ErrorConfig
  }
  {
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
  }
\end{mathpar}

\section{SemanticsRule.Lit \label{sec:SemanticsRule.Lit}}

  \subsection{Prose}
  Evaluation of a literal expression of a value \texttt{v}
  in environment \env\ is the configuration
  \texttt{\Normal(res,env,g)} and all of the following apply:
  \begin{itemize}
  \item \texttt{res} is the native value corresponding to \texttt{v};
  \item \texttt{g} is the empty graph, as literal do not yield any read/write effects.
  \end{itemize}

  \subsection{Example}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Lit.asl}
  the expression \texttt{3} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LitBegin, lastline=\LitEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\vres = \nvliteral{\vv} \\ \vg = \emptygraph}
  { \evalexpr{\env, \texttt{E\_Literal}(\vv)} \evalarrow \Normal(\vres, \env, \vg) }
\end{mathpar}

\end{formal}

\isempty{\subsection{Comments}}


\section{SemanticsRule.ELocalVar \label{sec:SemanticsRule.ELocalVar}}

  \subsection{Prose}
  Let \texttt{e} be an expression denoting a variable \texttt{x}.
  Evaluation of \texttt{e} under environment \texttt{env} terminates normally with
  \texttt{((v,g),env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{x} which is bound locally in \texttt{env};
  \item \texttt{v} is the native value of \texttt{x} in \texttt{env};
  \item \texttt{g} is the graph containing a single read effect for \texttt{x}.
  \end{itemize}

  \subsection{Example: SemanticsRuleELocalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ELocalVar.asl}
    the evaluation of \texttt{x} within \texttt{assert x == 3;} uses SemanticsRule.ELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\ELocalVarBegin, lastline=\ELocalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{\env=(\tenv, \denv)\\
    \vv = \denv[\vx] \\ \vg = \ReadEffect(\vx)}
  {\evalexpr{\env, \evar(\vx)} \evalarrow \Normal((\vv, \vg), \env)}
  \end{mathpar}
\end{formal}

  \subsection{Comments}
  When there exists a global variable called \texttt{x} then an ASL program
  cannot use the name \texttt{x} as a local variable. ASLRef checks that this
  property, sometimes called ``banning shadowing'', holds at type-checking time.

\section{SemanticsRule.EGlobalVar \label{sec:SemanticsRule.EGlobalVar}}

  \subsection{Prose}
  Let \texttt{e} be an expression denoting a variable \texttt{x}.
  Evaluation of \texttt{e} under environment \texttt{env} terminates normally with
  \texttt{((v,g),env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{x} which is bound globally in \texttt{env};
  \item \texttt{v} is the native value of \texttt{x} in \texttt{env};
  \item \texttt{g} is the graph containing a single read effect for \texttt{x}.
  \end{itemize}

  \subsection{Example: SemanticsRuleEGlobalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGlobalVar.asl}
    the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
    uses the rule SemanticsRule.EGlobalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\EGlobalVarBegin, lastline=\EGlobalVarEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
Due to how $\denv[\cdot]$ distinguishes between local variables and global variables,
we can use the same rule as for local variable expressions:
  \begin{mathpar}
  \inferrule{
    \env=(\tenv, \denv)\\
    \vv = \denv[\vx] \\ \vg = \ReadEffect(\vx)}
  {\evalexpr{\denv, \evar(\vx)} \evalarrow \Normal((\vv, \vg), \env)}
  \end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.BinopAnd \label{sec:SemanticsRule.BinopAnd}}

  \subsection{Prose}
  An expression \texttt{e}, which denotes a logical conjunction of two expressions \texttt{e1} and \texttt{e2},
  is evaluated as \texttt{if e1 then e2 else false} (see Section~\ref{sec:SemanticsRule.ECond}).

  \subsection{Example: SemanticsRule.EBinopAndFalse.asl}

 \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopAndFalse.asl}
    the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopAndBegin, lastline=\BinopAndEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \texttt{e2}, \efalse)} \evalarrow C
  }
  {
  \evalexpr{\env, \texttt{E\_Binop}(\texttt{BAND}, \texttt{e1}, \texttt{e2})} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopOr \label{sec:SemanticsRule.BinopOr}}
  \subsection{Prose}
  An expression \texttt{e}, which denotes a logical disjunction over two expressions \texttt{e1} and \texttt{e2},
  is evaluated as \texttt{if e1 then true else e2} (see Section~\ref{sec:SemanticsRule.ECond}).

  \subsection{Example: SemanticsRule.EBinopOrTrue.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopOrTrue.asl}
  The expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopOrBegin, lastline=\BinopOrEnd]{../Interpreter.ml}

\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \etrue, \texttt{e2})} \evalarrow C
    }
    {
    \evalexpr{\env, \texttt{E\_Binop}(\texttt{BAND}, \texttt{e1}, \texttt{e2})} \evalarrow C
    }
  \end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{BKNT}, \identr{XKGC} and \identi{QRXP}.

\section{SemanticsRule.BinopImpl \label{sec:SemanticsRule.BinopImpl}}

  \subsection{Prose}
  An expression \texttt{e}, which denotes an implication over two expressions \texttt{e1} and \texttt{e2},
  is evaluated as \texttt{if e1 then e2 else true} (see Section~\ref{sec:SemanticsRule.ECond}).

  \subsection{Example: SemanticsRule.EBinopImplExFalso.asl}
\VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopImplExFalso.asl}
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \texttt{TRUE}, according to the definition of implication.

  \subsection{Code}
  \VerbatimInput[firstline=\BinopImplBegin, lastline=\BinopImplEnd]{../Interpreter.ml}
\begin{emptyformal}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \texttt{E\_Cond}(\texttt{e1}, \texttt{e2}, \etrue)} \evalarrow C
    }
    {
    \evalexpr{\env, \texttt{E\_Binop}(\texttt{BAND}, \texttt{e1}, \texttt{e2})} \evalarrow C
    }
  \end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BKNT}, and \identi{QRXP}.

\section{SemanticsRule.Binop \label{sec:SemanticsRule.Binop}}

  \subsection{Prose}
  Let \texttt{e} denote a binary expression with operator \texttt{op} and two sub-expressions \texttt{e1} and \texttt{e2}.
  Evaluation of \texttt{e} under environment \texttt{env} is either $\Normal((\vv, \vg), \newenv)$
  or an abnormal configuration, and all of the following apply:
  \begin{itemize}
    \item The evaluation of the expression \texttt{e1} under \texttt{env} either terminates normally,
    yielding \texttt{((v1,g1),env')}, or it terminates abnormally, short-circuiting the entire evaluation;
    \item The evaluation of the expression \texttt{e2} under \texttt{env'} terminates normally,
    yielding \texttt{((v2,g2),new\_env)}, or it terminates abnormally, short-circuiting the entire evaluation;
    \item \texttt{v} is the result of applying the Binary Operator \texttt{op} to \texttt{v1} and \texttt{v2};
    \item \texttt{g} is the parallel combination of \texttt{g1} and \texttt{g2}.
    \item The entire expression terminates normally.
  \end{itemize}

  \subsection{Example: SemanticsRule.EBinopPlusAssert.asl}
    In this program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopPlusAssert.asl}
    the expression \texttt{3 + 2} evaluates to the value \texttt{5}.

  \subsection{Example: \\ SemanticsRule.EDIVBackendDefinedError.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EBinopDIVBackendDefinedError.asl}
    \begin{itemize}
    \item in ASLv0, the expression \texttt{3 DIV 0} raises a backend-defined
      error, e.g.
      \texttt{ASL Execution error: Illegal application of operator DIV for \\ values 3 and 0.}
    \item in ASLv1, the expression \texttt{3 DIV 0} raises a type error.
    \end{itemize}

  \subsection{Code}
  \VerbatimInput[firstline=\BinopBegin, lastline=\BinopEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
We first define the helper relation
$\binop : (\op \times \vals \times \vals) \bigtimes (\vals \cup \Error(\texttt{<string>}))$,
which evaluates an operator over a pair of native values:
\newcommand\ErrorDivDenominatorNegative[0]{\texttt{"DivDenominatorNegative"}}
\begin{mathpar}
  \inferrule{ n = a + b }{
    \binop(\texttt{"+"}, Z(a), Z(b)) \evalarrow Z(n)
  }
  \and
  \inferrule{ n = a - b }{
    \binop(\texttt{"-"}, Z(a), Z(b)) \evalarrow Z(\texttt{n})
  }
  \and
  \inferrule{ n = a \times b }{
    \binop(\texttt{"*"}, Z(a), Z(b)) \evalarrow Z(\texttt{n})
  }
  \and
  \inferrule{  b > 0 \\
    n = a \div b \\
    a = n \times b}{
    \binop(\texttt{"/"}, Z(a), Z(b)) \evalarrow Z(b)
  }
  \and
  \inferrule{  b \leq 0 }{
    \binop(\texttt{"/"}, Z(a), Z(b)) \evalarrow \Error(\ErrorDivDenominatorNegative)
  }
  \and
  \inferrule{  b > 0 \\
  n = a \div b \\
  n \not\in \Z
  }{
    \binop(\texttt{"/"}, Z(a), Z(b)) \evalarrow \Error(\texttt{"/ indivisibility error!"})
  }
  \and
  \inferrule{  b > 0 \\
  a \geq 0 \\
  n = \lfloor a \div b \rfloor
  }{ \binop(\texttt{"DIVRM"}, Z(a), Z(b)) \evalarrow Z(n)) }
  \and
  \inferrule{  b > 0 \\
  a < 0 \\
  n = -(\lceil (-a) \div b \rceil)
  }{ \binop(\texttt{"DIVRM"}, Z(a), Z(b)) \evalarrow Z(n)) }
  \and
  \inferrule{  b \leq 0 }{ \binop(\texttt{"DIVRM"}, Z(a), Z(b)) \evalarrow \Error(\texttt{"DIVRM denominator error!"}) }
  \and
  \inferrule{  b > 0 \\
    \binop(\texttt{DIVRM}, Z(a), Z(b)) \evalarrow c \\
    n = a - (b \times c)
  }{ \binop(\texttt{"MOD"}, Z(a), Z(b)) \evalarrow Z(n)) }
  \and
  \inferrule{  b \leq 0
  }{ \binop(\texttt{"MOD"}, Z(a), Z(b)) \evalarrow \Error(\texttt{"MOD denominator error!"}) }
  \and
  \inferrule{  b \geq 0 \\ n = a^b
  }{ \binop(\texttt{"\^{}"}, Z(a), Z(b)) \evalarrow Z(n)}
  \and
  \inferrule{  b < 0 \\ n = a^b
  }{ \binop(\texttt{"\^{}"}, Z(a), Z(b)) \evalarrow \Error(\texttt{"POW exponent error!"}) }
  \and
  \inferrule{  \binop(\texttt{"*"}, Z(a), \binop(\texttt{"\^{}"}, Z(2), Z(b))) \evalarrow C
  }{ \binop(\texttt{"<<"}, Z(a), Z(b)) \evalarrow C}
  \and
  \inferrule{  \binop(\texttt{"DIVRM"}, Z(a), \binop(\texttt{"\^{}"}, Z(2), Z(b))) \evalarrow C
  }{ \binop(\texttt{">>"}, Z(a), Z(b)) \evalarrow C}
\end{mathpar}

\begin{mathpar}
  \inferrule{  a = b }{ \binop(\texttt{"=="}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a \neq b }{ \binop(\texttt{"=="}, Z(a), Z(b)) \evalarrow B(\False)}
  \and
  \inferrule{  a = b }{ \binop(\texttt{"!="}, Z(a), Z(b)) \evalarrow B(\False)}
  \and
  \inferrule{  a \neq b }{ \binop(\texttt{"!="}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a \leq b }{ \binop(\texttt{"<="}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a > b }{ \binop(\texttt{"<="}, Z(a), Z(b)) \evalarrow B(\False)}
  \and
  \inferrule{  a < b }{ \binop(\texttt{"<"}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a \geq b }{ \binop(\texttt{"<"}, Z(a), Z(b)) \evalarrow B(\False)}
  \and
  \inferrule{  a \geq b }{ \binop(\texttt{">="}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a < b }{ \binop(\texttt{">="}, Z(a), Z(b)) \evalarrow B(\False)}
  \and
  \inferrule{  a > b }{ \binop(\texttt{">"}, Z(a), Z(b)) \evalarrow B(\True)}
  \and
  \inferrule{  a \leq b }{ \binop(\texttt{">"}, Z(a), Z(b)) \evalarrow B(\False)}
\end{mathpar}

In the following definitions, we
employ the usual meaning of logical conjunction $\wedge$, logical disjunction $\vee$,
and logical negation $\neg$.

\begin{mathpar}
\inferrule{}{ \binop(\texttt{"\&\&"}, B(a), B(b)) \evalarrow B(a \wedge b)}
\and
\inferrule{}{ \binop(\texttt{"||"}, B(a), B(b)) \evalarrow B(a \vee b)}
\and
\inferrule{}{ \binop(\texttt{"-->"}, B(a), B(b)) \evalarrow B(\neg a \vee b)}
\and
\inferrule{
  c = ((\neg a) \vee b) \wedge ((\neg b) \vee a)
}{ \binop(\texttt{"<->"}, B(a), B(b)) \evalarrow B(c)}
\and
\inferrule{
  \binop(\texttt{"<->"}, B(a), B(b)) \evalarrow B(c)
}{ \binop(\texttt{"=="}, B(a), B(b)) \evalarrow B(c)}
\and
\inferrule{
  \binop(\texttt{"<->"}, B(a), B(b)) \evalarrow B(c)
}{ \binop(\texttt{"!="}, B(a), B(b)) \evalarrow B(\neg c)}
\end{mathpar}

\begin{mathpar}
  \inferrule{}{\binop(\texttt{"+"}, R(a), R(b)) \evalarrow R(a+b)}
\and
\inferrule{}{\binop(\texttt{"-"}, R(a), R(b)) \evalarrow R(a-b)}
\and
\inferrule{}{\binop(\texttt{"*"}, R(a), R(b)) \evalarrow R(a\times b)}
\and
\inferrule{b \neq 0}{\binop(\texttt{"/"}, R(a), R(b)) \evalarrow R(a\div b)}
\and
\inferrule{b = 0}{\binop(\texttt{"/"}, R(a), R(b)) \evalarrow \Error(\texttt{"/ denominator is 0!})}
\and
\inferrule{b \geq 0}{\binop(\texttt{"\^{}"}, R(a), R(b)) \evalarrow R(a^b)}
\and
\inferrule{b < 0}{\binop(\texttt{"\^{}"}, R(a), R(b)) \evalarrow \Error(\texttt{"Negative exponent!})}
\end{mathpar}

Finally, we employ the definition of $\binop$ to define the rule for a binary operator expression:
  \begin{mathpar}
    \inferrule{
      \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envp) \OrAbnormal \\
      \evalexpr{ \envp, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\
      \vmone = (\vvone, \vgone) \\
      \vmtwo = (\vvtwo, \vgtwo) \\
      \binop(\op, \vvone, \vvtwo) \evalarrow \vv \terminateas \ErrorConfig\\
      \vg = \vgone \parallel \vgtwo
    }
    {
      \evalexpr{ \env, \texttt{E\_Binop}(\op, \veone, \vetwo) } \evalarrow
      \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
\end{formal}

\subsection{Comments}
  This is related to \identr{XKGC} and \identr{BKNT}.

Notice that when one of the sub-expressions terminates exceptionally,
the other exception is guaranteed by the type-checker to be side effect-free and non-throwing (\identi{QJTN}).

The semantics takes a semantic transition over the left sub-expression before the right sub-expression.
This is an artbirary choice as the type-checker must ensure that either order of evaluation of the operands
yields the same result.

\section{SemanticsRule.Unop \label{sec:SemanticsRule.Unop}}
  \subsection{Prose}
  Let \texttt{e} denote a unary expression with operator \texttt{op} and the sub-expression \texttt{e'}.
  Evaluation of \texttt{e}
  under environment \texttt{env} is $\Normal((\vv, \vg), \newenv)$ and all of the following apply:
\begin{itemize}
  \item The evaluation of the expression \texttt{e'} under \texttt{env} terminates normally with \texttt{(v',g),new\_env};
  \item \texttt{v} is the result of applying the unary operator \texttt{op} to \texttt{v'}.
\end{itemize}

  \subsection{Example: SemanticsRule.EUnopAssert.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnopAssert.asl}
    the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.

  \subsection{Code}
  \VerbatimInput[firstline=\UnopBegin, lastline=\UnopEnd]{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule{
    \evalexpr{ \env, \vep} \evalarrow \Normal((\vvp,\vg), \newenv)\\
    \tododefine{unop}(\op, \vvp) = \vv
  }
  {
    \evalexpr{ \env, \texttt{E\_Unop}(\op, \vep) } \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECond \label{sec:SemanticsRule.ECond}}

  \subsection{Prose}
  Let \texttt{e} denote a conditional expression with condition sub-expression \texttt{e\_cond},
  \textit{then} sub-expression \texttt{e1}, and \textit{else} sub-expression \texttt{e2}.
  Evaluating \texttt{e} in the environment \texttt{env} results either in $\Normal((\vres,\vg),\newenv)$
  or an abnormal configuration, and one of the following applies:
  \begin{itemize}
    \item (Condition Normal True) All of the following apply:
    \begin{itemize}
      \item The evaluation of the conditional expression in \texttt{env} terminates normally with the true value,
            \texttt{env'}, and the execution \texttt{g1}, or it terminates abnormally, thereby short-circuiting the entire evaluation;
      \item The evaluation of the expression \texttt{e1} in the environment \texttt{env'} terminates normally with the value
            \texttt{v}, the environment \texttt{new\_env}, and the execution graph \texttt{g2},
            or it terminates abnormally, thereby short-circuiting the entire evaluation;
      \item The resulting graph is \texttt{g1} connected to \texttt{g2} via the label $\aslctrl$.
    \end{itemize}

    \item (Condition Normal False) All of the following apply:
    \begin{itemize}
      \item The evaluation of the conditional expression in \texttt{env} terminates normally with the false value,
            \texttt{env'}, and the execution \texttt{g1}, or it terminates abnormally, thereby short-circuiting the entire evaluation;
      \item The evaluation of the expression \texttt{e2} in the environment \texttt{env'} terminates with the value
            \texttt{v}, the environment \texttt{new\_env}, and the execution graph \texttt{g2},
            or it terminates abnormally, thereby short-circuiting the entire evaluation;
      \item The resulting graph is \texttt{g1} connected to \texttt{g2} via the label $\aslctrl$.
    \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.ECondFalse.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondFalse.asl}
    the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.

  \subsection{Example: \\ SemanticsRule.ECondUNKNOWN3or42.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECondUNKNOWN3or42.asl}
the expression \texttt{if UNKNOWN: boolean then 3 else Return42()} will
evaluate either \texttt{3} or \texttt{Return42()} depending on how
\texttt{UNKNOWN} is implemented.

  \subsection{Code}
  \VerbatimInput[firstline=\ECondBegin, lastline=\ECondEnd]{../Interpreter.ml}

\begin{emptyformal}
\begin{mathpar}
  \inferrule[(Condition True)]{
    \evalexpr{\env, \texttt{e\_cond}} \evalarrow \Normal(\mcond, \envp) \OrAbnormal\\
    \mcond = (\nvliteral{\texttt{L\_Bool}(\True)}, \vgone)\\
    \evalexpr{\envp, \veone} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslctrl}{\vgtwo}
  }
  {
    \evalexpr{\env, \texttt{E\_Cond}(\texttt{e\_cond}, \veone, \vetwo)} \evalarrow
    \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule[(Condition False)]{
  \evalexpr{\env, \texttt{e\_cond}} \evalarrow \Normal(\mcond, \envp) \OrAbnormal\\
  \mcond = (\nvliteral{\texttt{L\_Bool}(\False)}, \vgone)\\
  \evalexpr{\envp, \vetwo} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslctrl}{\vgtwo}
}
{
  \evalexpr{\env, \texttt{E\_Cond}(\texttt{e\_cond}, \veone, \vetwo)} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\end{emptyformal}

  \subsection{Comments}
  This is related to \identr{YCDB}.

\section{SemanticsRule.ESlice \label{sec:SemanticsRule.ESlice}}

  \subsection{Prose}
  Let \texttt{e} denote a slicing expression of the bitvector \texttt{e\_bv} and list of slices \texttt{slices}.
  Evaluating \texttt{e} in the environment \texttt{env} either results in $\Normal((\vres,\vg),\newenv)$,
  or an abnormal configuration, and one of the following applies:

  All of the following apply:
  \begin{itemize}
  \item The evaluation of \texttt{e\_bv} under \texttt{env} is \texttt{v\_bv};
  \item The evaluation of \texttt{slices} under \texttt{env} is \texttt{positions};
  \item \texttt{v} is the value read in \texttt{v\_bv} from \texttt{positions}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ESlice.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ESlice.asl}
    the expression \texttt{'11110000'[5:2]} evaluates to the value \texttt{'1100'}.

  \subsection{Code}
  \VerbatimInput[firstline=\ESliceBegin, lastline=\ESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\
    \mbv = (\vbv,\vgone) \\
    \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envp)  \OrAbnormal \\
    \mpositions = (\positions, \vgtwo) \\
    \tododefine{read\_from\_bitvector}(\vbv, \positions) \evalarrow (\vv, \vgthree)\\
    \newenv = \envp \\
    \vg = \ordered{(\vgone \parallel \vgtwo)}{\asldata}{\vgthree}
  }
  {
    \evalexpr{\env, \texttt{E\_Slice}(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ECall \label{sec:SemanticsRule.ECall}}

  \subsection{Prose}
  Let \texttt{e} denote a subprogram call \texttt{(name, params, actual\_args)}.
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{\Normal((res,g),new\_env)}, or an abnormal configuration, and all of the following apply:
  \begin{itemize}
  \item The evaluation of that subprogram call under \texttt{env} is \texttt{ms};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value read from \texttt{ms};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ECall.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ECall.asl}
    the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
    subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\ECallBegin, lastline=\ECallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv)  \OrAbnormal\\
    \vms = [(\vv, \vg)]
  }
  {
    \evalexpr{\env, \texttt{E\_Call}(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule{
  \evalcall{\env, \name, \actualargs, \params} \evalarrow \Normal(\vms, \newenv)  \OrAbnormal\\
  \vms = [i=1..k: (\vv_i, \vg_i)]\\
  \vvs = [i=1..k: \vv_i]\\
  \vg = \vg_1 \parallel \ldots \parallel \vg_k \\
  \vv = \texttt{create\_vector}(\vvs)
}
{
  \evalexpr{\env, \texttt{E\_Call}(\name, \actualargs, \params)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetArray \label{sec:SemanticsRule.EGetArray}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  such that all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes an array \texttt{e\_array} and an index \texttt{e\_index};
  \item The evaluation of \texttt{e\_array} under \texttt{env} is \texttt{v\_array};
  \item The evaluation of \texttt{e\_index} under \texttt{env} is \texttt{v\_index};
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
          \begin{itemize}
          \item the result of evaluation of \texttt{e} under \texttt{env} is \texttt{(res, env)};
          \item \texttt{res} is a value \texttt{v};
          \item \texttt{v} is the value found at the index \texttt{v\_index} of \texttt{v\_array};
          \item \texttt{new\_env} is \texttt{env};
          \end{itemize}

        \item \texttt{res} is a typing error.
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.EGetArray.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArray.asl}
    the expression \texttt{my\_array[2]} evaluates to the value \texttt{42} since the element
    indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.

  \subsection{Example: SemanticsRule.EGetArrayTooSmall.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EGetArrayTooSmall.asl}
    raises a typing error since we are trying to access index \texttt{3} of an array
    which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetArrayBegin, lastline=\EGetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
      \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envp)  \OrAbnormal\\
      \marray = (\varray, \vgone)\\
      \mindex = (\vindex, \vgtwo)\\
      \vi = \nvliteral{\texttt{L\_Int}(\vindex)}\\
      \tododefine{get\_index}(\vi, \varray) = \vv\\
      \vg = \vgone \parallel \vgtwo\\
    }
    {
      \evalexpr{\env, \texttt{E\_GetArray}(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
    }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.ERecord \label{sec:SemanticsRule.ERecord}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a record value \texttt{names} and associated expressions
    \texttt{fields};
  \item \texttt{fields} evaluates in \texttt{env} to \texttt{v\_fields};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the record built by associating the names \texttt{names} to \texttt{v\_fields}.
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{MyRecordType { a=3, b=42 }} evaluates to the value \texttt{{a:
3, b: 42}}.

  \subsection{Code}
  \VerbatimInput[firstline=\ERecordBegin, lastline=\ERecordEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \efields = [i=1..k: (\id_i, \ve_i)]\\
    \names = [i=1..k: \id_i] \\
    \fields = [i=1..k: \ve_i] \\
    \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \envp)  \OrAbnormal\\
    \vvfields = (i=1..k: \vv_i)\\
    \vv = \nvrecord{[i=1..k: \id_i\mapsto\vv_i]}\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Record}(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EGetField \label{sec:SemanticsRule.EGetField}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a field name \texttt{field\_name} in a record value \texttt{e\_vec};
  \item the evaluation of \texttt{e\_vec} in \texttt{env} is \texttt{v\_vec};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the value mapped by \texttt{field\_name} in \texttt{v\_vec};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ERecord.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ERecord.asl}
    the expression \texttt{my\_record.a} evaluates to the value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\EGetFieldBegin, lastline=\EGetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \envp)  \OrAbnormal\\
    \tododefine{get\_field}(\fieldname, \vrecord) = \vv\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_GetField}(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}


\isempty{\subsection{Comments}}

\section{SemanticsRule.EConcat \label{sec:SemanticsRule.EConcat}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a list of bitvector expressions \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in \texttt{env} is \texttt{v\_list};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the concatenation of \texttt{v\_list};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EConcat}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EConcat.asl}
    the expression \texttt{['10', '11']} evaluates to the value \texttt{'1011'}.

  \subsection{Code}
  \VerbatimInput[firstline=\EConcatBegin, lastline=\EConcatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \envp)  \OrAbnormal\\
    \tododefine{concat\_bitvectors}(\vlist) = \vv\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Concat}(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{BRCM}.

\section{SemanticsRule.ETuple \label{sec:SemanticsRule.ETuple}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a list of expression \texttt{e\_list};
  \item the evaluation of \texttt{e\_list} in \texttt{env} is \texttt{v\_list};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the tuple built from \texttt{v\_list};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.ETuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.ETuple.asl}
    the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\ETupleBegin, lastline=\ETupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \envp)  \OrAbnormal\\
    \tododefine{create\_vector}(\vlist) = \vv\\
    \newenv = \envp
  }
  {
    \evalexpr{\env, \texttt{E\_Tuple}(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.EUnknown \label{sec:SemanticsRule.EUnknown}}

  \paragraph{Domain of a Type.}

  The domain of a type $\vt$ in an environment $\env=(\tenv,\denv)$,
  denoted by $\textsf{dyn-dom}(\tenv, \denv, \vt)$, is defined by the type system~\cite{ASLTypingReference}.
  Intuitively, it is the set of values that a type may store. The reason that the dynamic environment is
  needed to determine the domain is due to subprogram parameters, which constrain integer parameters to
  a singleton value domain.

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} terminates normally with
  \texttt{(v,new\_env,g)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes the \texttt{UNKNOWN} expression annotated with type \texttt{t};
  \item \texttt{v} is a value in the domain of \texttt{t};
  \item \texttt{new\_env} is \texttt{env}.
  \item \texttt{g} is the empty execution graph.
  \end{itemize}

  \subsection{Example: SemanticsRule.EUnknownInteger3.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownInteger3.asl}
    the expression \texttt{[UNKNOWN : integer]} evaluates to an integer value.

  \subsection{Example: \\ SemanticsRule.EUnknownIntegerRange3-42-3.asl}

    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EUnknownIntegerRange3-42-3.asl}
    the expression \texttt{UNKNOWN : integer \{3, 42\}} evaluates to either the value
\texttt{3} or the value \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\EUnknownBegin, lastline=\EUnknownEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{\env=(\tenv, \denv)\\
    \vv \in \textsf{dyn-dom}(\tenv, \env, \vt) \\
  \newenv = \env
  }
  {
    \evalexpr{\env, \texttt{E\_Unknown}} \evalarrow \Normal(\newenv, \vv, \emptygraph)
  }
\end{mathpar}
\end{formal}

\subsection{Comments}
  This is related to \identr{WLCH}.

\section{SemanticsRule.EPattern \label{sec:SemanticsRule.EPattern}}


  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{e} denotes a pattern \texttt{e,p};
  \item \texttt{res} is a value \texttt{v};
  \item \texttt{v} is the boolean determining whether the evaluation of \texttt{e} in \texttt{env} matches \texttt{p};
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.EPatternFALSE.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternFALSE.asl}
    the expression \texttt{42 IN \{0..3, -4\}} evaluates to the value \texttt{FALSE}.

  \subsection{Example: SemanticsRule.EPatternTRUE.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.EPatternTRUE.asl}
    the expression \texttt{42 IN \{0..3, 42\}} evaluates to \texttt{TRUE}.

  \subsection{Code}
  \VerbatimInput[firstline=\EPatternBegin, lastline=\EPatternEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envp)  \OrAbnormal\\
    \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
    \newenv = \envp\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalexpr{\env, \texttt{E\_Pattern}(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CTC \label{sec:SemanticsRule.CTC}}

  \subsection{Prose}
  Evaluation of the expression \texttt{e} under environment \texttt{env} is
  \texttt{(res,new\_env)} and all of the following apply:
  \begin{itemize}
  \item \texttt{(e,\_t)} denotes an expression \texttt{e} and a type \texttt{t};
  \item \texttt{v} is the result of evaluating \texttt{e} in \texttt{env};
  \item \texttt{new\_env} is \texttt{env} modified after evaluating \texttt{e} in \texttt{env};
  \item \texttt{b} is \texttt{true} or \texttt{false} depending on whether \texttt{v} is of type \texttt{t} in \texttt{env};
  \item One of the following applies:
        \begin{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{true};
              \item \texttt{res} is \texttt{v};
              \item \texttt{new\_env} is \texttt{new\_env}
              \end{itemize}
        \item All of the following apply:
              \begin{itemize}
              \item \texttt{b} is \texttt{false};
              \item a type error is raised.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.CTCValue.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCValue.asl}

  \subsection{Example: SemanticsRule.CTCError.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CTCError.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\CTCBegin, lastline=\CTCEnd]
                {../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv)  \OrAbnormal\\
    \tododefine{is\_val\_of\_type}(\ve, \env, \vv, \vt)
  }
  {
    \evalexpr{\env, \texttt{E\_CTC}(\ve, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
  }
\and
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\Ignore, \vg), \newenv)\\
  \neg\tododefine{is\_val\_of\_type}(\ve, \env, \vv, \vt)
}
{
  \evalexpr{\env, \texttt{E\_CTC}(\ve, \vt)} \evalarrow \Error(\texttt{"Type mismatch!"})
}
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WZVX}, \identi{VQLX}, \identr{YCPX}, \identi{TCST}, \identi{CGRH}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Left-Hand Side Expressions \label{chap:eval_lexpr}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is either \texttt{new\_env}
or an error is raised and one of the following applies:
\begin{itemize}
\item SemanticsRule.LEDiscard (see Section~\ref{sec:SemanticsRule.LEDiscard});
\item SemanticsRule.LELocalVar (see Section~\ref{sec:SemanticsRule.LELocalVar});
\item SemanticsRule.LEGlobalVar (see Section~\ref{sec:SemanticsRule.LEGlobalVar});
\item SemanticsRule.LESlice (see Section~\ref{sec:SemanticsRule.LESlice});
\item SemanticsRule.LESetArray (see Section~\ref{sec:SemanticsRule.LESetArray});
\item SemanticsRule.LESetField (see Section~\ref{sec:SemanticsRule.LESetField});
\item SemanticsRule.LEDestructuring (see Section~\ref{sec:SemanticsRule.LEDestructuring}).
\end{itemize}

\section{Evaluating Multi-assignments}
We employ the following helper semantic relation to evaluate multi-assignments.
That is, simultaneous assignments of a tuple of values to a tuple of left-hand side expressions.
\[
  \begin{array}{rl}
    \evalmultiassignment{\envs \times \expr^* \times (\vals \times \XGraphs)^*} \bigtimes
      & \Normal(\XGraphs, \envs)\ \cup \\
      & \Throwing((\langle\vals \times \ty\rangle \times \XGraphs, \envs)\ \cup \\
      & \Error(\texttt{<string>})
  \end{array}
\]

The relation is defined via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \evalmultiassignment{\env, \emptylist, \emptylist} \evalarrow \Normal(\env, \emptygraph)
  }
\and
\inferrule{
  \evallexpr{\env, \vle, \vm} \evalarrow \Normal(\envp, \vgone) \OrAbnormal\\
  \evalmultiassignment{\envp, \vlelist, \vmlist} \evalarrow \Normal(\newenv, \vgtwo) \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalmultiassignment{\env, [\vle] + \vlelist, [\vm] + \vmlist} \evalarrow \Normal(\newenv, \vg)
}

\end{mathpar}

\section{SemanticsRule.LEDiscard \label{sec:SemanticsRule.LEDiscard}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} can be discarded;
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

  \subsection{Example: SemanticsRule.LEDiscard.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDiscard.asl}
  \texttt{- = 42;} does not affect the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDiscardBegin, lastline=\LEDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{}
    { \evallexpr{\env, \texttt{LE\_Discard}, (\vv, \vg)} \evalarrow \Normal(\vg, \env) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LELocalVar \label{sec:SemanticsRule.LELocalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x};
    \item \texttt{x} is locally bound in \texttt{env};
    \item \texttt{new\_env} is \texttt{env} where \texttt{x} is bound to \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LELocalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LELocalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LELocalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LELocalVarBegin, lastline=\LELocalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \newenv = \env[\vx \mapsto \vv]\\
      \vg' = \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \texttt{LE\_Var}(\vx), (\vv, \vg)} \evalarrow \Normal(\vg',\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LEGlobalVar \label{sec:SemanticsRule.LEGlobalVar}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a variable \texttt{x};
    \item \texttt{x} is globally bound in \texttt{env};
    \item \texttt{new\_env} is \texttt{env} where \texttt{x} is bound to \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEGlobalVar.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEGlobalVar.asl}
    the evaluation of the left-hand-side expression \texttt{x} within \texttt{x = 42;} uses SemanticsRule.LEGlobalVar.

  \subsection{Code}
  \VerbatimInput[firstline=\LEGlobalVarBegin, lastline=\LEGlobalVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \newenv = \env[\vx \mapsto \vv]\\
      \vg' = \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
    }
    { \evallexpr{\env, \texttt{LE\_Var}(\vx), (\vv, \vg)} \evalarrow \Normal(\vg',\newenv) }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LESlice \label{sec:SemanticsRule.LESlice}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a left-hand-side expression sliced as per \texttt{slices};
    \item The right-hand-side expression corresponding to \texttt{le} is \texttt{re\_bv};
    \item The evaluation of \texttt{re\_bv} under \texttt{env} is \texttt{rv\_bv};
    \item The evaluation of \texttt{slices} under \texttt{env} is \texttt{positions};
    \item \texttt{new\_m\_bv} is \texttt{rv\_bv} where the positions \texttt{positions} have been updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le} is bound to \texttt{new\_m\_bv}.
    \end{itemize}

   \subsection{Example: SemanticsRule.LESlice.asl}
   In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESlice.asl}
   \texttt{x[3:0] = '0000'} binds \texttt{x} to \texttt{'11110000'} in the environment where \texttt{x} is bound to \texttt{'11111111'}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESliceBegin, lastline=\LESliceEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
    \inferrule{
      \vm = (\vv, \vg)\\
      \evalexpr{\env, \torexpr(\ebv)} \evalarrow \Normal(\mbv,\envone) \OrAbnormal\\
      \evalslices{\envone, \slices} \evalarrow \Normal(\mpositions, \envtwo) \OrAbnormal\\
      \mpositions = (\vgone, \positions)\\
      \vbv = (\mbv, \vgtwo)\\
      \tododefine{write\_to\_bitvector}(\positions, \vv, \vbv) \evalarrow (\vv',\vgthree) \OrAbnormal\\
      \vg' = \ordered{(\vg \parallel \vgone \parallel \vgtwo)}{\asldata}{\vgthree}\\
      \evallexpr{\env, \texttt{LE\_Slice}(\ebv, \slices), (\vv', \vg')} \evalarrow C
    }
    { \evallexpr{\envtwo, \ebv, \vm} \evalarrow C }
  \end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.

\section{SemanticsRule.LESetArray \label{sec:SemanticsRule.LESetArray}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes an array \texttt{le\_array} and an index \texttt{e\_index};
    \item The right-hand-side expression corresponding to \texttt{le\_array} is \texttt{re\_array};
    \item The evaluation of \texttt{re\_array} under \texttt{env} is \texttt{rv\_array};
    \item The evaluation of \texttt{e\_index} under \texttt{env} is \texttt{v\_index};
    \item \texttt{new\_v\_array} is \texttt{rv\_array} where the value at index \texttt{v\_index} has been
      updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le\_array} is bound to
      \texttt{new\_v\_array}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetArray.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetArray.asl}
    binds the third element of \texttt{my\_array} to the value \texttt{53}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetArrayBegin, lastline=\LESetArrayEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm = (\vv, \vg)\\
    \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
    \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
    \mindex = (\vindex, \vgone)\\
    \rmarray = (\rvarray, \vgtwo)\\
    \tododefine{set\_index}(\vindex, \vv, \rvarray) = \vv'\\
    \vm' = (\vv', \vgone \parallel \vgtwo)\\
    \evallexpr{\envtwo, \rearray, \vm'} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_SetArray}(\rearray, \eindex), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.


\section{SemanticsRule.LESetField \label{sec:SemanticsRule.LESetField}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a field name \texttt{field\_name} in a record \texttt{le\_record};
    \item The right-hand-side expression corresponding to \texttt{le\_record} is
      \texttt{re\_record};
    \item The evaluation of \texttt{re\_record} under \texttt{env} is \texttt{rv\_record};
    \item \texttt{new\_v\_record} is \texttt{rv\_record} where the field \texttt{field\_name} has been
      updated to \texttt{v};
    \item \texttt{new\_env} is \texttt{env} where \texttt{le\_record} is bound to
      \texttt{new\_v\_record}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LESetField.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LESetField.asl}
    \texttt{my\_record.a = 42;} binds \texttt{my\_record} to \texttt{\{a: 42, b: 42\}} in the environment where \texttt{my\_record} is bound to \texttt{\{a: 3, b: 42\}}.

  \subsection{Code}
  \VerbatimInput[firstline=\LESetFieldBegin, lastline=\LESetFieldEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm = (\vv, \vg)\\
    \evalexpr{\env, \torexpr(\rerecord)} \evalarrow \Normal(\rmrecord, \envone) \OrAbnormal\\
    \rmrecord = (\rvrecord, \vgone)\\
    \tododefine{set\_field}(\fieldname, \vv, \rvrecord) = \vv'\\
    \vm' = (\vv', \vg \parallel \vgone)\\
    \evallexpr{\env1, \rerecord, \vm'} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_SetField}(\rerecord, \fieldname), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\subsection{Comments}
  This is related to \identr{WHRS}.


\section{SemanticsRule.LEDestructuring \label{sec:SemanticsRule.LEDestructuring}}

    \subsection{Prose}
    Evaluation of the left-hand-side expression \texttt{le} associated with a
value \texttt{v} under an environment \texttt{env} is \texttt{new\_env} and all
of the following apply:
    \begin{itemize}
    \item \texttt{le} denotes a list of left-hand-side expressions \texttt{le\_list};
    \item \texttt{new\_env} is \texttt{env} where each left-hand-side expression in \texttt{le\_list} has
      been assigned the value at the corresponding index in \texttt{v}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LEDestructuring.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LEDestructuring.asl}
    \texttt{(x, y) = (3, 42)} binds \texttt{x} to \texttt{3} and \texttt{y} to \texttt{42} in the environment where \texttt{x} is bound to \texttt{42} and \texttt{y} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\LEDestructuringBegin, lastline=\LEDestructuringEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm = (\vv, \vg)\\
    \vlelist = [\vle_{i=1..k}]\\
    i=1..k: \tododefine{get\_index}(i, \vv)=(\vv_i, \vg_i)\\
    \vmlist = [i=1..k: (\vv_i, \ordered{\vg}{\asldata}{\vg_i})]\\
    \evalmultiassignment{\env, \vlelist, \vmlist} \evalarrow C
  }
  { \evallexpr{\env, \texttt{LE\_Destructuring}(\vlelist), \vm} \evalarrow C }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Slices \label{chap:eval_slices}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_slices env slices} is the list of pair \texttt{(start\_n, length\_n)} that
corresponds to the start (included) and the length of each slice in
\texttt{slices}.

We define evaluation of a list of slices in terms of the following rules,
which make use of the rules for evaluating a single slice, in the sequel of this chapter:
\begin{mathpar}
  \inferrule{}
  {
    \evalslices{\env, \emptylist} \evalarrow \Normal((\emptylist, \emptygraph), \env)
  }
  \and
  \inferrule{
    \evalslice{\env, \slice} \evalarrow \Normal((\range, \vgone), \envone) \OrAbnormal\\
    \evalslices{\envone, \slices} \evalarrow \Normal((\ranges, \vgtwo), \newenv) \OrAbnormal\\
  }
  {
    \evalslices{\env, \slice + \slices} \evalarrow \Normal([\range] + \ranges, \vgone \parallel \vgtwo), \newenv)
  }
\end{mathpar}

Evaluation of a single slice \texttt{s} under environment \texttt{env} is
\texttt{((start, length), new\_env)}, or an error, and one of the following applies:
\begin{itemize}
\item SemanticsRule.SliceSingle (see Section~\ref{sec:SemanticsRule.SliceSingle}),
\item SemanticsRule.SliceLength (see Section~\ref{sec:SemanticsRule.SliceLength}),
\item SemanticsRule.SliceRange (see Section~\ref{sec:SemanticsRule.SliceRange}),
\item SemanticsRule.SliceStar (see Section~\ref{sec:SemanticsRule.SliceStar}).
\end{itemize}

\section{SemanticsRule.SliceSingle \label{sec:SemanticsRule.SliceSingle}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all
of the following apply:
  \begin{itemize}
    \item \texttt{s} is the single expression \texttt{e};
    \item \texttt{start} is the result of evaluation of the expression~\texttt{e}
      in the environment \texttt{env};
    \item \texttt{new\_env} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e};
    \item \texttt{length} is the integer value 1.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceSingle.asl}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceSingle.asl}
  the slice \texttt{[2]} evaluates to \texttt{(2, 1)}, i.\,e.\ the slice of
  length 1 starting at index 2.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceSingleBegin, lastline=\SliceSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \ve} \evalarrow \Normal((\start, \vg), \newenv) \OrAbnormal\\
  }
  {
    \evalslice{\env, \texttt{Slice\_Single}(\ve)} \evalarrow \Normal(((\start, Z(1)), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceLength \label{sec:SemanticsRule.SliceLength}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice which starts at expression~\texttt{e\_start} with length~\texttt{e\_length};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceLength.asl}
  In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceLength.asl}
  \texttt{2+:3} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceLengthBegin, lastline=\SliceLengthEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \estart} \evalarrow \Normal(\mstart, \envone) \OrAbnormal\\
    \evallexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mstart = (\vstart, \vgone)\\
    \mlength = (\vlength, \vgtwo)\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Length}(\estart, \elength)} \evalarrow \\ \Normal(((\vstart, \vlength), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceRange \label{sec:SemanticsRule.SliceRange}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following apply:
  \begin{itemize}
    \item \texttt{s} is the slice range between the
      expressions~\texttt{e\_start} and~\texttt{e\_top};
    \item \texttt{v\_top} is the result of evaluation of the
      expression~\texttt{e\_top} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_top};
    \item \texttt{start} is the result of evaluation of the
      expression~\texttt{e\_start} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_start};
    \item \texttt{length} is the integer value \texttt{(vtop - start) + 1};
  \end{itemize}

  \subsection{Example: SemanticsRule.SliceRange.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceRange.asl}
  \texttt{4:2} evaluates to \texttt{(2, 3)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceRangeBegin, lastline=\SliceRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \etop} \evalarrow \Normal(\mtop, \envone) \OrAbnormal\\
    \mtop = (\vvtop, \vgone)\\
    \evallexpr{\envone, \estart} \evalarrow \Normal(\mstart, \newenv) \OrAbnormal\\
    \mstart = (\vstart, \vgtwo)\\
    \binop(\texttt{"+"}, Z(1), \binop(\texttt{"-"}, \vvtop, \vstart)) \evalarrow \length\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Range}(\etop, \estart)} \evalarrow \\ \Normal(((\start, \length), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SliceStar \label{sec:SemanticsRule.SliceStar}}

  \subsection{Prose}
  The result of evaluation is \texttt{((start, length), new\_env)} and all of the following
apply:
  \begin{itemize}
    \item \texttt{s} is the slice with factor given by the
      expression~\texttt{e\_factor} and length given by the
      expression~\texttt{e\_length};
    \item \texttt{v\_factor} is the result of evaluation of the
      expression~\texttt{e\_factor} in the environment \texttt{env};
    \item \texttt{env\_1} is the environment \texttt{env} modified after
      evaluation of the expression~\texttt{e\_factor};
    \item \texttt{length} is the result of evaluation of the
      expression~\texttt{e\_length} in the environment \texttt{env\_1};
    \item \texttt{new\_env} is the environment \texttt{env\_1} modified after
      evaluation of the expression~\texttt{e\_length};
    \item \texttt{start} is the integer value
      $\texttt{v\_factor} \times \texttt{length}$.
  \end{itemize}


  \subsection{Example: SemanticsRule.SliceStar.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SliceStar.asl}
  \texttt{x[2*:3]} evaluates to \texttt{(6, 2)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SliceStarBegin, lastline=\SliceStarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallexpr{\env, \efactor} \evalarrow \Normal(\mfactor, \envone) \OrAbnormal\\
    \mfactor = (\vfactor, \vgone)\\
    \evallexpr{\envone, \elength} \evalarrow \Normal(\mlength, \newenv) \OrAbnormal\\
    \mlength = (\vlength, \vgtwo)\\
    \binop(\texttt{"*"}, \vfactor, \vlength) \evalarrow \length \\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalslice{\env, \texttt{Slice\_Star}(\efactor, \elength)} \evalarrow \\ \Normal(((\start, \length), \vg), \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Patterns \label{chap:eval_pattern}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_pattern env pos v p} determines if \texttt{v} matches the pattern \texttt{p}.

Evaluation of the pattern \texttt{p} under environment \texttt{env} with
respect to value \texttt{v} is \texttt{b}, or an error, and one of the
following applies:
\begin{itemize}
\item SemanticsRule.PAll (see Section~\ref{sec:SemanticsRule.PAll})
\item SemanticsRule.PAny (see Section~\ref{sec:SemanticsRule.PAny})
\item SemanticsRule.PGeq (see Section~\ref{sec:SemanticsRule.PGeq})
\item SemanticsRule.PLeq (see Section~\ref{sec:SemanticsRule.PLeq})
\item SemanticsRule.PNot (see Section~\ref{sec:SemanticsRule.PNot})
\item SemanticsRule.PRange (see Section~\ref{sec:SemanticsRule.PRange})
\item SemanticsRule.PSingle (see Section~\ref{sec:SemanticsRule.PSingle})
\item SemanticsRule.PMask (see Section~\ref{sec:SemanticsRule.PMask})
\item SemanticsRule.PTuple (see Section~\ref{sec:SemanticsRule.PTuple})
\end{itemize}

\section{SemanticsRule.PAll \label{sec:SemanticsRule.PAll}}

  \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
  \begin{itemize}
    \item \texttt{p} is the pattern which matches everything, and therefore
      matches \texttt{v};
    \item \texttt{b} is the boolean value \texttt{true}.
  \end{itemize}

  \subsection{Example: SemanticsRule.PAll.asl}
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAll.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PAllBegin, lastline=\PAllEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalpattern{\env, \Ignore, \texttt{Pattern\_All}} \evalarrow \Normal(B(\True), \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PAny \label{sec:SemanticsRule.PAny}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is a list of patterns \texttt{ps};
      \item \texttt{bs} is the list resulting of the evaluation of the patterns in \texttt{ps} under environment \texttt{env} with respect to value \texttt{v};
      \item \texttt{b} is the disjunction of the values in \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PAnyTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyTRUE.asl}

    \subsection{Example: SemanticsRule.PAnyFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PAnyFALSE.asl}

    \subsection{Code}
    \VerbatimInput[firstline=\PAnyBegin, lastline=\PAnyEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps = \vp_{i=1..k}\\
    i=1..k : \evalpattern{\env, \vv, \vp_i} \evalarrow \Normal(B(\vb_i), \vg_i) \terminateas \ErrorConfig\\
    \vv = B(\bigvee_{i=1..k} \vb_i)\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Any}(\vps)} \evalarrow \Normal(\vv, \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PGeq \label{sec:SemanticsRule.PGeq}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being greater or equal
        than the side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is greater or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PGeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqTRUE.asl}

    \subsection{Example: SemanticsRule.PGeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PGeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PGeqBegin, lastline=\PGeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv', \vg) \terminateas \ErrorConfig
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Geq}(\ve)} \evalarrow \Normal(\binop(\GEQ, \vv, \vv'), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PLeq \label{sec:SemanticsRule.PLeq}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being less or equal
        than the side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is less or equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PLeqTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqTRUE.asl}

    \subsection{Example: SemanticsRule.PLeqFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PLeqFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PLeqBegin, lastline=\PLeqEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vv', \vg) \terminateas \ErrorConfig
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Geq}(\ve)} \evalarrow \Normal(\binop(\LEQ, \vv, \vv'), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PNot \label{sec:SemanticsRule.PNot}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the negation of the pattern \texttt{p'};
      \item \texttt{b'} is the result of the evaluation of the pattern
        \texttt{p'} under environment \texttt{env} with respect to the value
        \texttt{v};
      \item \texttt{b} is the boolean negation of \texttt{b'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PNotTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotTRUE.asl}

    \subsection{Example: SemanticsRule.PNotFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PNotFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PNotBegin, lastline=\PNotEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \ve} \evalarrow \Normal(\vb, \vg) \terminateas \ErrorConfig
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Not}(\vp')} \evalarrow \Normal(\unop(\BNOT, \vb), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PRange \label{sec:SemanticsRule.PRange}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being greater or equal
        to \texttt{e1}, and lesser or equal to \texttt{e2};
      \item \texttt{e1} and \texttt{e2} are side-effect-free expressions;
      \item \texttt{v1} is the side-effect-free evaluation of \texttt{e1} in
        \texttt{env};
      \item \texttt{v2} is the side-effect-free evaluation of \texttt{e2} in
        \texttt{env};
      \item \texttt{b1} is the boolean value corresponding to whether
        \texttt{v} is greater or equal to \texttt{v1}.
      \item \texttt{b2} is the boolean value corresponding to whether
        \texttt{v} is less or equal to \texttt{v2}.
      \item \texttt{b} is the boolean conjunction of \texttt{b1} and
        \texttt{b2}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PRangeTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeTRUE.asl}

    \subsection{Example: SemanticsRule.PRangeFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PRangeFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PRangeBegin, lastline=\PRangeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvone, \vgone) \terminateas \ErrorConfig\\
    \vbone = \unop(\GEQ, \vv, \vvone)\\
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvtwo, \vgtwo) \terminateas \ErrorConfig\\
    \vbtwo = \unop(\GEQ, \vv, \vvtwo)\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Range}(\veone, \vetwo)} \evalarrow \Normal(\unop(\BAND, \vbone, \vbtwo), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PSingle \label{sec:SemanticsRule.PSingle}}

    \subsection{Prose}
  Evaluation of the pattern \texttt{p} under environment \texttt{env} with
  respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is the condition corresponding to being equal to the
        side-effect-free expression \texttt{e};
      \item \texttt{v'} is the side-effect-free evaluation of \texttt{e} in
        environment \texttt{env};
      \item \texttt{b} is the boolean value corresponding to whether \texttt{v}
        is equal to \texttt{v'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PSingleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleTRUE.asl}

    \subsection{Example: SemanticsRule.PSingleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PSingleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PSingleBegin, lastline=\PSingleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexprsef{\env, \veone} \evalarrow \Normal(\vvp, \vg) \terminateas \ErrorConfig\\
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Single}(\ve)} \evalarrow \Normal(\unop(\EQOP, \vv, \vvp), \vg)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PMask \label{sec:SemanticsRule.PMask}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} is a mask \texttt{m} of length $n$ (with spaces removed);
      \item \texttt{m\_set} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit set at index $i$, i.\,e.\
        $\texttt{m}[i] = '1'$;
      \item \texttt{m\_unset} is the bitvector value of length $n$ with bit set
        at index $i$ if the mask requires a bit unset at index $i$, i.\,e.\
        $\texttt{m}[i] = '0'$;
      \item \texttt{m\_specified} is the bitwise disjunction of \texttt{m\_set}
        and \texttt{m\_unset};
      \item \texttt{nv} is the bitwise negation of \texttt{v};
      \item \texttt{v\_set} is the bitwise conjunction of \texttt{m\_set} and
        \texttt{v};
      \item \texttt{v\_unset} is the bitwise conjunction of \texttt{m\_unset} and
        \texttt{nv};
      \item \texttt{v\_set\_or\_unset} is the bitwise disjunction of
        \texttt{v\_set} and \texttt{v\_unset};
      \item \texttt{b} is the boolean value of the bitwise equality of
        \texttt{v\_set\_or\_unset} and \texttt{m\_specified}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PMaskTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskTRUE.asl}

    \subsection{Example: SemanticsRule.PMaskFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PMaskFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PMaskBegin, lastline=\PMaskEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  The helper function $\text{mask\_match} : \{0, 1, x\} \times \{0,1\} \rightarrow \{\True,\False\}$,
  which checks whether a bit value (second operand) matches a mask value (first operand),
  is defined by the following table:
\[
  \begin{array}{|c|c|c|c|}
    \hline
    \textbf{mask\_match} & 0 & 1 & x\\
    \hline
    0 & \True & \False & \True\\
    \hline
    1 & \False & \True & \True\\
    \hline
  \end{array}
\]

\begin{mathpar}
  \inferrule{
    \vm = \vm_{1..k}\\
    \vv = \vv_{1..k}\\
    \vv = B(\bigwedge_{i=1..k} \text{mask\_match}(\vm_i, \vv_i))
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Mask}(\vm)} \evalarrow \Normal(\vv, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.PTuple \label{sec:SemanticsRule.PTuple}}

    \subsection{Prose}
    Evaluation of the pattern \texttt{p} under environment \texttt{env} with
    respect to value \texttt{v} is \texttt{b} and all of the following apply:
    \begin{itemize}
      \item \texttt{p} gives a list of patterns \texttt{ps} of length $n$;
      \item \texttt{v} gives a tuple of values \texttt{vs} of length $n$;
      \item for all $1 \leq i \leq n$, $\texttt{b}_i$ is the evaluation result
        of $\texttt{p}_i$ with respect to the value $\texttt{v}_i$ in
        environment \texttt{env};
      \item \texttt{bs} is the list of all $\texttt{b}_i$ for $1 \leq i \leq n$;
      \item \texttt{b} is the conjunction of the boolean values of \texttt{bs}.
    \end{itemize}

    \subsection{Example: SemanticsRule.PTupleTRUE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleTRUE.asl}

    \subsection{Example: SemanticsRule.PTupleFALSE.asl}
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.PTupleFALSE.asl}

  \subsection{Code}
  \VerbatimInput[firstline=\PTupleBegin, lastline=\PTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vps = \vp_{1..k}\\
    i=1..k: \vvs_i = \tododefine{get\_index}(i, \vv)\\
    i=1..k: \evalpattern{\env, \vvs_i, \vp_i} \evalarrow \Normal(B(\vbs_i), \vg_i) \terminateas \ErrorConfig\\
    \vv = B(\bigwedge_{i=1..k} \vbs_i)\\
    \vg = \vg_1 \parallel \ldots \parallel \vg_k
  }
  {
    \evalpattern{\env, \vv, \texttt{Pattern\_Tuple}(\vps)} \evalarrow \Normal(\vv, \emptygraph)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Local Declarations \label{chap:eval_local_decl}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_local\_decl ldi env m\_init\_opt} declares local variables
\texttt{ldi} in \texttt{env} with an optional initialisation value
\texttt{m\_init\_opt}.  Evaluation of the local variables \texttt{ldi}
under an environment \texttt{env} is either \texttt{new\_env} or raises an
error and one of the following applies:
\begin{itemize}
  \item SemanticsRule.LDDiscard (see Section~\ref{sec:SemanticsRule.LDDiscard}),
  \item SemanticsRule.LDVar (see Section~\ref{sec:SemanticsRule.LDVar}),
  \item SemanticsRule.LDTyped (see Section~\ref{sec:SemanticsRule.LDTyped}),
  \item SemanticsRule.LDTuple (see Section~\ref{sec:SemanticsRule.LDTuple}),
  \item SemanticsRule.LDUninitialisedTyped (see Section~\ref{sec:SemanticsRule.LDUninitialisedTyped}),
\end{itemize}

\section{SemanticsRule.LDDiscard \label{sec:SemanticsRule.LDDiscard}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} indicates that the initialisation value will be discarded;
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDDiscard.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDDiscard.asl}
    \texttt{var - : integer;} does not modify the environment.

  \subsection{Code}
  \VerbatimInput[firstline=\LDDiscardBegin, lastline=\LDDiscardEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evallocaldecl{\env, \texttt{LDI\_Discard}, \Ignore} \evalarrow \Normal(\emptygraph, \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDVar \label{sec:SemanticsRule.LDVar}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} is a variable \texttt{x};
    \item \texttt{m\_init\_opt} is a value \texttt{m};
    \item \texttt{new\_env} is \texttt{env} modified to declare \texttt{x} as a
local variable bound to value \texttt{m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDVar0.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar0.asl}
    \texttt{var x = 3;} binds \texttt{x} to the evaluation of \texttt{3} in \texttt{env}.

    \subsection{Example: SemanticsRule.LDVar1.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDVar1.asl}
    \texttt{var x : integer = 3;} binds \texttt{x} to the evaluation of
\texttt{3} in \texttt{env}, without type consideration at runtime.

  \subsection{Code}
  \VerbatimInput[firstline=\LDVarBegin, lastline=\LDVarEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm = (\vv, \vgone)\\
    \tododefine{declare\_local\_identifier}(\env, \vx, \vv)=(\newenv, \vgtwo)\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Var}(\vx), \langle \vm\rangle} \evalarrow \Normal(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTyped \label{sec:SemanticsRule.LDTyped}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
      \item \texttt{ldi} gives a local declaration item \texttt{ldi'} and a
        type \texttt{t};
        %
      \item \texttt{m\_init\_opt} is a value \texttt{m};
        %
      \item \texttt{new\_env} is \texttt{env} modified after the evaluation of
        \texttt{ldi'} with the initialisation value \texttt{m} in \texttt{env}.
        %
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTyped.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in \texttt{env} to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTypedBegin, lastline=\LDTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\env, \ldi', \langle \vm\rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Typed}(\ldi', \Ignore), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDTuple \label{sec:SemanticsRule.LDTuple}}

    \subsection{Prose}
Evaluation of the local variables \texttt{ldi} under the environment
\texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{ldi} gives a list of local variables \texttt{ldis};
    \item \texttt{m\_init\_opt} is a list of values \texttt{liv};
    \item \texttt{new\_env} is \texttt{env} modified to declare each element of \texttt{ldis} to be bound
      to the corresponding value in \texttt{liv}.
    \end{itemize}

    \subsection{Example: SemanticsRule.LDTuple.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDTuple.asl}
    \texttt{var (x,y,z) = (1,2,3);} binds \texttt{x} to the evaluation of
\texttt{1}, \texttt{y} to the evaluation of \texttt{2}, and \texttt{z} to the
evaluation of \texttt{3}) in \texttt{env}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDTupleBegin, lastline=\LDTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
\newcommand\ldituplefolder[1]{\texttt{ldi\_tuple\_folder}(#1)}

  \subsection{Formally}
We first define the helper semantic relation
\[
    \ldituplefolder{\envs \times \localdeclitem^* \times (\vals \times \XGraphs)^*} \bigtimes
     \Normal(\XGraphs, \envs)
\]
via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \ldituplefolder{\env, \emptylist, \emptylist} \evalarrow \Normal(\emptygraph, \env)
  }
\and
  \inferrule{
    \vm = (\vv, \vgone)\\
    \evallocaldecl{\env, \ldi', \langle\vm\rangle} \evalarrow \Normal(\vgone, \envone)\\
    \ldituplefolder{\envone, \ldis, \liv} \evalarrow \Normal(\vgtwo, \newenv)\\
    \vg = \vgone \parallel \vgtwo
  }
  {
    \ldituplefolder{\env, [\ldi'] + \ldis, [\vm] + \liv} \evalarrow \Normal(\vg, \newenv)
  }
\end{mathpar}

We now use the helper rules to define the rule for local declaration item tuples:
\begin{mathpar}
  \inferrule{
    \vm = (\vv, \vg)\\
    \ldis = \ldi_{1..k}\\
    i=1..k: \tododefine{get\_index}(i, \vv)=(\vv_i,\vg_i)\\
    \liv = [i=1..k: (\vv_i, \ordered{\vg}{\asldata}{\vg_i})]\\
    \ldituplefolder{\env, \ldis, \liv} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Tuple}(\ldis), \langle \vm\rangle} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.LDUninitialisedTyped\label{sec:SemanticsRule.LDUninitialisedTyped}}

    \subsection{Prose}
    Evaluation of the local declaration item \texttt{ldi} under the environment
    \texttt{env} is \texttt{new\_env} and all of the following apply:
    \begin{itemize}
      \item \texttt{ldi} gives a local declaration item \texttt{ldi'} and a
        type \texttt{t};
        %
      \item \texttt{m\_init\_opt} is \texttt{None};
        %
      \item \texttt{m} is the base value of \texttt{t} in \texttt{env};
        %
      \item \texttt{new\_env} is \texttt{env} modified after the evaluation of
        \texttt{ldi'} with the initialisation value \texttt{m} in \texttt{env}.
        %
    \end{itemize}

    \subsection{Example: SemanticsRule.LDUninitialisedTyped.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.LDUninitialisedTyped.asl}
    \texttt{var x : integer;} binds \texttt{x} in \texttt{env} to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\LDUninitialisedTypedBegin, lastline=\LDUninitialisedTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vm = (\tododefine{base\_value}(\env, \vt), \emptygraph)\\
    \evallocaldecl{\env, \ldi', \langle \vm \rangle} \evalarrow C
  }
  {
    \evallocaldecl{\env, \texttt{LDI\_Ttyped}(\ldi', \vt), \None} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Statements \label{chap:eval_stmt}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The semantic relation for statements is defined as follows:
\[
  \semantic{\texttt{stmt}} : \evalstmt{\envs \times \stmt} \times \left(
    \begin{array}{ll}
    \Continuing(\XGraphs, \envs) &\cup\\
    \Returning((\vals^* \times \XGraphs), \envs) &\cup\\
    \Throwing((\langle\vals \times \ty\rangle \times \XGraphs), \envs)&
    \end{array}
  \right) \enspace.
\]

Input configurations consist of an environment and a statement that should be evaluated in that environment.
Output configurations are in one of three \emph{modes}: \emph{continuing mode} configurations, which signify
the flow of control should pass to the next statement in the current subprogram;
\emph{returning mode} configurations, which signify that the flow of control should resume with the caller
of the current subprogram with a list of returned values;
and \emph{throwing mode} configurations, which signify that an exception was raised, either without an exception value (as in \texttt{throw;}),
or with a given exception value and an associated exception type.

\begin{itemize}
\item SemanticsRule.SPass (see Section~\ref{sec:SemanticsRule.SPass}),
\item SemanticsRule.SAssign (see Section~\ref{sec:SemanticsRule.SAssign}),
\item SemanticsRule.SAssignCall (see Section~\ref{sec:SemanticsRule.SAssignCall}),
\item SemanticsRule.SAssignTuple (see Section~\ref{sec:SemanticsRule.SAssignTuple}),
\item SemanticsRule.SReturnNone (see Section~\ref{sec:SemanticsRule.SReturnNone}),
\item SemanticsRule.SReturnOne (see Section~\ref{sec:SemanticsRule.SReturnOne}),
\item SemanticsRule.SReturnSome (see Section~\ref{sec:SemanticsRule.SReturnSome}),
\item SemanticsRule.SSeq (see Section~\ref{sec:SemanticsRule.SSeq}),
\item SemanticsRule.SCall (see Section~\ref{sec:SemanticsRule.SCall}),
\item SemanticsRule.SCond (see Section~\ref{sec:SemanticsRule.SCond}),
\item SemanticsRule.SCase (see Section~\ref{sec:SemanticsRule.SCase}),
\item SemanticsRule.SAssert (see Section~\ref{sec:SemanticsRule.SAssert}),
\item SemanticsRule.SWhile (see Section~\ref{sec:SemanticsRule.SWhile}),
\item SemanticsRule.SRepeat (see Section~\ref{sec:SemanticsRule.SRepeat}),
\item SemanticsRule.SFor (see Section~\ref{sec:SemanticsRule.SFor}),
\item SemanticsRule.SThrowNone (see Section~\ref{sec:SemanticsRule.SThrowNone}),
\item SemanticsRule.SThrowSomeTyped (see Section~\ref{sec:SemanticsRule.SThrowSomeTyped}),
\item SemanticsRule.STry (see Section~\ref{sec:SemanticsRule.STry}),
\item SemanticsRule.SDeclSome (see Section~\ref{sec:SemanticsRule.SDeclSome}),
\item SemanticsRule.SDeclNone (see Section~\ref{sec:SemanticsRule.SDeclNone}).
\end{itemize}

\section{SemanticsRule.SPass \label{sec:SemanticsRule.SPass}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a \texttt{pass} statement;
  \item \texttt{new\_env} is \texttt{env}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SPass.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SPass.asl}
  \texttt{pass;} does nothing.

  \subsection{Code}
  \VerbatimInput[firstline=\SPassBegin, lastline=\SPassEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  { \evalstmt{\env, \texttt{S\_Pass}} \evalarrow \Continuing(\emptygraph, \env) }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssign \label{sec:SemanticsRule.SAssign}}

  \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is an assignment \texttt{le = re};
  \item \texttt{v} is the evaluation of the expression \texttt{re} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
  \item \texttt{r\_env} is \texttt{env} modified after evaluation of the expression \texttt{re} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
  \item \texttt{new\_env} is \texttt{r\_env} modified after evaluation of \texttt{le} under \texttt{r\_env} with
    \texttt{v}, as per Chapter~\ref{chap:eval_lexpr}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SAssign.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssign.asl}
  \texttt{x = 3;} binds \texttt{x} to \texttt{3} in the environment where \texttt{x} is bound to \texttt{42}, and \texttt{new\_env} is such that \texttt{x} is bound to \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignBegin, lastline=\SAssignEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \vre} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \evallexpr{\envp, \vle, (\vv, \vgone)} \evalarrow \Normal(\vg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\vle, \vre)} \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignCall \label{sec:SemanticsRule.SAssignCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a subprogram call \texttt{(name, args, named\_args)};
  \item \texttt{vs} is the list of values resulting from the evaluation of the subprogram call;
  \item \texttt{env'} is the environment resulting from modifying \texttt{env} after the evaluation of the subprogram call;
  \item \texttt{new\_env} is the result of modifying \texttt{env'} after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignCall.asl}

\VerbatimInput{\testdir/SemanticsRule.SAssignCall.asl}
  given that the function call \texttt{f(1)} returns the pair of values \texttt{(1,2)}, statement \texttt{(a,b) = f(1)} assigns the value \texttt{1} to the mutable variable \texttt{a} and the value \texttt{2} to the mutable variable~\texttt{b}.
  \subsection{Code}
  \VerbatimInput[firstline=\SAssignCallBegin, lastline=\SAssignCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\newcommand\lexprisvar[0]{\texttt{lexpr\_is\_var}}

We first define two simple rules for the predicate $\lexprisvar$, which holds when a left-hand side expression
represents a variable, and then define the evaluation of assigning from a subprogram call.
\begin{mathpar}
  \inferrule{}{ \lexprisvar(\texttt{LE\_Var}(\Ignore)) }
  \and
  \inferrule{}{ \lexprisvar(\texttt{LE\_Discard}) }
  \and
  \inferrule{
    \vles = \vle_{i=1..k}\\
    i=1..k: \tododefine{lexpr\_is\_var}(\vle_i)\\
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal((\vvs, \vgone), \envp) \OrAbnormal\\
    \evalmultiassignment{\envp, \vles, \vvs} \evalarrow \Normal(\vgtwo, \newenv) \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\texttt{LE\_Destructuring}(\les),\texttt{E\_Call}(\name, \args, \namedargs))} \\
    \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssignTuple \label{sec:SemanticsRule.SAssignTuple}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} gives a left-hand-side tuple expression \texttt{les} and a tuple expression \texttt{exprs};
  \item \texttt{vs} is the list of values resulting from the evaluation of \texttt{exprs};
  \item \texttt{env'} is the environment resulting from modifying \texttt{env} after the evaluation of \texttt{exprs};
  \item \texttt{new\_env} is the result of modifying \texttt{env'} after assigning each values in \texttt{vs} to the elements of the tuple \texttt{les}.
  \end{itemize}

    \subsection{Example: SemanticsRule.SAssignTuple.asl}
\VerbatimInput{\testdir/SemanticsRule.SAssignTuple.asl}
statement \texttt{(b,x)} assigns the value \texttt{TRUE} to the mutable variable \texttt{b} and the value~\texttt{42} to the mutable variable~\texttt{x}.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssignTupleBegin, lastline=\SAssignTupleEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \vles = [\vle_{i=1..k}]\\
    i=1..k: \tododefine{lexpr\_is\_var}(\vle_i)\\
    \evalexprlistm{\env, \exprs} \evalarrow \Normal(\vms, \envp) \OrAbnormal\\
    \evalmultiassignment{\envp, \les, \vms} \evalarrow \Normal(\vg, \newenv) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Assign}(\texttt{LE\_Destructuring}(\vles), \texttt{E\_Tuple}(\exprs))} \\
    \evalarrow \Continuing(\vg, \newenv)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnNone \label{sec:SemanticsRule.SReturnNone}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{vs} is \texttt{[]};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SReturnNoneReturn.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnNone.asl}
    exits the current procedure.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnNoneBegin, lastline=\SReturnNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \texttt{S\_Return}(\None)} \evalarrow \Returning((\emptylist, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnOne \label{sec:SemanticsRule.SReturnOne}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives an expression \texttt{e};
    \item \texttt{v} is the evaluation of \texttt{e} under \texttt{env};
    \item \texttt{vs} is \texttt{[v]};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the expression \texttt{e} under \texttt{env} as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnOne.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnOne.asl}
    \texttt{return 3;} exits the current subprogram with value \texttt{3}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnOneBegin, lastline=\SReturnOneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \wid \in \identifier\text{ is fresh}\\
    \tododefine{write\_identifier}(\wid, \envp, \vv) = \vgtwo\\
    \vg = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Return}(\langle\ve\rangle)} \evalarrow \Returning(([\vv], \vg), \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SReturnSome \label{sec:SemanticsRule.SReturnSome}}

    \subsection{Prose}
Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{Returning vs} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{return} statement;
    \item \texttt{s} gives a list of expressions \texttt{es};
    \item \texttt{vs} is the result of the evaluation of each element of the list \texttt{es} under \texttt{env} as per Chapter~\ref{chap:eval_expr};
    \item \texttt{new\_env} is \texttt{env} modified after the evaluation of each element of the list \texttt{es} under \texttt{env} as per Chapter~\ref{chap:eval_expr}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SReturnSome.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SReturnSome.asl}
    \texttt{return (3, 42);} exits the current subprogram with value \texttt{(3, 42)}.

  \subsection{Code}
  \VerbatimInput[firstline=\SReturnSomeBegin, lastline=\SReturnSomeEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\newcommand\writefolder[1]{\texttt{write\_folder}(#1)}

We first define the helper relation
\[
  \writefolder{\envs, (\vals\times\XGraphs)^*} \bigtimes (\vals^*, \XGraphs)
\]

via the following two rules:
\begin{mathpar}
  \inferrule{}{
    \writefolder{\env, \emptylist} \evalarrow (\emptylist, \emptygraph)
  }
  \and
  \inferrule{
    \wid \in \identifier\text{ is fresh}\\
    \vm = (\vv, \vg)\\
    \tododefine{write\_identifier}(\wid, \env, \vv) \evalarrow \vgone\\
    \writefolder{\env, (\vms, \vgone)} \evalarrow (\vvs', \vgtwo)\\
  }
  {
    \writefolder{\env, ([\vm] + \vms, \vg)} \evalarrow ([\vv] + \vvs', \ordered{\vg}{\aslpo}{ (\ordered{\vgone}{\asldata}{\vgtwo}) })
  }
\end{mathpar}

We now use the helper relation to define the rule for returning a tuple of values:
\begin{mathpar}
  \inferrule{
    \evalexprlistm{\env, \es} \evalarrow \Normal(\ms, \newenv) \OrAbnormal\\
    \writefolder{\env, \ms} \evalarrow (\vvs, \vg)
  }
  {
    \evalstmt{\env, \texttt{S\_Return}(\langle\texttt{E\_Tuple}(\es)\rangle)} \evalarrow \Returning((\vvs, \vg), \newenv)
  }
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SSeq \label{sec:SemanticsRule.SSeq}}
  \subsection{Prose}
  The semantics of~\texttt{s1; s2} is the semantics of~\texttt{s2} applied to the results
  of the semantics of~\texttt{s1} if they do not perform an early return, in which
  case it is the semantics of~\texttt{s1}.
  The evaluation of two statements introduces an $\aslpo$ arrow between the two
  graphs produced by their interpretations.

  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
  \begin{itemize}
  \item \texttt{s} is a sequence statement \texttt{s1; s2};
  \item \texttt{env'} is \texttt{env} modified after evaluation of \texttt{s1};
  \item \texttt{new\_env} is \texttt{env'} modified after evaluation of \texttt{s2}.
  \end{itemize}

  \subsection{Example: SemanticsRule.SSeq.asl}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SSeq.asl}
  \texttt{let x = 3; let y = x + 1} evaluates \texttt{let x = 3} then \texttt{let y = x + 1}.

  \subsection{Code}
  \VerbatimInput[firstline=\SSeqBegin, lastline=\SSeqEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
\inferrule{
  \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone) \terminateas \Returning(\vvsg, \envp),\ExprThrowsConfig,\ErrorConfig\\
  \evalstmt{\envone, \vstwo} \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalstmt{\env, \texttt{S\_Seq}(\vsone, \vstwo)} \evalarrow \Continuing(\vg, \envtwo)
}
\and
\inferrule{
  \evalstmt{\env, \vsone} \evalarrow \Continuing(\vgone, \envone)\\
  \evalstmt{\envone, \vstwo} \evalarrow \Returning(\vvsg, \envtwo)\\
  \vg = \ordered{\vgone}{\aslpo}{\vgtwo}
}
{
  \evalstmt{\env, \texttt{S\_Seq}(\vsone, \vstwo)} \evalarrow \Returning(\vg, \envtwo)
}
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCall \label{sec:SemanticsRule.SCall}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a call statement;
    \item \texttt{s} gives a subprogram name \texttt{name} with actual arguments \texttt{actual\_args};
    \item \texttt{env'} is \texttt{env} modified after evaluation of the subprogram call;
    \item \texttt{new\_env} is \texttt{env'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCall.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCall.asl}
    \texttt{Zeros(3)} evaluates to \texttt{'000'}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCallBegin, lastline=\SCallEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalcall{\env, \name, \args, \namedargs} \evalarrow \Normal(\vg, \envp) \OrAbnormal
  }
  {
    \evalstmt{\env, \texttt{S\_Call}(\name, \args, \namedargs)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCond \label{sec:SemanticsRule.SCond}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and two conditional blocks \texttt{s1} and \texttt{s2};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of \texttt{s1} or \texttt{s2} depending on
      \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCond.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCond.asl}
    does not raise any Assertion Error.

  \subsection{Code}
  \VerbatimInput[firstline=\SCondBegin, lastline=\SCondEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
    \vv = B(\True)\\
    \evalblock{\envp, \vsone} \evalarrow C \OrAbnormal\\
    \vg = \ordered{\vgone}{\aslctrl}{\graphof{C}}
  }
  {
    \evalstmt{\env, \texttt{S\_Cond}(\ve, \vsone, \vstwo)} \evalarrow \withgraph{C}{\vg}
  }
\and
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \envp) \OrAbnormal\\
  \vv = B(\False)\\
  \evalblock{\envp, \vsone} \evalarrow C \OrAbnormal\\
  \vg = \ordered{\vgone}{\aslctrl}{\graphof{C}}
}
{
  \evalstmt{\env, \texttt{S\_Cond}(\ve, \vsone, \vstwo)} \evalarrow \withgraph{C}{\vg}
}
\end{mathpar}
\end{formal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SCase \label{sec:SemanticsRule.SCase}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} gives a condition \texttt{cond} and a number of statements \texttt{s\_1}, $\cdots$, \texttt{s\_n};
    \item \texttt{v\_cond} is the evaluation of \texttt{cond};
    \item \texttt{new\_env} is \texttt{env'} modified after evaluation of one of the statements \texttt{s\_i} depending on \texttt{v\_cond}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SCase.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SCase.asl}
    uses the second \texttt{when} clause because \texttt{3} is less than \texttt{42}.

  \subsection{Code}
  \VerbatimInput[firstline=\SCaseBegin, lastline=\SCaseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
A case statement is syntactic sugar for a ``condition-ladder''.
We use the AST-to-AST function \tododefine{case\_to\_conds} to convert a case statement
into a corresponding conditional statement.

\begin{mathpar}
  \inferrule{
    \tododefine{case\_to\_conds}(\ve, \texttt{alts}) = \vs\\
    \evalstmt{\env, \vs} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_Case}(\ve, \texttt{alts})} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SAssert \label{sec:SemanticsRule.SAssert}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} or an error and all of the following apply:
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is an \texttt{assert} statement;
    \item \texttt{s} gives an expression \texttt{e};
    \item \texttt{v} is the evaluation of the expression \texttt{e} as per Chapter~\ref{chap:eval_expr};
    \item One of the following applies:
          \begin{itemize}
          \item \texttt{v} is \texttt{true} and \texttt{new\_env} is \texttt{env},
          \item an ``AssertionFailed'' error is raised.
          \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.SAssertOk.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertOk.asl}
    \texttt{assert (42 != 3);} ensures that \texttt{3} is not equal to \texttt{42}.

    \subsection{Example: SemanticsRule.SAssertNo.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SAssertNo.asl}
    \texttt{assert (42 == 3);} raises an ``\texttt{AssertionFailed}'' error.

  \subsection{Code}
  \VerbatimInput[firstline=\SAssertBegin, lastline=\SAssertEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vg), \envp) \OrAbnormal\\
    \vv = B(\True)
  }
  {
    \evalstmt{\env, \texttt{S\_Assert}(\ve)} \evalarrow \Continuing(\vg, \envp)
  }
  \and
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vg), \envp)\\
    \vv = B(\False)
  }
  {
    \evalstmt{\env, \texttt{S\_Assert}(\ve)} \evalarrow \Error(\texttt{"Assertion failed!"})
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SWhile \label{sec:SemanticsRule.SWhile}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{while} statement;
    \item \texttt{s} gives an expression \texttt{e} and a loop body \texttt{body};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SWhile.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SWhile.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SWhileBegin, lastline=\SWhileEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalloop{\env, \True, \ve, \body} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_While}(\ve, \body)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SRepeat \label{sec:SemanticsRule.SRepeat}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{repeat} statement;
    \item \texttt{s} gives an expression \texttt{e} and a loop body \texttt{body};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the loop \texttt{(e,body)} as per Section~\ref{sec:SemanticsRule.Loop}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SRepeat.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SRepeat.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SRepeatBegin, lastline=\SRepeatEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \body} \evalarrow \Continuing(\vgone, \envone) \terminateas \Returning(\vvsg, \envp),\ExprThrowsConfig,\ErrorConfig\\
    \evalloop{\envone, \False, \ve, \body} \evalarrow C
  }
  {
    \evalstmt{\env, \texttt{S\_Repeat}(\ve, \body)} \evalarrow C
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SFor \label{sec:SemanticsRule.SFor}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{for} statement;
    \item \texttt{s} gives \texttt{(id,e1,dir,e2,s)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the \texttt{for} loop \texttt{(id,e1,dir,e2,s)} as per Section~\ref{sec:SemanticsRule.For}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SFor.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SFor.asl}
    prints ``\texttt{0123}''.

  \subsection{Code}
  \VerbatimInput[firstline=\SForBegin, lastline=\SForEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
Recall that the expression for the \texttt{for} loop range are side-effect-free, which means they are guaranteed to terminate normally.
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \vvone} \evalarrow \Normal((\vvone, \vgone), \env)\\
    \evalexpr{\env, \veone} \evalarrow \Normal((\vvtwo, \vgtwo), \env)\\
    \tododefine{declare\_local\_identifier}(\env, \id, \vvone) \evalarrow (\vgthree,\envone)\\
    \evalfor{\env, \id, \vvone, \dir, \vvtwo, \vs} \evalarrow \Normal(\vgfour, \envtwo) \OrAbnormal\\
    \tododefine{remove\_local}(\envtwo, \id) = \envthree\\
    \vg = \ordered{(\vgone \parallel \vgtwo)}{\asldata}{ \ordered{\vgthree}{\aslpo}{\vgfour}   }
  }
  {
    \evalstmt{\env, \texttt{S\_For}(\id, \veone, \dir, \vetwo, \vs)} \evalarrow \Continuing(\vg, \envthree)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowNone \label{sec:SemanticsRule.SThrowNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives no expression;
    \item \texttt{new\_env} is \texttt{env};
    \item an exception is thrown with \texttt{new\_env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowNone.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowNone.asl}
    throws a ``\texttt{MyException}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowNoneBegin, lastline=\SThrowNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalstmt{\env, \texttt{S\_Throw}(\None)} \evalarrow \Throwing((\None, \emptygraph), \env)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SThrowSomeTyped \label{sec:SemanticsRule.SThrowSomeTyped}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{throw} statement which gives an expression \texttt{e} and a type \texttt{t};
    \item \texttt{v} is the result of evaluating the expression \texttt{e} in \texttt{env};
    \item \texttt{new\_env} is the environment modified after evaluating the expression \texttt{e} in \texttt{env};
    \item an exception is thrown with \texttt{v} and \texttt{new\_env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SThrowSomeTyped.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SThrowSomeTyped.asl}
    throws a ``\texttt{MyException \{a: 3, b: 42\}}'' exception.

  \subsection{Code}
  \VerbatimInput[firstline=\SThrowSomeTypedBegin, lastline=\SThrowSomeTypedEnd]{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\
    \vgtwo = \WriteEffect(\name)\\
    \name\in\identifier \text{ is fresh}\\
    \vg' = \ordered{\vgone}{\asldata}{\vgtwo}
  }
  {
    \evalstmt{\env, \texttt{S\_Throw}(\langle\ve, \langle\vt\rangle\rangle)} \evalarrow \Throwing((\langle(\vv,\vt)\rangle, \vg'), \env)
  }
  \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.STry \label{sec:SemanticsRule.STry}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a \texttt{try} statement \texttt{[(s', catchers, otherwise\_opt)};
    \item \texttt{s\_m} is the evaluation of the block \texttt{s'} under \texttt{env};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the
catchers \\ \texttt{(catchers otherwise\_opt s\_m)} as per
Chapter~\ref{chap:eval_catchers}.
    \end{itemize}

    \subsection{Example: SemanticsRule.STry.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.STry.asl}
    does not raise any Assertion error, and the program terminates with the exit code 0.

  \subsection{Code}
  \VerbatimInput[firstline=\STryBegin, lastline=\STryEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalblock{\env, \vs} \evalarrow C \OrAbnormal\\
    \evalcall{\env, \catchers, \otherwiseopt, C} \evalarrow C'
  }
  {
    \evalstmt{\env, \texttt{S\_Try}(\vs, \catchers, \otherwiseopt)} \evalarrow C'
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclSome \label{sec:SemanticsRule.SDeclSome}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, Some e)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the local declaration
      \texttt{ldi env (Some m)} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclSome.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclSome.asl}
    \texttt{let x = 3;} binds \texttt{x} to \texttt{3} in the empty environment.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclSomeBegin, lastline=\SDeclSomeEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \ve} \evalarrow \Normal(\vm, \envone) \OrAbnormal\\
    \evallocaldecl{\envone, \vs, \ldi, \langle\vm\rangle} \evalarrow \Normal(\vg, \envp)\\
  }
  {
    \evalstmt{\env, \texttt{S\_Decl}(\Ignore, \ldi, \langle\ve\rangle)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.SDeclNone \label{sec:SemanticsRule.SDeclNone}}

    \subsection{Prose}
  Evaluation of the statement \texttt{s} under environment \texttt{env} is
\texttt{new\_env} and all of the following apply:
    \begin{itemize}
    \item \texttt{s} is a declaration \texttt{(ldi, None)};
    \item \texttt{new\_env} is \texttt{env} modified after evaluation of the local declaration
      \texttt{ldi env None} as per Chapter~\ref{chap:eval_local_decl}.
    \end{itemize}

    \subsection{Example: SemanticsRule.SDeclNone.asl}
    In the program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.SDeclNone.asl}
    \texttt{var x : integer;} binds \texttt{x} in \texttt{env} to the base value of \texttt{integer}.

  \subsection{Code}
  \VerbatimInput[firstline=\SDeclNoneBegin, lastline=\SDeclNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evallocaldecl{\envone, \vs, \ldi, \None} \evalarrow \Normal(\vg, \envp)\\
  }
  {
    \evalstmt{\env, \texttt{S\_Decl}(\Ignore, \ldi, \langle\ve\rangle)} \evalarrow \Continuing(\vg, \envp)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Blocks \label{chap:eval_block}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SemanticsRule.Block \label{sec:SemanticsRule.Block}}

    \subsection{Prose}
    \texttt{eval\_block env stm} is \texttt{new\_env} and all of the following applies:
    \begin{itemize}
    \item \texttt{block\_env'} is \texttt{env} modified after the evaluation of the statement \texttt{stm} as per Chapter~\ref{chap:eval_stmt};
    \item \texttt{new\_env} is \texttt{block\_env'} after restoring the
variable bindings of \texttt{env} with the updated values of
\texttt{block\_env'}.
    \end{itemize}

    \subsection{Example: SemanticsRule.Block.asl}
    In the program:
    \VerbatimInput{\testdir/SemanticsRule.Block.asl}
    the conditional statement \texttt{if TRUE then\ldots{} end;} defines a
block structure. Thus, the scope of the declaration \texttt{let y = 2;} is
limited to its declaring block---or the binding for \texttt{y} no longer exists
once the block is exited. As a consequence, the subsequent declaration
\texttt{let y = 1} is valid.  By contrast, the assigment of the mutable
variable~\texttt{x} persists after block end. However, observe that \texttt{x}
is defined before the block and hence still exists after the block.

  \subsection{Code}
    \VerbatimInput[firstline=\BlockBegin,lastline=\BlockEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
The \emph{restriction} of a function $f : X \rightarrow Y$ to a subset of its domain values
$A \subseteq \dom(f)$, denoted as $f|_A$, is defined as follows (by defining the graph of the resulting function):
\[
  f|_A \triangleq \{ (x, f(x)) \;|\; x \in A \} \enspace.
\]

\begin{mathpar}
  \inferrule{
    \env=(\tenv,\denv)\\
    \blockenv = (\tenv, (G^\denv, \emptylist))\\
    \evalstmt{\env, \stm} \evalarrow \Continuing(\vg, \blockenv') \OrAbnormal\\
    \blockenv'=(\tenv, \denv')\\
    \newenv = (\tenv, (G^{\denv'}, L^{\denv'}|_{\dom(L^\denv)}))
  }
  {
    \evalblock{\env, \stm} \evalarrow \Continuing(\vg, \newenv)
  }
  \and
  \inferrule{
    \env=(\tenv,\denv)\\
    \blockenv = (\tenv, (G^\denv, \emptylist))\\
    \evalstmt{\env, \stm} \evalarrow \Returning((\vv_{1..k},\vg), \blockenv')\\
    \blockenv'=(\tenv, \denv')\\
    \newenv = (\tenv, (G^{\denv'}, L^{\denv'}|_{\dom(L^\denv)}))
  }
  {
    \evalblock{\env, \stm} \evalarrow \Returning((\vv_{1..k},\vg), \newenv)
  }
\end{mathpar}

That is, evaluating a block discards the bindings for variables declared inside $\stm$.
\end{emptyformal}

\isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Loops \label{chap:eval_loops}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The evaluation of loop is a common part of the evaluation of multiple loop
statements.
%
For example, the semantic rule \emph{Loop} is used by the semantic rule
\emph{SWhile} at Section~\ref{sec:SemanticsRule.SWhile} and the semantic rule
\emph{SRepeat} at Section~\ref{sec:SemanticsRule.SRepeat}.
%
The semantic rule \emph{For} is only used by the semantic rule \emph{SFor} at
Section~\ref{sec:SemanticsRule.SFor}.

\section{SemanticsRule.Loop \label{sec:SemanticsRule.Loop}}
\texttt{eval\_loop is\_while env e\_cond body} evaluates \texttt{body} in
\texttt{env}: this is either an interruption \texttt{Returning vs}, a
\texttt{Throwing} or a new environment \texttt{new\_env}.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{e\_cond} or \texttt{not e\_cond} as
determined by \texttt{is\_while} and one of the following applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item \texttt{new\_env} is \texttt{env}---the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item \texttt{env1} is \texttt{env} modified after the evaluation of the
statement \texttt{body}---this step might affect the value of \texttt{cond\_m}
eventually leading to exiting the loop;
      \item \texttt{new\_env} is \texttt{env1} modified after the evaluation of
\texttt{eval\_loop is\_while env e\_cond body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Loop.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Loop.asl}
    does not raise any Assertion Error and the program terminates with exit
    code 0.

    \subsection{Code}
    \VerbatimInput[firstline=\LoopBegin, lastline=\LoopEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone) \OrAbnormal\\
    \condm = (B(\False), \vgone)
  }
  {
    \evalloop{\env, \econd, \body} \evalarrow \Continuing(\vgone, \envone)
  }
\and
  \inferrule{
    \evalexpr{\env, \econd} \evalarrow \Normal(\condm, \envone)\\
    \condm = (B(\True), \vgone)\\
    \evalblock{\envone, \body} \evalarrow \Continuing(\vgtwo, \envtwo) \OrAbnormal\\
    \evalloop{\envtwo, \iswhile, \econd, \body} \evalarrow \Continuing(\vgthree, \envthree)\\
    \vg = \ordered{\ordered{\vgone}{\aslctrl}{\vgtwo}}{\aslpo}{\vgthree}
  }
  {
    \evalloop{\env, \econd, \body} \evalarrow \Continuing(\vg, \envthree)
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.For \label{sec:SemanticsRule.For}}
\texttt{eval\_for undet env index\_name v\_start dir v\_end body} evaluates
\texttt{body} in \texttt{env}: this is either an interruption \texttt{Returning
vs} or a new environment \texttt{new\_env}.

    \subsection{Prose}
    \texttt{cond\_m} evaluates to \texttt{leq v\_end v\_start} or \texttt{geq
v\_end v\_start} as determined by \texttt{dir} and one of the following
applies:
    \begin{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{true};
      \item \texttt{new\_env} is \texttt{env} as the loop is exited.
      \end{itemize}
    \item All of the following apply:
      \begin{itemize}
      \item \texttt{cond\_m} evaluates to \texttt{false};
      \item \texttt{env1} is \texttt{env} modified after the evaluation of the statement \texttt{body};
      \item \texttt{env2} is \texttt{env1} modified such that \texttt{index\_name} is bound to \texttt{v\_step};
      \item \texttt{v\_step} evaluates to \texttt{v\_start+1} or \texttt{v\_start-1} as determined by \texttt{dir};
      \item \texttt{new\_env} is \texttt{env2} modified after the evaluation of \texttt{eval\_for undet
        env index\_name v\_step dir v\_end body}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.For.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.For.asl}
    does not raise any assertion error, and the program terminates with exit-code 0.

    \subsection{Code}
    \VerbatimInput[firstline=\ForBegin, lastline=\ForEnd]{../Interpreter.ml}

\begin{emptyformal}
    \subsection{Formally}
    Intuitively, a \texttt{for}-loop \texttt{for $i$ = $e_1$ to $e_2$ do $S$} is syntactic sugar for
    \texttt{$i$ = $e_1$; while $i$ < $e_2$ do $S$; $i$=$i$+1 end}.
    Similarly, \texttt{for $i$ = $e_1$ downto $e_2$ do $S$} is syntactic sugar for
    \texttt{$i$ = $e_1$; while $i$ > $e_2$ do $S$; $i$=$i$-1 end}. The important difference between
    the statement involving the \texttt{while} loop and the original \texttt{for} loop is that the
    scope of the counter variable is restricted to the body of the \texttt{for}. Notice that this
    aspect is already handled by the rule for \texttt{S\_For}.

    To reflect this, we constructs the following two ASTs for each of the cases for the direction of the loop:
\[
\begin{array}{rcl}
  \texttt{Ei}         &\triangleq& \texttt{E\_Var}(\vindexname)\\
  \texttt{plus\_one}   &\triangleq& \texttt{S\_Assign}(\texttt{Ei}, \texttt{E\_Binop}(\texttt{"+"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
  \texttt{Up\_for\_body}  &\triangleq& \texttt{S\_Seq}(\body, \texttt{plus\_one})\\
  \texttt{Up\_cond}       &\triangleq& \texttt{E\_Binop}(\texttt{LT}, \texttt{Ei}, \vend)\\
  \texttt{Up\_for}       &\triangleq& \texttt{S\_Seq}(\texttt{S\_Assign}(\texttt{Ei}, \vstart), \texttt{S\_While}(\texttt{Up\_cond}, \texttt{Up\_for\_body}))\\
  \hline
  \texttt{minus\_one}   &\triangleq& \texttt{S\_Assign}(\texttt{Ei}, \texttt{E\_Binop}(\texttt{"-"}, \texttt{Ei}, \texttt{E\_Lit}(\texttt{L\_Int}(1))))\\
  \texttt{Down\_for\_body}  &\triangleq& \texttt{S\_Seq}(\body, \texttt{minus\_one})\\
  \texttt{Down\_cond}       &\triangleq& \texttt{E\_Binop}(\texttt{GT}, \texttt{Ei}, \vend)\\
  \texttt{Down\_for}       &\triangleq& \texttt{S\_Seq}(\texttt{S\_Assign}(\texttt{Ei}, \vstart), \texttt{S\_While}(\texttt{Down\_cond}, \texttt{Down\_for\_body}))
\end{array}
\]

  We now use the (de-sugared) ASTs to evaluate the statement:
\begin{mathpar}
  \inferrule{
    \evalstmt{\env, \texttt{Up\_for}} \evalarrow C
  }
  {
    \evalfor{\env, \vindexname, \vstart, \texttt{Up}, \vend, \body} \evalarrow C
  }
  \and
  \inferrule{
    \evalstmt{\env, \texttt{Down\_for}} \evalarrow C
  }
  {
    \evalfor{\env, \vindexname, \vstart, \texttt{Down}, \vend, \body} \evalarrow C
  }
\end{mathpar}

% \newcommand\compfordir[0]{\texttt{comp\_for\_dir}}
% \newcommand\opfordir[0]{\texttt{op\_for\_dir}}
% \[
%   \begin{array}{rl}
%     \compfordir = &\lambda d.\
%  \left\{
%   \begin{array}{ll}
%     \texttt{LT}, & x=\texttt{Up}\\
%     \texttt{GT}, & x=\texttt{Down}\\
%   \end{array}\right.\\
%   \opfordir = &\lambda d.\
%  \left\{
%   \begin{array}{ll}
%     \texttt{PLUS}, & x=\texttt{Up}\\
%     \texttt{MINUS}, & x=\texttt{Down}\\
%   \end{array}\right.
% \end{array}
%   \]

% \begin{mathpar}
%   \inferrule{
%     %\op = \dir=\texttt{UP} ? \texttt{LT} : \texttt{GT}\\
%     \tododefine{read\_identifier}(\env, \vindexname, \vstart) \evalarrow \vgone\\
%     \binop(\compfordir(\dir), \vend, \vstart) \evalarrow \condm\\
%     \condm = (\condv, \condg)\\
%     \ordered{\vgone}{\asldata}{\condg}\\
%     %\opfordir(\dir)
%   }
%   {
%     \evalfor{\env, \vindexname, \vstart, \dir, \vend, \body} \evalarrow
%   }
% \end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\chapter{Evaluation of Catchers \label{chap:eval_catchers}}
\texttt{eval\_catchers env catchers otherwise\_opt s\_m}, given the result
\texttt{s\_m} of the evaluation of a statement under environment \texttt{env}
is \texttt{res} which is either a \texttt{Throwing (v, v\_ty, env\_throw)}, an
interruption \texttt{Returning vs} or a new environment \texttt{new\_env}.
Formally, one of the following applies:
\begin{itemize}
\item SemanticsRule.Catch (see Section~\ref{sec:SemanticsRule.Catch}),
\item SemanticsRule.CatchNamed (see Section~\ref{sec:SemanticsRule.CatchNamed}),
\item SemanticsRule.CatchOtherwise (see Section~\ref{sec:SemanticsRule.CatchOtherwise}),
\item SemanticsRule.CatchNone (see Section~\ref{sec:SemanticsRule.CatchNone}),
\item SemanticsRule.CatchNoThrow (see Section~\ref{sec:SemanticsRule.CatchNoThrow}).
\end{itemize}

\newcommand\findcatcher[0]{\texttt{find\_catcher}}
We define the (recursive) helper function $\findcatcher : (\staticenvs \times \ty, \catcher^*) \rightarrow \langle \catcher \rangle$,
which returns the first catcher clause that matches the given type (as a singleton set), or an empty set:
\begin{mathpar}
  \inferrule{}{\findcatcher(\tenv, \vvty, \emptylist) \evalarrow \None}
\and
\inferrule{
  \vc = (\nameopt, \ety, \vs) \\
  \typesatisfies(\tenv, \vvty, \ety)
}
{
  \findcatcher(\tenv, \vvty, \vc + \catchers) = \langle\vc\rangle
}
\and
\inferrule{
  \vc = (\nameopt, \ety, \vs) \\
  \neg\typesatisfies(\tenv, \vvty, \ety)\\
  \findcatcher(\tenv, \vvty, \catchers) = C
}
{
  \findcatcher(\tenv, \vvty, \vc + \catchers) = C
}
\end{mathpar}

We define the helper relation
\[
  \rethrowimplicit : (\identifier \times \ty \times \TConfig) \rightarrow \TConfig
\]
via the following rules:
\begin{mathpar}
  \inferrule{}
  {
    \rethrowimplicit(\vv, \vvty, \Throwing((\None, \vg), \envthrowone)) \evalarrow \\
    \Throwing((\langle(\vv, \vvty)\rangle, \vg), \envthrowone)
  }
\and
\inferrule{}
{
  \rethrowimplicit(\vv, \vvty, \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)) \evalarrow \\
  \Throwing((\langle(\vv', \vvty')\rangle, \vg), \envthrowone)
}
\and
\inferrule{
  \configmode{C} \neq \Throwing
}
{
  \rethrowimplicit(\Ignore, \Ignore, C, \Ignore)) \evalarrow C
}
\end{mathpar}
This function changes \emph{implicit throwing configurations}, that is, $\Throwing$ configurations with an empty
variable name and exception type, such that they include the given variable name and exception type.
Other configurations remain unchanged.

\section{SemanticsRule.Catch \label{sec:SemanticsRule.Catch}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} does not declare a name;
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.Catch.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.Catch.asl}
    prints ``\texttt{MyException}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchBegin, lastline=\CatchEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env = (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \langle (\None, \Ignore, \vs) \rangle\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \rethrowimplicit(\vv, \vvty, C) = D\\
    \vg = \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNamed \label{sec:SemanticsRule.CatchNamed}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{catcher} is the first catcher in \texttt{catchers} that matches \texttt{v\_ty};
    \item \texttt{catcher} declares a name \texttt{name};
    \item \texttt{catcher} gives a statement \texttt{s};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \item \texttt{env2} is \texttt{env1} modified after binding locally \texttt{name} to the exception
        \texttt{v} raised by \texttt{s\_m};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env2}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{env3} is \texttt{env2} modified after the evaluation of the block \texttt{s} in
        \texttt{env2}, and \texttt{new\_env} is \texttt{env3} modified after unbinding \texttt{name} from
        \texttt{env3}.
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env2}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNamed.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNamed.asl}
    prints ``\texttt{My exception with my message}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNamedBegin, lastline=\CatchNamedEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env = (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \langle (\langle\name\rangle, \Ignore, \vs) \rangle\\
    \tododefine{read\_value\_from}(\vv) = (\vvone, \vgone)\\
    \tododefine{declare\_local\_identifier\_m}(\envone, \name, (\veone, \vgone)) = (\envtwo, \vgtwo)\\
    \evalblock{\envtwo, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \envthree = \environof{C}\\
    \rethrowimplicit(\vv, \vvty, \withenviron{C}{\tododefine{remove\_local}(\envthree)}) = D\\
    \vg = \ordered{\sg}{\aslpo}{ \ordered{\ordered{\vgone}{\aslpo}{\vgtwo}}{\aslpo}{\graphof{D}} }
  }
  {
    \evalcatchers{\env, \catchers, \otherwiseopt, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchOtherwise \label{sec:SemanticsRule.CatchOtherwise}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{Some s};
    \item no catcher matches \texttt{v\_ty};
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{env\_throw} and \texttt{env} have the same scope, and \texttt{env1} is \texttt{env\_throw};
      \item \texttt{env1} is the environment formed with the global part of \texttt{env\_throw}
        and the local part of \texttt{env};
      \end{itemize}
    \item One of the following applies:
      \begin{itemize}
      \item \texttt{Throwing (None, None, env\_throw1)} is the result of the evaluation of
        the block \texttt{s} in \texttt{env1}, and \texttt{res} is \texttt{Throwing (v, v\_ty, env\_throw1)};
      \item \texttt{res} is the result of the evaluation of the block \texttt{s} in \texttt{env1}.
      \end{itemize}
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchOtherwise.asl}
     The program:
     \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchOtherwise.asl}
     prints ``\texttt{Another exception}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchOtherwiseBegin, lastline=\CatchOtherwiseEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env = (\tenv, (G^\denv, L^\denv))\\
    \envthrow = (\tenv, (G^{\denvthrow}, L^{\denvthrow}))\\
    \envone = (\tenv, (G^{\denvthrow}, L^{\denv}))\\
    \findcatcher(\tenv, \vvty, \catchers) = \None\\
    \evalblock{\envone, \vs} \evalarrow C \terminateas \ErrorConfig\\
    \rethrowimplicit(\vv, \vvty, C) = D\\
    \vg = \ordered{\sg}{\aslpo}{\graphof{D}}
  }
  {
    \evalcatchers{\env, \catchers, \langle\vs\rangle, \sm} \evalarrow \withgraph{D}{\vg}
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNone \label{sec:SemanticsRule.CatchNone}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is \texttt{Throwing (v, v\_ty, env\_throw)};
    \item \texttt{otherwise\_opt} is \texttt{None};
    \item no catcher matches \texttt{v\_ty};
    \item \texttt{new\_env} is \texttt{env}.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNone.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNone.asl}
    does not print anything.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoneBegin, lastline=\CatchNoneEnd]{../Interpreter.ml}

\begin{emptyformal}
\subsection{Formally}
  \begin{mathpar}
  \inferrule{
    \sm = \Throwing((\langle \vv, \vvty \rangle, \sg), \envthrow)\\
    \env = (\tenv, (G^\denv, L^\denv))\\
    \findcatcher(\tenv, \vvty, \catchers) = \None
  }
  {
    \evalcatchers{\env, \catchers, \None, \sm} \evalarrow \sm
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.CatchNoThrow \label{sec:SemanticsRule.CatchNoThrow}}

    \subsection{Prose}
    All of the following apply:
    \begin{itemize}
    \item \texttt{s\_m} is not \texttt{Throwing};
    \item \texttt{res} is \texttt{s\_m}.
    \end{itemize}

    \subsection{Example: SemanticsRule.CatchNoThrow.asl}
    The program:
    \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.CatchNoThrow.asl}
    prints ``\texttt{No exception raised}''.

  \subsection{Code}
  \VerbatimInput[firstline=\CatchNoThrowBegin, lastline=\CatchNoThrowEnd]{../Interpreter.ml}

  % For some reason the emptyformal environment here fails LaTeX compilation.
  %\begin{emptyformal}
    \subsection{Formally}
      \begin{mathpar}
      \inferrule{
        \sm = \Throwing((\None, \sg), \envthrow)
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
      \and
      \inferrule{
        \configmode{\sm} = \Normal
      }
      {
        \evalcatchers{\env, \catchers, \Ignore, \sm} \evalarrow \sm
      }
    \end{mathpar}
  %\end{emptyformal}

  \isempty{\subsection{Comments}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation of Functions \label{chap:eval_func}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\texttt{eval\_func genv name pos actual\_args params} evaluates the subprogram \\
named \texttt{name} in the global environment \texttt{genv}, with
\texttt{actual\_args} the list of actual arguments, and \texttt{params} the
list of arguments deduced by type equality. This is a new global environment
\texttt{new\_genv} and a list of values \texttt{vs}, or an error is raised.
One of the following applies:
\begin{itemize}
\item SemanticsRule.FPrimitive (see Section~\ref{sec:SemanticsRule.FPrimitive}),
\item SemanticsRule.FCall (see Section~\ref{sec:SemanticsRule.FCall}).
\end{itemize}

\section{SemanticsRule.FPrimitive \label{sec:SemanticsRule.FPrimitive}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a primitive subprogram with a body \texttt{body};
  \item \texttt{new\_genv} is \texttt{genv};
  \item \texttt{vs} is the application of \texttt{body} on \texttt{actual\_args}.
  \end{itemize}

  \subsection{Example}
  In the program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FPrimitive.asl}
  \texttt{print ("Hello, world!");} calls the primitive \texttt{print} on the evaluation of \texttt{"Hello, world!"}.

  \subsection{Code}
  \VerbatimInput[firstline=\FPrimitiveBegin, lastline=\FPrimitiveEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally}
\begin{mathpar}
  \inferrule{}
  {
    \evalfunc{\env, \name, \actualargs} \evalarrow
  }
\end{mathpar}
\end{emptyformal}

\isempty{\subsection{Comments}}

\section{SemanticsRule.FCall \label{sec:SemanticsRule.FCall}}

  \subsection{Prose}
  All of the following apply:
  \begin{itemize}
  \item \texttt{name} is bound in \texttt{genv} to a subprogram with a list of formal arguments
    \texttt{arg\_decls} and a body statement \texttt{body};
  \item \texttt{env1} is the environment made of \texttt{genv} and the empty local environment,
  \item \texttt{env2} is \texttt{env1} modified so that each formal argument in \texttt{arg\_decls} is
    locally bound to the corresponding actual argument in \texttt{actual\_args};
  \item \texttt{env3} is \texttt{env2} modified so that each parameter in \texttt{params} is declared;
  \item \texttt{res} is the evaluation of \texttt{body} in \texttt{env3} and one of the following
    applies:
      \begin{itemize}
      \item \texttt{res} is an environment \texttt{env4} and \texttt{new\_genv} is the global environment
        given by \texttt{env4}---e.g. where the subprogram called is either a setter or
        a procedure;
      \item \texttt{res} is an interruption \texttt{Returning(xs,ret\_genv)} and \texttt{new\_genv} is
        \texttt{ret\_genv}---this is the general case.
      \end{itemize}
  \end{itemize}

  \subsection{Example: SemanticsRule.FCall.asl}
  The program:
  \VerbatimInput{../tests/ASLSemanticsReference.t/SemanticsRule.FCall.asl}
  calls the function \texttt{foo} and the procedure \texttt{bar}.

  \subsection{Code}
  \VerbatimInput[firstline=\FCallBegin, lastline=\FCallEnd]{../Interpreter.ml}

\begin{formal}
  \subsection{Formally: sequential case}
  The evaluation of a n-ary subprogram evaluates the arguments in order then
  calls the subprogram:
  \begin{align}
  \interp{f (e_1, \dotsc e_n)} (E_0) & \triangleq
    \left\{ (v, E') \st{}
    \begin{aligned}
      & \forall i \in \semantic{ 1, n }, (v_i, E_i) \in \interp{e_i} (E_{i - 1})
      \\ \text{and}\ &
      (v, E') \in \interp{\left\langle f, v_1, \dotsc v_n \right\rangle} \left(E_n\right)
    \end{aligned}
    \right\}
  \label{eq:sem-seq-fcall}
  \end{align}

  \subsection{Formally: concurrent case}
  For $i$ ranging implicitly from 1 to $n$ included, a call to a subprogram $f$
  is interpreted as the interpretation of the subprogram call (see to $f$ after
  evaluating every argument in order:

  \begin{align}
    \interp{f (e_i)} (E_0) \triangleq
      \left\{ (v, E', S) \st{}
      \begin{aligned}
        & % \forall i \in \semantic{ 1, n },
          (v_i, E_i, S_i) \in \interp{e_i} (E_{i - 1})
        \\ \text{and}\ &
        (v, E', S) \in \interp{\left\langle f, (v_i,S_i) \right\rangle} \left(E_n\right)
      \end{aligned}
      \right\}
    \label{eq:sem-conc-fcall}
  \end{align}
\end{formal}

  \subsection{Comments}
  This is related to \identr{DFWZ}.

\chapter{Evaluation of Programs}

  \section{SemanticsRule.TopLevel \label{sec:SemanticsRule.TopLevel}}

  \subsection{Prose}
  The evaluation of a program \texttt{ast} is \texttt{res} or an error
  and all of the following apply:
  \begin{itemize}
  \item \texttt{ast’} is \texttt{ast} modified to add the standard library;
  \item \texttt{ast\_typed, static\_env} is the result of typing \texttt{ast’};
  \item \texttt{genv} is the global environment built using \texttt{static\_env} and evaluating the global constants in \texttt{ast\_typed} following the Directed Acyclic Graph of their definitions;
  \item \texttt{res} is the result of evaluating the function ``\texttt{main}, without any argument, in \texttt{genv};
  \item One of the following applies:
        \begin{itemize}
	\item \texttt{res} is a value \texttt{v}, or
	\item All of the following apply:
              \begin{itemize}
              \item \texttt{res} is an implicitly thrown exception;
	      \item An error ``\texttt{Uncaught exception: implicitly thrown out of a try-catch}'' is raised;
              \end{itemize}
	\item All of the following apply:
              \begin{itemize}
              \item \texttt{res} is an exception \texttt{exn} with an associated type \texttt{ty};
	      \item An error ``\texttt{Uncaught exception: \{ty\} \{exn\}}'' is raised.
              \end{itemize}
        \end{itemize}
  \end{itemize}

  \subsection{Example}

  \subsection{Code}
  \VerbatimInput[firstline=\TopLevelBegin, lastline=\TopLevelEnd]{../Interpreter.ml}

\begin{emptyformal}
  \subsection{Formally: sequential case}

  \subsection{Formally: concurrent case}
\end{emptyformal}

\isempty{\subsection{Comments}}

\bibliographystyle{plain}
\bibliography{ASL}
\end{document}
