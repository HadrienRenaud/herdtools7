\chapter{Subprogram Declarations\label{chap:SubprogramDeclarations}}

Subprogram declarations are grammatically derived from $\Ndecl$ via the subset of productions shown in
\secref{SubprogramDeclarationsSyntax} and represented as ASTs via the production of $\decl$
shown in \secref{SubprogramDeclarationsAbstractSyntax}.
%
Subprogram declarations are typed via $\annotateanddeclarefunc$, which is defined in \nameref{sec:TypingRule.AnnotateAndDeclareFunc}.
%
Subprogram declarations have no associated semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax\label{sec:SubprogramDeclarationsSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Ndecl  \derivesinline\ & \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \parsesep \Nrecurselimit \\
& \wrappedline\ \parsesep \Nfuncbody &\\
|\ & \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nfuncbody &\\
|\ & \Tgetter \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \parsesep \Nfuncbody&\\
|\ & \Tsetter \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Teq \parsesep \Ntypedidentifier & \\
    & \wrappedline\ \parsesep \Nfuncbody &\\
\end{flalign*}

\begin{flalign*}
\Nrecurselimit   \derivesinline\ & \Trecurselimit \parsesep \Nexpr &\\
|\              & \emptysentence &\\
\Nparamsopt \derivesinline\ & \emptysentence &\\
                   |\ & \Tlbrace \parsesep \Clist{\Nopttypedidentifier} \parsesep \Trbrace &\\
\Nopttypedidentifier \derivesinline\ & \Tidentifier \parsesep \option{\Nasty} &\\
\Nfuncargs          \derivesinline\ & \Tlpar \parsesep \Clist{\Ntypedidentifier} \parsesep \Trpar &\\
\Nreturntype        \derivesinline\ & \Tarrow \parsesep \Nty &\\
\Nfuncbody          \derivesinline\ & \Tbegin \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nmaybeemptystmtlist \derivesinline\ & \emptysentence \;|\; \Nstmtlist &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax\label{sec:SubprogramDeclarationsAbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\decl \derives\ & \DFunc(\func) &
\end{flalign*}

\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& (\identifier, \ty?)^*,\\
 \funcargs &:& \typedidentifier^*,\\
 \funcbody &:& \subprogrambody,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype,\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool
\end{array}
\right\}
} &\\
\typedidentifier \derives\ & (\identifier, \ty) &\\
\subprogrambody \derives\ & \SBASL(\stmt) \;|\; \SBPrimitive &\\
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &
\end{flalign*}

\subsubsection{ASTRule.GlobalDecl}
The relation
\[
  \builddecl : \overname{\parsenode{\Ndecl}}{\vparsednode} \;\aslrel\; \overname{\decl}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\hypertarget{build-funcdecl}{}
\begin{mathpar}
\inferrule[func\_decl]{}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
    \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nreturntype}, \\
    \wrappedline\ \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
  \right)}{\vparsednode}\right)
\astarrow \\
{
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \langle \astof{\vreturntype} \rangle,\\
            \funcsubprogramtype &:& \STFunction,\\
            \funcrecurselimit   &:& \langle\astof{\vrecurselimit}\rangle\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)}{\vastnode}
  }
}
\end{mathpar}

\hypertarget{build-procedureecl}{}
\begin{mathpar}
\inferrule[procedure\_decl]{}{
  \builddecl(
    \overname{\Ndecl(\Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nfuncbody})}{\vparsednode}
    )
  \astarrow \\
  {
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STProcedure,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
    }{\vastnode}
  }
}
\end{mathpar}

\hypertarget{build-getter}{}
\begin{mathpar}
\inferrule[getter]{}{
  {
    \begin{array}{r}
  \builddecl\left(\overname{\Ndecl\left(
    \begin{array}{l}
      \Tgetter, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \\
      \wrappedline\ \punnode{\Nreturntype}, \punnode{\Nfuncbody}
    \end{array}
      \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \langle \astof{\vreturntype}\rangle,\\
            \funcsubprogramtype &:& \STGetter,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
  }{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\hypertarget{build-setter}{}
\begin{mathpar}
\inferrule[setter]{}{
  {
      \builddecl\left(\overname{\Ndecl\left(
        \begin{array}{r}
          \Tsetter, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \Teq, \\
   \wrappedline\ \namednode{\vv}{\Ntypedidentifier}, \punnode{\Nfuncbody}
        \end{array}
   \right)}{\vparsednode}\right)
  } \astarrow
  \\
  {
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& [\vv] \concat \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STSetter,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
    }{\vastnode}
  }
}
\end{mathpar}

\subsubsection{ASTRule.RecurseLimit}
\hypertarget{build-recurselimit}{}
The function
\[
\buildrecurselimit(\overname{\parsenode{\Nrecurselimit}}{\vparsednode}) \aslto \overname{\langle\expr\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\Trecurselimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.TypedIdentifier \label{sec:ASTRule.TypedIdentifier}}
\hypertarget{build-typedidentifier}{}
The function
\[
\buildtypedidentifier(\overname{\parsenode{\Ntypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \ty)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildtypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \punnode{\Nasty})}{\vparsednode}) \astarrow \overname{(\id,\astof{\vasty})}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.OptTypedIdentifier \label{sec:ASTRule.OptTypedIdentifier}}
\hypertarget{build-opttypedidentifier}{}
The function
\[
\buildopttypedidentifier(\overname{\parsenode{\Nopttypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \langle\ty\rangle)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\Nasty](\vastyopt) \astarrow \astversion{\vastyopt}
}{
  {
  \begin{array}{r}
  \buildopttypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \namednode{\vastyopt}{\option{\Nasty}})}{\vparsednode}) \astarrow \\
  \overname{(\id, \astversion{\vastyopt})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\subsubsection{ASTRule.ReturnType \label{sec:ASTRule.ReturnType}}
\hypertarget{build-returntype}{}
The function
\[
\buildreturntype(\overname{\parsenode{\Nreturntype}}{\vparsednode}) \aslto \overname{\ty}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildreturntype(\overname{\Nreturntype(\Tarrow, \punnode{\Nty})}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.ParamsOpt \label{sec:ASTRule.ParamsOpt}}
\hypertarget{build-paramsopt}{}
The function
\[
\buildparamsopt(\overname{\parsenode{\Nparamsopt}}{\vparsednode}) \aslto
  \overname{(\identifier\times\langle\ty\rangle)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildparamsopt(\overname{\Nparamsopt(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildclist[\Nopttypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildparamsopt(\overname{\Nparamsopt(\Tlbrace, \namednode{\ids}{\Clist{\Nopttypedidentifier}}, \Trbrace)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.FuncArgs \label{sec:ASTRule.FuncArgs}}
\hypertarget{build-funcargs}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncargs}}{\vparsednode}) \aslto
  \overname{(\identifier\times\ty)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\Ntypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildfuncargs(\overname{\Nfuncargs(\Tlpar, \namednode{\ids}{\Clist{\Ntypedidentifier}}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.MaybeEmptyStmtList \label{sec:ASTRule.MaybeEmptyStmtList}}
\hypertarget{build-maybeemptystmtlist}{}
The function
\[
\buildmaybeemptystmtlist(\overname{\parsenode{\Nmaybeemptystmtlist}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\Nstmtlist)}{\vparsednode}) \astarrow
  \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\subsubsection{ASTRule.FuncBody \label{sec:ASTRule.FuncBody}}
\hypertarget{build-funcbody}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncbody}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
  \buildfuncbody(\overname{\Nfuncbody(\Tbegin, \namednode{\vstmts}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon)}{\vparsednode}) \astarrow \\
  \overname{\astof{\vmaybeemptystmtlist}}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We also define the following helper rules:
\begin{itemize}
  \item TypingRule.AnnotateAndDeclareFunc (see \secref{TypingRule.AnnotateAndDeclareFunc})
  \item TypingRule.AnnotateFuncSig (see \secref{TypingRule.AnnotateFuncSig})
  \item TypingRule.CheckParamDecls (see \secref{TypingRule.CheckParamDecls})
  \item TypingRule.TypesInFuncSig (see \secref{TypingRule.TypesInFuncSig})
  \item TypingRule.ParametersOfTy (see \secref{TypingRule.ParametersOfTy})
  \item TypingRule.ParametersOfExpr (see \secref{TypingRule.ParametersOfExpr})
  \item TypingRule.ParametersOfConstraint (see \secref{TypingRule.ParametersOfConstraint})
  \item TypingRule.AnnotateParams (see \secref{TypingRule.AnnotateParams})
  \item TypingRule.AnnotateOneParam (see \secref{TypingRule.AnnotateOneParam})
  \item TypingRule.AnnotateArgs (see \secref{TypingRule.AnnotateArgs})
  \item TypingRule.AnnotateOneArg (see \secref{TypingRule.AnnotateOneArg})
  \item TypingRule.AnnotateReturnType (see \secref{TypingRule.AnnotateReturnType})
  \item TypingRule.DeclareOneFunc (see \secref{TypingRule.DeclareOneFunc})
  \item TypingRule.SubprogramClash (see \secref{TypingRule.SubprogramClash})
  \item TypingRule.AddNewFunc (see \secref{TypingRule.AddNewFunc})
  \item TypingRule.CheckSetterHasGetter (see \secref{TypingRule.CheckSetterHasGetter})
  \item TypingRule.AddSubprogram (see \secref{TypingRule.AddSubprogram})
\end{itemize}

\subsubsection{TypingRule.AnnotateAndDeclareFunc \label{sec:TypingRule.AnnotateAndDeclareFunc}}
\hypertarget{def-annotateanddeclarefunc}{}
The function
\[
  \annotateanddeclarefunc(\overname{\globalstaticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a subprogram definition $\funcsig$ in the global static environment $\genv$,
yielding a new subprogram definition $\newfuncsig$ and modified static environment
$\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\genv$ as per
        \secref{TypingRule.AnnotateFuncSig} yields
        the environment $\tenvone$ and subprogram definition $\funcsigone$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigone$ in $\tenvone$
        as per \secref{TypingRule.DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError.
\end{itemize}
\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\tenvone, \funcsigone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}

\subsubsection{TypingRule.AnnotateFuncSig\label{sec:TypingRule.AnnotateFuncSig}}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\globalstaticenvs}{\genv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the global static environment $\genv$,
yielding a new function definition $\newfuncsig$ and modified static environment
$\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\tenv$ is the static environment which comprises of the global static environment $\genv$ and an empty local environment;
  \item applying $\annotatelimitexpr$ to $\funcsig.\funcrecurselimit$ in $\tenvone$ yields \\
        $\vrecurselimit$\ProseOrTypeError;
  \item checking that the parameters $\funcsig.\funcparameters$ are declared correctly using $\checkparamdecls$ yields $\True$\ProseOrTypeError;
  \item annotating and declaring the parameters $\funcsig.\funcparameters$ in $\tenv$ using \\ $\annotateparams$ yields environment $\tenvwithparams$ and the list of annotated parameters $\params$\ProseOrTypeError;
  \item annotating and declaring the arguments $\funcsig.\funcargs$ in $\tenvwithparams$ using $\annotateargs$ yields environment $\tenvwithargs$ and the list of annotated arguments $\vargs$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvwithparams$ using \\ $\annotatereturntype$ yields the result environment $\newenv$ and the annotated return type $\vreturntype$\ProseOrTypeError;
  \item $\newfuncsig$ is $\funcsig$ with the annotated parameters $\vparams$, annotated arguments $\vargs$, annotated return type $\vreturntype$,
        and $\vrecurselimit$ as its recursion limit.
\end{itemize}\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv\\
  \annotatelimitexpr(\tenvone, \funcsig.\funcrecurselimit) \typearrow \vrecurselimit \OrTypeError\\\\
  \checkparamdecls(\tenv, \funcsig) \typearrow \True \OrTypeError \\
  {
    \begin{array}{r}
    \annotateparams(\tenv, \funcsig.\funcparameters, (\tenv, \emptylist)) \typearrow \\
    (\tenvwithparams, \params) \OrTypeError
    \end{array}
  }\\
  {
    \begin{array}{r}
    \annotateargs(\tenvwithparams, \funcsig.\funcargs, (\tenvwithparams, \emptylist)) \typearrow \\
    (\tenvwithargs, \vargs) \OrTypeError
      \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvwithargs, \tenvwithparams, \funcsig.\funcreturntype) \typearrow \\
    (\newtenv, \vreturntype) \OrTypeError
    \end{array}
  }\\\\
  {
    \newfuncsig \eqdef
    \left\{
    \begin{array}{rcl}
      \funcname            &:& \funcsig.\funcname,\\
      \funcparameters      &:& \vparameters,\\
      \funcargs            &:& \vargs,\\
      \funcbody            &:& \funcsig.\funcbody,\\
      \funcreturntype      &:& \vreturntype,\\
      \funcsubprogramtype  &:& \funcsig.\funcsubprogramtype,\\
      \funcrecurselimit    &:& \vrecurselimit\\
      \funcbuiltin         &:& \funcsig.\funcbuiltin
    \end{array}
    \right\}
  }
}{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \argparams)
}
\end{mathpar}


\subsubsection{TypingRule.CheckParamDecls \label{sec:TypingRule.CheckParamDecls}}
The function
\[
\checkparamdecls(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks the parameters declared in $\funcsig$ for validity.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item Finding the list of types in $\funcsig$ using $\typesinfuncsig$ yields $\tys$;
  \item Applying $\paramsofty$ to each type in $\tys$ and concatenating the results yields the list of parameter identifiers $\params$;
  \item Finding unique elements in $\params$ yields $\paramsone$;
  \item Checking that the expected parameters $\paramsone$ and the declared parameters $\funcsig.\funcparameters$ are equal yields $\vb$\ProseOrTypeError.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \typesinfuncsig(\funcsig) \typearrow \tys \\
  \vi \in \listrange(\tys): \paramsofty(\tenv, \tty_i) \typearrow \params_i \\
  \params \eqdef \texttt{inferred\_params} \concat \ldots \concat \params_{\listlen{\tys}} \\
  \paramsone \eqdef \uniquelist(\params) \\\\
  \checktrans{\texttt{inferred\_params} = \funcsig.\funcparameters}{\BadParameterDecl} \checktransarrow \vb \OrTypeError
}{
  \checkparamdecls(\tenv, \funcsig) \typearrow \vb
}
\end{mathpar}

\subsubsection{TypingRule.TypesInFuncSig \label{sec:TypingRule.TypesInFuncSig}}
\hypertarget{def-typesinfuncsig}{}
The function
\[
\typesinfuncsig(\overname{\func}{\funcsig}) \aslto \overname{\ty^*}{\tys}
\]
returns the list of types $\tys$ in the function signature $\funcsig$.
Their ordering is return type first (if any), followed by argument types left-to-right.

\subsection{Prose}
Define $\tys$ as the return type (if any) concatenated with the argument types.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
    \left(
    \begin{array}{l}
    \funcsig.\funcreturntype \eqname \None \;\land\; \vreturntype \eqdef \emptylist \;\lor\\
    \funcsig.\funcreturntype \eqname \langle\ttyp\rangle \;\land\; \vreturntype \eqdef [\ttyp]
    \end{array}
    \right)
  } \\\\
  \argtypes \eqdef [(\Ignore, \ttyp)\in\funcsig.\funcargs: \ttyp]
}{
  \typesinfuncsig(\funcsig) \typearrow \overname{\vreturntype \concat \argtypes}{\tys}
}
\end{mathpar}


\subsubsection{TypingRule.ParametersOfTy \label{sec:TypingRule.ParametersOfTy}}
\hypertarget{def-paramsofty}{}
The function
\[
\paramsofty(\overname{\staticenvs}{\tenv}, \overname{\ty}{\tty}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the type $\tty$.
It assumes that $\tty$ appears in a function signature.

\subsection{Prose}
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{tbits}):
    \begin{itemize}
      \item $\tty$ is a bitvector type, that is, $\TBits(\ve, \Ignore)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
    \begin{itemize}
      \item $\tty$ is a tuple over a list of types $\tys$, that is, $\TTuple(\tys)$;
      \item applying $\paramsofty$ to each type $\tty_i$ in $\tys$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item All of the following apply (\textsc{tint\_constrained}):
    \begin{itemize}
      \item $\tty$ is a \wellconstrainedintegertype, that is, $\TInt(\wellconstrained(\cs))$;
      \item applying $\paramsofconstraint$ to each constraint $\vc_i$ in $\cs$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item All of the following apply (\textsc{other}):
    \begin{itemize}
      \item $\tty$ is not a tuple type, bit vector type, or \wellconstrainedintegertype;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[tbits]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofty(\tenv, \TBits(\ve, \Ignore)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \tty_i \in \tys: \paramsofty(\tenv, \tty_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TTuple(\tys)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_constrained]{
  \vc_i \in \cs: \paramsofconstraint(\tenv, \vc_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TInt(\wellconstrained(\cs)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\tty) \notin \{ \TBits, \TTuple \} \\
  \tty \neq \TInt(\wellconstrained(\Ignore))
}{
  \paramsofty(\tenv, \tty) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}


\subsubsection{TypingRule.ParametersOfExpr \label{sec:TypingRule.ParametersOfExpr}}
\hypertarget{def-paramsofexpr}{}
The function
\[
\paramsofexpr(\overname{\staticenvs}{\tenv}, \overname{\expr}{\ve}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the expression $\ve$.
It assumes that $\ve$ appears as $\TBits(\ve, \Ignore)$ or as part of a \wellconstrainedintegertype{} in a function signature.

\subsection{Prose}
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{eval}):
    \begin{itemize}
      \item $\ve$ is a variable, that is, $\EVar(\vx)$;
      \item if $\vx$ is undefined in $\tenv$ then $\ids$ is $[\vx]$, otherwise $\ids$ is $\emptylist$.
    \end{itemize}

  \item All of the following apply (\textsc{eunop}):
    \begin{itemize}
      \item $\ve$ is a unary operation, that is, $\EUnop(\Ignore, \ve)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item All of the following apply (\textsc{ebinop}):
    \begin{itemize}
      \item $\ve$ is a binary operation, that is, $\EBinop(\Ignore, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item define $\ids$ as the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}

  \item All of the following apply (\textsc{other}):
    \begin{itemize}
      \item $\ve$ is not a variable, unary operation, or binary operation;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[eval]{
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \ids \eqdef \choice{\vb}{[\vx]}{\emptylist}
}{
  \paramsofexpr(\tenv, \EVar(\vx)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop]{
  \paramsofexpr(\tenv, \veone) \typearrow \ids
}{
  \paramsofexpr(\tenv, \EUnop(\Ignore, \veone)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo
}{
  \paramsofexpr(\tenv, \EBinop(\Ignore, \veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \notin \{ \EVar, \EUnop, \EBinop \}
}{
  \paramsofexpr(\tenv, \ve) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}

\subsubsection{TypingRule.ParametersOfConstraint \label{sec:TypingRule.ParametersOfConstraint}}
\hypertarget{def-paramsofconstraint}{}
The function
\[
\paramsofconstraint(\overname{\staticenvs}{\tenv}, \overname{\intconstraint}{\vc}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the constraint $\vc$.
It assumes that $\vc$ appears within a \wellconstrainedintegertype{} in a function signature.

\subsection{Prose}
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{exact}):
    \begin{itemize}
      \item $\vc$ is an exact constraint, that is, $\ConstraintExact(\ve)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $ids$.
    \end{itemize}

  \item All of the following apply (\textsc{range}):
    \begin{itemize}
      \item $\vc$ is an range constraint, that is, $\ConstraintRange(\veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item $\ids$ is the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[exact]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofconstraint(\tenv, \ConstraintExact(\ve)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \\
}{
  \paramsofconstraint(\tenv, \ConstraintRange(\veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\subsection{Example}
In the following specification, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}, \texttt{B}\}$,
since they appear in the type \texttt{bits(A)}
of the argument \texttt{bv} and the type \texttt{bits(A+B)} of the argument \texttt{bv3}.

\VerbatimInput{\typingtests/TypingRule.AnnotateFuncSig.asl}

\subsection{Example}
Consider the following specification:
\VerbatimInput{\typingtests/TypingRule.AnnotateFuncSig.asl}

Finding parameters for each type in the signature of the function \texttt{signature\_example} yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\{\texttt{A}, \texttt{B}\}$ & \texttt{A} and \texttt{B} are variables \\
& & and neither is defined in the environment.\\
\end{tabular}
\end{center}

\subsubsection{TypingRule.AnnotateParams \label{sec:TypingRule.AnnotateParams}}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\params} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithparams} \times \overname{\identifier\times\ty}{\paramsone})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each parameter in $\params$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithparams$ and the annotated parameters $\paramsone$, together with any annotated parameters already in the accumulator $\acc$.
\ProseOtherwiseTypeError

\subsection{Example}
In the following specification, the list of explicitly defined parameters
of the function \texttt{signature\_example} is $\{\texttt{A},\texttt{B}\}$.
Therefore, $\tenvwithparams$ effectively reflects the added declarations \verb|let A: integer{A}| and \verb|let B: integer{B}|.

\VerbatimInput{\typingtests/TypingRule.AnnotateFuncSig.asl}

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\params$ is the empty list;
    \item $\tenvwithparams$ is $\newtenv$;
    \item $\paramsone$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\params$ is a list with $(\vx, \tyopt)$ as its \head\ and $\paramsp$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\tty$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \tty)$;
    \item applying $\annotateparams$ to $\paramsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithparams$ and $\paramsone$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \annotateparams(\tenv, \overname{\emptylist}{\params}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithparams}, \overname{\acc}{\paramsone})
}
\and
\inferrule[non\_empty]{
  \params \eqname [(\vx,\tyopt)] \concat \paramsp\\\\
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \tty)] \\\\
  \annotateparams(\tenv, \paramsp, (\newtenvp, \accp)) \typearrow (\tenvwithparams, \paramsone) \OrTypeError
}{
  \annotateparams(\tenv, \params, (\newtenv, \acc)) \typearrow (\tenvwithparams, \paramsone)
}
\end{mathpar}

\subsubsection{TypingRule.AnnotateOneParam \label{sec:TypingRule.AnnotateOneParam}}
The function
\hypertarget{def-annotateoneparam}{}
\[
\begin{array}{r}
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times \overname{\ty}{\tty})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the parameter given by $\vx$ and the \optional\ type $\tyopt$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated parameter type $\tty$ are returned.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{type\_parameterized}):
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an \unconstrainedintegertype{};
      \item $\tty$ is defined as the \parameterizedintegertype\ for the identifier $\vx$.
    \end{itemize}

    \item All of the following apply (\textsc{type\_annotated}):
    \begin{itemize}
      \item $\tyopt$ is the type $\langle\ttyp\rangle$, which is not the unconstrained integer type;
      \item annotating $\ttyp$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item checking that $\tty$ is a constrained integer in $\newtenv$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\tty$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[type\_parameterized]{
  (\tyopt = \None \lor \tyopt = \langle \unconstrainedinteger\rangle) \\
  \tty \eqdef \TInt(\parameterized(\vx))\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty)
}
\and
\inferrule[type\_annotated]{
  \ttyp \neq \unconstrainedinteger\\
  \annotatetype{\False, \tenv, \ttyp} \typearrow \tty \OrTypeError\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \langle\ttyp\rangle)) \typearrow (\newtenvp, \tty)
}
\end{mathpar}

\subsubsection{TypingRule.AnnotateArgs \label{sec:TypingRule.AnnotateArgs}}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \ty)^*}{\args} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithargs} \times \overname{(\identifier\times\ty)^*}{\vnewargs})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each argument in $\args$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithargs$ and the annotated arguments $\vnewargs$, together with any annotated arguments already in the accumulator $\acc$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\args$ is the empty list;
    \item $\tenvwithargs$ is $\newtenv$;
    \item $\newargs$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\args$ is a list with $(\vx, \tty)$ as its \head\ and $\vargsp$ as its \tail;
    \item applying $\annotateonearg$ to the argument $(\vx, \tty)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\ttyp$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \ttyp)$;
    \item applying $\annotateargs$ to $\vargsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithargs$ and $\vnewargs$.
  \end{itemize}
\end{itemize}

\subsection{Example}
In the following specification, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.

\VerbatimInput{\typingtests/TypingRule.AnnotateFuncSig.asl}

\subsection{Formally}
\begin{mathpar}
\inferrule[empty]{}{
  \annotateargs(\tenv, \overname{\emptylist}{\args}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithargs}, \overname{\acc}{\newargs})
}
\and
\inferrule[non\_empty]{
  \vargs \eqname [(\vx,\tty)] \concat \vargsp\\\\
  \annotateonearg(\tenv, \newtenv, (\vx, \tty)) \typearrow (\newtenvp, \ttyp) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \ttyp)] \\\\
  \annotateargs(\tenv, \vargsp, (\newtenvp, \accp)) \typearrow (\tenvwithargs, \newargs) \OrTypeError
}{
  \annotateargs(\tenv, \args, (\newtenv, \acc)) \typearrow (\tenvwithargs, \newargs)
}
\end{mathpar}

\subsubsection{TypingRule.AnnotateOneArg \label{sec:TypingRule.AnnotateOneArg}}
\hypertarget{def-annotateonearg}{}
The function
\[
\annotateonearg(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times\ \overname{\ty}{\ttyp})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the argument given by the identifier $\vx$ and the type $\tty$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated argument type $\ttyp$ are returned.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item annotating the type $\tty$ in $\tenv$ yields $\ttyp$\ProseOrTypeError;
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\ttyp$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow \ttyp \OrTypeError \\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\
  \addlocal(\newtenv, \vx, \ttyp, \LDKLet) \typearrow \newtenvp
}{
  \annotateonearg(\tenv, \newtenv, (\vx, \tty))
  \typearrow (\newtenvp, \ttyp)
}
\end{mathpar}

\subsubsection{TypingRule.AnnotateReturnType \label{sec:TypingRule.AnnotateReturnType}}
\hypertarget{def-annotatereturntype}{}
The function
\[
\begin{array}{rl}
\annotatereturntype(
  \overname{\staticenvs}{\tenvwithparams} \aslsep
  \overname{\staticenvs}{\tenvwithargs} \aslsep
  \overname{\langle\ty\rangle}{\vreturntype}
) & \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype})
\cup \overname{\TTypeError}{\TypeErrorConfig} &
\end{array}
\]
annotates the \optional\ return type $\vreturntype$ in the context of the static environment
$\tenvwithparams$ where all parameters have been declared.
It produces $\newtenv$, which is the input $\tenvwithargs$ (where all parameters and arguments have been declared) with the \optional{} annotated return type $\newreturntype$ added.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_return\_type}):
  \begin{itemize}
    \item $\vreturntype$ is $\None$;
    \item $\newtenv$ is $\tenvwithargs$;
    \item $\newreturntype$ is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{has\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvwithparams$ yields $\ttyp$\ProseOrTypeError;
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvwithargs$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$.
  \end{itemize}
\end{itemize}

\subsection{Formally}
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\None}{\vreturntype}) \typearrow \\
  (\overname{\tenvwithargs}{\newtenv}, \overname{\None}{\newreturntype})
  \end{array}
  }
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvwithparams, \tty} \typearrow \ttyp \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvwithargs, L^\tenvwithargs[\funcreturntype\mapsto\newreturntype])
}{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\langle\tty\rangle}{\returntype}) \typearrow \\
  (\newtenv, \newreturntype)
  \end{array}
  }
}
\end{mathpar}

\subsubsection{TypingRule.DeclareOneFunc \label{sec:TypingRule.DeclareOneFunc}}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$ can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
\ProseOtherwiseTypeError

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \SBASL(\bd),\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype, \\
                      & \funcbuiltin         &:& \vb \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item ensuring that each setter has a getter given $\funcsig$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item adding a subprogram with name $\namep$ and definition $\funcsigone$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}
\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checkvarnotingenv{G^\tenvone, \namep} \typearrow \True \OrTypeError\\\\
  \checksetterhasgetter(\tenvone, \funcsig) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
    \addsubprogram(\tenvone, \namep, \funcsigone) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}\lrmcomment{This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.}

\subsubsection{TypingRule.SubprogramClash \label{sec:TypingRule.SubprogramClash}}
\hypertarget{def-subprogramclash}{}
The function
\[
  \subprogramclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError

The function is only defined when there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item the subprogram type associated with the unique subprogram named by $\name$ is $\namesubpgmtype$;
  \item applying $\subprogramtypesclash$ to $\namesubpgmtype$ and $\subpgmtype$ yields \\
        $\True$\ProseTerminateAs{\False}
        (that is, if both $\namesubpgmtype$ and $\subpgmtype$ are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item $\nameargs$ is the list of pairs of types and identifiers associated with the function definition
        of $\name$ in $\tenv$;
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        $\nameformals$ in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}
\subsection{Formally}
\hypertarget{def-subprogramtypeclash}{}
We first introduce the helper predicate
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\subpgmtypeone} \aslsep
    \overname{\subprogramtype}{\subpgmtypetwo}
  ) \aslto \overname{\Bool}{\vb}
\]
which defines whether two subprogram types are considered to be clashing:
\begin{mathpar}
\inferrule{
  \vbone \eqdef
  {
    \begin{array}{l}
  (\subpgmtypeone=\STGetter \land \subpgmtypetwo=\STSetter)\ \lor\\
  (\subpgmtypeone=\STSetter \land \subpgmtypetwo=\STGetter)
    \end{array}
  }\\\\
  \vb \eqdef \neg\vbone
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  \namesubpgmtype \eqdef G^\tenv.\subprograms(\name).\subprogramtype\\
  \subprogramtypesclash(\namesubpgmtype, \subpgmtype) \typearrow \True \terminateas \False\\
  \nameargs \eqdef G^\tenv.\subprograms(\name).\funcargs\\
  \hasargclash(\formaltypes, \nameargs) \typearrow \vb
}{
  \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow \vb
}
\end{mathpar}\lrmcomment{This is related to \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}.}

\subsubsection{TypingRule.AddNewFunc \label{sec:TypingRule.AddNewFunc}}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError

\subsection{Prose}
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{first\_name}):
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{name\_exists}):
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\False$
          or a type error that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}
\subsection{Formally}
\newcommand\stringconcat[0]{\hyperlink{def-stringconcat}{\texttt{+}}}
\newcommand\stringofint[0]{\hyperlink{def-stringofnat}{\texttt{string\_of\_nat}}}

We use the following functions to construct a unique string for each subprogram:
\begin{itemize}
\hypertarget{def-stringconcat}{}
\item The function $\stringconcat : \Strings \times \Strings \rightarrow \Strings$
concatenates two strings.

\hypertarget{def-stringofnat}{}
\item The function $\stringofint : \N \rightarrow \Strings$ converts a natural number
to the corresponding string.
\end{itemize}

\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\overloadedsubprograms(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\end{mathpar}

\begin{mathpar}
\inferrule[name\_exists]{
  G^\tenv.\overloadedsubprograms(\name) = \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \texttt{"-"}\ \stringconcat\ \stringofint(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \left(\begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}\right)
  }\\\\
  \namep \in \othernames: \checktrans{\neg\vb_{\namep}}{\SubrogramDeclaredMultipleTimes} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto \othernames \cup \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}\lrmcomment{This is related to \identr{PGFC}.}

\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}

\subsubsection{TypingRule.CheckSetterHasGetter \label{sec:TypingRule.CheckSetterHasGetter}}
\hypertarget{def-checksetterhashgetter}{}
The function
\[
  \checksetterhasgetter(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
  \aslto \overname{\True}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the setter procedure given by $\funcsig$ has a corresponding getter,
returning $\True$ if this condition holds and a type error otherwise.

\subsection{Prose}
All of the following apply:
\begin{itemize}
  \item checking that the subprogram type of $\funcsig$ is $\STSetter$ has one of two outcomes:
        $\False$, which satisfies the premise;
        or $\True$, which short-circuits the entire rule
        (since the subprogram is not any kind of setter and no getter is required);
  \item \view\ the list of arguments of $\funcsig$ (that is, $\funcsig.\funcargs$) as follows:
        the \head\ is an argument that has the type $\rettype$;
        the \tail\ is a list with arguments that have the types $\argtypes$;
  \item applying $\subprogramforname$ to look up $\tenv$ for a subprogram with the name given by $\funcsig$ (that is, $\funcsig.\funcname$)
        yields a subprogram definition AST node $\funcsigp$\ProseOrTypeError;
  \item checking that $\funcsigp.\funcsubprogramtype$ is $\STGetter$ yields $\True$\ProseOrTypeError;
  \item define $\argtypesp$ as the list of types appearing in the signature of $\funcsigp$ (that is, in $\funcsigp.\funcargs$);
  \item checking, for each index $\vi$ in the indices for $\argtypes$, that the type at $\argtypes[\vi]$ and the type at $\argtypesp[\vi]$
        are \typeequivalent\ yields $\True$\ProseOrTypeError;
  \item checking that $\rettype$ and $\funcsigp.\funcreturntype$ are \typeequivalent\ yields \\
        $\True$\ProseOrTypeError;
  \item define $\vb$ as $\True$ (that is, unless the rule short-circuited with a type error).
\end{itemize}
\CodeSubsection{\CheckSetterHasGetterBegin}{\CheckSetterHasGetterEnd}{../Typing.ml}

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \issetter \eqdef \funcsig.\subprogramtype = \STSetter\\
  \booltrans{\issetter} \booltransarrow \False \terminateas \True\\\\
  \funcsig.\funcargs \eqname (\Ignore, \rettype) \concat \vargs\\
  \argtypes \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \subprogramforname(\tenv, \funcsig.\funcname, \argtypes) \typearrow (\Ignore, \Ignore, \funcsigp) \OrTypeError\\\\
  \checktrans{\funcsigp.\funcsubprogramtype = \STGetter}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\\\
  \argtypesp \eqdef [(\Ignore, \vt) \in \funcsigp.\funcargs : \vt]\\
  \vi\in\listrange(\argtypes): \typeequal(\argtypes[\vi], \argtypesp[\vi]) \typearrow \vb_\vi \OrTypeError\\\\
  \vi\in\listrange(\argtypes): \checktrans{\vb_\vi}{\SetterWithoutGetter} \typearrow \True \OrTypeError\\\\
  \typeequal(\rettype, \funcsigp.\funcreturntype) \typearrow \vb_\ret \OrTypeError\\\\
  \checktrans{\vb_\ret}{\SetterWithoutGetter} \typearrow \True \OrTypeError
}{
  \checksetterhasgetter(\tenv, \funcsig) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\subsubsection{TypingRule.AddSubprogram \label{sec:TypingRule.AddSubprogram}}
\hypertarget{def-addsubprogram}{}
The function
\[
  \addsubprogram(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\func}{\funcdef})
   \aslto
  \overname{\staticenvs}{\newtenv}
\]
updates the global environment of $\tenv$ by mapping the (unique) subprogram identifier $\name$
to the function definition $\funcdef$ in $\tenv$, resulting in a new static environment $\newtenv$.

\subsection{Prose}
$\newtenv$ is $\tenv$ with its $\subprograms$ component updated by binding $\name$ to $\funcdef$.

\subsection{Formally}
\begin{mathpar}
\inferrule{
  \newtenv \eqdef (G^\tenv.\subprograms[\name\mapsto\funcdef], L^\tenv)
}{
  \addsubprogram(\tenv, \name, \funcdef) \typearrow \newtenv
}
\end{mathpar}
